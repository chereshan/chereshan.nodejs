<!--<title>Глава 1. Введение в TypeScript</title>-->
<h1>Глава 1. Введение в TypeScript</h1>
<h2>Зачем программировать н TypeScript</h2>
<p>TypeScript — это язык, компилируемый в JavaScript. Он был выпущен корпорацией Microsoft в 2012 году как открытый проект. Программа, написанная в TypeScript, сперва должна быть транспилирована в JavaScript, и только потом ее можно выполнить в браузере или отдельном движке JavaScript.</p>
<p>Разница между транспиляцией и компиляцией в том, что последняя преобразовывает исходный код программы в машинный байт-код, в то время как транспиляция конвертирует программу из одного языка в другой (например, из TypeScript в JavaScript). Однако в сообществе TypeScript все же более распространен термин компиляция, поэтому его мы и будем использовать в этой книге для описания процесса преобразования TypeScript-кода в JavaScript.</p>
<p>Вам может стать интересно, зачем все эти сложности с написанием программы в TypeScript и его последующей компиляцией в JavaScript, если можно изначально написать эту программу в JavaScript. Чтоб ответить на этот вопрос, взглянем на TypeScript с высокоуровневой позиции.</p>
<p>TypeScript — это надмножество JavaScript, поэтому можно взять любой файл JavaScript вроде <span class="code">myProgram.js</span>, изменить его расширение с <span class="code">.js</span> на <span class="code">.ts</span>, и получившийся файл <span class="code">myProgram.ts</span>, скорее всего, станет рабочей программой TypeScript. Мы говорим «скорее всего», потому что оригинальный код JavaScript может иметь скрытые баги, связанные с типами (он может динамически изменять типы свойств объектов или добавлять новые после объявления объекта), а также другие проблемы, которые вскроются только после компиляции.</p>
<p>В общем смысле слово надмножество подразумевает, что это надмножество содержит все, что есть в самом множестве, плюс что-то еще. Рисунок 1.1 представляет TypeScript как надмножество ECMAScript, являющегося спецификацией для всех версий JavaScript. ES.Next представляет самые последние дополнения в ECMAScript, которые еще дорабатываются.</p>
<p>В дополнение к набору JavaScript, TypeScript также поддерживает статическую типизацию, в то время как JavaScript поддерживает только динамическую. Здесь слово «типизация» относится к присвоению типов переменным программы.</p>
<p>В языках программирования со статической типизацией тип переменной должен быть присвоен прежде, чем ее можно будет использовать. В TypeScript можно объявить переменную конкретного типа, и любая попытка присвоить ей значение другого типа приведет к появлению ошибки.</p>
<p>В JavaScript ситуация обстоит иначе, так как он ничего не знает о типах переменных вашей программы до начала ее выполнения. И даже в запущенной программе вы можете изменить тип переменной, просто присвоив ей значение другого типа. В TypeScript же, если вы объявляете переменную как <span class="code">string</span>, то попытка присвоить ей численное значение приведет к ошибке при компиляции.</p>
<pre><code >let customerId: string;
customerId = 123; // ошибка при компиляции</code></pre>
<p>JavaScript определяет тип переменной в процессе выполнения, и тип может динамически изменяться, как это показано в следующем примере:</p>
<pre><code >let customerId = "A15BN"; // OK, customerId является строкой.
customerId = 123; // OK, с этого момента она является числом.</code></pre>
<p>Теперь давайте рассмотрим JavaScript-функцию, которая применяет к цене скидку. У нее есть два аргумента, которые должны быть числами.</p>
<pre><code >function getFinalPrice(price, discount) {
    return price - price / discount;
}</code></pre>
<p>Это достаточно простая функция, но давайте представим, что кто-то вызвал ее, сообщив скидку в виде строки. В этом случае функция в среде выполнения выдаст ошибку NaN.</p>
<pre><code >console.log(getFinalPrice( 100, "10%")); // выводит NaN</code></pre>
<p>Это пример ошибки среды выполнения, вызванной неправильным использованием функции. В TypeScript вы могли бы присвоить аргументам функции типы и избежать тем самым появления подобной ошибки. Если кто-либо пытается вызвать функцию с неверным типом аргумента, то эта ошибка будет перехвачена сразу во время набора. Рассмотрим это на практике.</p>
<p>Разве не прекрасно, что ошибки перехватываются до выполнения программы? Мы убеждены, что да. Многие разработчики, имеющие опыт работы вJava, C++ и C#, воспринимают такое обнаружение ошибок как само собой разумеющееся, и именно эта особенность является одной из основных причин выбора TypeScript.</p>
<p>Некоторые матерые JS-разработчики говорят, что TypeScript только замедляет рабочий процесс, требуя объявлений типов, и что в JavaScript их продуктивность выше. Но при этом стоит помнить, что типы в TypeScript используются по желанию, то есть вы можете продолжить писать на JavaScript, но с участием tsc в рабочем процессе. Зачем? Потому, что вы сможете использовать новейший синтаксис ECMAScript (вроде async и await), а затем транспилировать ваш JavaScript код в ES5, чтобы он мог быть запущен в более старых браузерах</p>
<p>Но многие веб-разработчики, не являющиеся JavaScript-ниндзя, смогут по достоинству оценить помощь, предлагаемую TypeScript. По правде говоря, все строго типизированные языки предоставляют лучшую поддержку инструментов, повышая тем самым производительность (даже для ниндзя). Упомянув это, мы бы хотели отметить, что TypeScript дает вам преимущества статически типизированных языков, где и когда это нужно, не препятствуя при этом использованию старых добрых динамических объектов.</p>
<p>Летом 2017 года в спецификацию ECMAScript ES2017 (ES8) были введены
    ключевые слова async и await. Ведущим браузерам при этом потребовалось
    более года, чтобы внедрить их поддержку, TypeScript же начал поддерживать
    их с ноября 2015 года. TypeScript-разработчики получили возможность использовать эти ключевые слова на три года раньше тех, кто ожидал появления
    их поддержки в браузерах. Самое лучшее в этом то, что вы можете использовать
    будущий синтаксис JavaScript в сегодняшнем коде TypeScript и транспилировать
    его в более старые версии синтаксиса JavaScript (вроде ES5), которые поддерживаются всеми браузерами.</p>
<p>С учетом сказанного хотелось бы сделать четкое разграничение между синтаксисом, описанным в последних спецификациях ECMAScript, и синтаксисом,
    присущим исключительно TypeScript. Рекомендуем для начала ознакомиться
    с приложением, чтобы знать, где заканчивается ECMAScript и начинается
    TypeScript.
</p>
<p>Несмотря на то что движки JavaScript отлично справляются с угадыванием
    типов переменных по их значениям, инструменты разработки не могут оказать
    полноценную помощь, не зная этих типов. В средних и крупных приложениях
    этот недочет JavaScript снижает производительность разработчиков.</p>
<p>TypeScript следует новейшим спецификациям ECMAScript и добавляет к ним
    типы, интерфейсы, декораторы, переменные членов классов (поля), обобщенные
    типы, перечисления, ключевые слова public, protected, private и другие возможности.</p>


<h2>Начало работы с TypeScript</h2>
<p>Создаем пустой проект WebStorm с некоторым именем, например, <span class="code">ts-example</span>. В нем вызываем комнду</p>
<pre><code >npm init</code></pre>
<p>Эта команда иницилизирует проект Node и создает файл package.json. </p>
<p>После этого добавим в наш проект поддержку TS. Для этого введем:</p>
<pre><code >npm i typescript</code></pre>
<p>Чтобы иницилизировать TS и его config надо, чтобы даный пкет был установлен глобально:</p>
<pre><code >npm install -g typescript</code></pre>
<p>Далее иницилизируем ts командой:</p>
<pre><code >tsc --init</code></pre>
<p>Был создан tsconfig.json, в котором пока активны только поля target и module:</p>
<pre><code >"target": "es2016",
"module": "commonjs",</code></pre>
<p>Чтобы продемонстрировать то, как работает TS, создадим файл test.ts и пропишем в нем следующий код:</p>
<pre><code >"use strict"
let lname = 'John';</code></pre>
<p>Вызовем комамну <span class="code">tsc</span> и после чего получим транспилированный в js скрипт.</p>

<h3>Типы TS</h3>
<ul>
    <li><span class="code">string</span></li>
    <li><span class="code">number</span></li>
    <li><span class="code">boolean</span></li>
    <li><span class="code">array</span></li>
    <li><span class="code">enum</span></li>
    <li><span class="code">tuple</span></li>
    <li><span class="code">any</span></li>
    <li><span class="code">void</span></li>
    <li><span class="code">never</span></li>
</ul>
<p>ts имеет способность предполагать типы исходя из задаваемого значения.</p>

<h3>Функции TS</h3>
<h4>Типы параметров</h4>
