<!--<title>Глава 0. Не сортировано</title>-->
<h1>Глава 0. Не сортировано</h1>

<h2>Общий обзор AngularJS</h2>

<p>Теперь вернемся к основной теме нашей книги: фреймворку Angular. Этот раздел —
  единственный, посвященный AngularJS.
  Перечислим причины, по которым AngularJS стал таким популярным</p>
<ul>
  <li>Фреймворк содержит механизм создания пользовательских тегов и атрибутов HTML с помощью концепции <i>директив</i>, которая позволяет расширять набор тегов HTML в соответствии с потребностями приложения.</li>
  <li>AngularJS не слишком глубоко внедряется. Вы можете добавить атрибут <span class="code">ng-app</span>
    к любому тегу <span class="code">&lt;div></span>, и AngularJS будет управлять содержимым лишь этого
      тега. Остальная часть веб-страницы может быть написана на чистом HTML
      и JavaScript.</li>
  <li>Фреймворк позволяет легко связывать данные с представлениями. Изменение
    данных приводит к автоматическому обновлению соответствующего элемента
    представления, и наоборот</li>
  <li>AngularJS поставляется с настраиваемым маршрутизатором; он разрешает
    соотносить шаблоны URL с соответствующими компонентами приложения,
    которые изменяют представление на веб-странице в зависимости от установленных соотношений.</li>
  <li>Поток данных приложения определяется в контроллерах, они являются объектами JavaScript, содержащими свойства и функции</li>
  <li>Приложения, созданные с помощью AngularJS, используют иерархию областей
    видимости — объектов, необходимых для сохранения данных, общих для контроллеров и представлений.</li>
  <li>Фреймворк содержит модуль внедрения зависимостей, который позволяет разрабатывать слабо связанные приложения.</li>
</ul>

<p>В то время как в jQuery были упрощены манипуляции с объектом DOM,
  AngularJS позволяет разработчикам отвязывать логику приложения от интерфейса путем структурирования приложения по шаблону проектирования MVC. На рис. 1.1 показан пример рабочего потока приложения, созданного с помощью
  этого фреймворка.</p>

<a href='https://postimg.cc/JyCKDzcF' target='_blank'><img src='https://i.postimg.cc/N05nnyyQ/image.png' border='0' alt='image'/></a>
<p>AngularJS может управлять всем веб-приложением. Для этого включите директиву ng-app в HTML-тег <span class="code">&lt;body></span>:</p>
<pre><code >&lt;body ng-app="ProductApp"></code></pre>
<ol>
  <li>чтобы получить данные о продукте, пользователь загружает приложение</li>
  <li>вводит идентификатор продукта</li>
  <li>Представление оповещает
    контроллер</li>
  <li>который обновляет модель </li>
  <li>и выполняет HTTP-запрос на удаленный сервер, используя сервис <span class="code">$http</span>. AngularJS заполняет свойства
    модели на основе полученных данных</li>
  <li>и изменения в модели автоматически отразятся в пользовательском интерфейсе с помощью связывающего выражения</li>
  <li>После этого пользователь увидит данные о запрошенном продукте</li>
</ol>
<p>AngularJS автоматически обновляет представление при модификации данных
  модели. Изменения в пользовательском интерфейсе вносятся в модель, если
  пользователь меняет данные в элементах управления представления, связанных
  с вводом. Такой двунаправленный механизм обновлений называется двухсторонней
  привязкой, он показан на рис. 1.2.</p>
<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/j2gNBjnr/image.png' border='0' alt='image'/></a>
<p>В AngularJS модель и представление тесно связаны, поскольку двухсторонняя
  привязка означает, что один из элементов пары автоматически обновляет другой.
  Подобная возможность автоматического обновления очень удобна, но имеет свою
  цену.</p>
<p>При каждом обновлении модели фреймворк запускает специальный цикл
  $digest, который проходит по всему приложению, применяет привязку данных и обновляет DOM, когда это необходимо. Каскадные обновления приводят к нескольким запускам цикла $digest, что может повлиять на производительность
  крупных приложений, использующих двухстороннюю привязку</p>
<p>Манипуляции с объектом DOM браузера — самая медленная операция. Чем меньше приложение обновляет DOM, тем лучше оно работает.</p>
<p>Данные модели существуют в контексте определенного объекта $scope, области видимости AngularJS формируют иерархию объектов. Элемент $rootScope
  создается для целого приложения. Контроллеры и директивы (пользовательские
  компоненты) имеют собственные объекты $scope, и принципы работы областей
  видимости в фреймворке могут быть сложны для понимания.</p>
<p>Вы можете реализовать модульность, создавая и загружая объекты module.
  Когда конкретный модуль зависит от других объектов (таких как контроллеры,
  модули или сервисы), экземпляры этих объектов создаются и внедряются путем
  использования механизма внедрения зависимостей, представленного в AngularJS.
  В следующем фрагменте кода показывается один из способов, которым фреймворк
  внедряет один объект в другой:</p>
  <pre><code >var seacrhController = function ($scope){
      //определение функции-конструктора, имеющую параметр $scope
    }
    seacrhController['$inject']=['$scope'];
    //добавляет свойство $inject в контроллер, довая команду внедрить объект $scope в функцию-конструктор
    angular.module('auction').controller('searchController', seacrhController)
    //указывает, что объект searchController должен стать контроллером модуля аукциона</code></pre>
<p>В этом фрагменте кода квадратными скобками обозначен массив, и AngularJS
  может внедрять сразу несколько объектов следующим образом: <span class="code">['$scope', 'myCustomService']</span>.</p>
<p>Данный фреймворк зачастую используется для создания одностраничных приложений, в которых лишь отдельные фрагменты страницы (подпредставления)
  обновляются в результате действий пользователя или из-за отправки данных
  на сервер. Хорошим примером таких подпредставлений является веб-приложение,
  показывающее котировки: при продаже акции обновляется лишь элемент, содержащий значение цены</p>
<p>Навигация между представлениями в AngularJS выполняется с помощью
  конфигурирования компонента маршрутизатора ng-route. Можно указать количество параметров .when, чтобы направить приложение к соответствующему
  представлению в зависимости от шаблона URL. В следующем фрагменте кода маршрутизатору предписывается использовать разметку из файла home.html и контроллер HomeController, если только URL не содержит элемент /search. В этом
  случае представление отрисует страницу search.html, и в качестве контроллера
  будет применен объект SearchController:</p>
  <pre><code >angular.module('auction', ['ngRoute'])
            .config(['$routeProvider', function ($routeProvider) {
              $routeProvider
                      .when('/', {
                        templateUrl: 'views/home.html',
                        controller: 'HomeController' })
                      .when('/search', {
                        templateUrl: 'views/search.html',
                        controller: 'SearchController' })
                      .otherwise({
                        redirectTo: '/'
                      });
            }]);</code></pre>
<p>Маршрутизатор фреймворка поддерживает глубокое связывание, которое представляет собой способность поместить в закладки не только целую веб-страницу,
  но и определенное состояние внутри нее.
  Теперь, после общего обзора AngularJS, взглянем, что нам может предложить
  Angular</p>
<h3>Общий обзор Angular</h3>


<p>Фреймворк Angular гораздо производительнее, чем AngularJS. Он более понятен
  для освоения; архитектура приложений была упрощена, и код с его помощью легче
  читать и писать</p>
<h4>Упрощение кода</h4>
<p>Во-первых, Angular-приложение содержит стандартные модули в форматах
  ECMAScript 6 (ES6), Asynchronous Module Definition (AMD) и CommonJS.
  Обычно один модуль находится в одном файле. Нет необходимости прибегать
  к синтаксису, характерному для фреймворков, для загрузки и использования
  модулей. Запустите универсальный загрузчик модулей SystemJS (он рассматривается в главе 2) и добавьте операторы импорта, чтобы применить функциональные
  возможности, реализованные в загруженных модулях. Вам не нужно волноваться насчет правильного использования тегов <span class="code">&lt;script></span> в ваших файлах HTML. Если
  для модуля A требуются функции, содержащиеся в модуле B, просто импортируйте
  модуль B в модуль A.</p>
<p>Файл HTML для посадочной страницы вашего приложения содержит модули
  Angular и их зависимости. Код приложения загружается путем загрузки корневого
  модуля приложения. Все необходимые компоненты и сервисы будут загружены на
  основании объявлений в операторах module и import.</p>
<p>В следующем фрагменте кода показано типичное содержимое файла index.html
  приложения, созданного с помощью Angular, куда вы можете включить требуемые
  модули фреймворка. В сценарий systemjs.config.js входит конфигурация загрузчика SystemJS. Вызов System.import('app') загружает высокоуровневый элемент
  приложения, сконфигурированный в файле systemjs.config.js (показан в главе 2).
  Пользовательский тег <span class="code">&lt;app></span> представляет собой значение, определенное в свойстве
    selector корневого компонента:</p>
<pre><code >&lt;!DOCTYPE html>
&lt;html>
&lt;head>
  &lt;title>Angular seed project&lt;/title>
  &lt;meta charset="UTF-8">
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;script src="node_modules/core-js/client/shim.min.js">&lt;/script>
  &lt;script src="node_modules/zone.js/dist/zone.js">&lt;/script>
  &lt;script src="node_modules/typescript/lib/typescript.js">&lt;/script>
  &lt;script src="node_modules/systemjs/dist/system.src.js">&lt;/script>
  &lt;script src="node_modules/rxjs/bundles/Rx.js">&lt;/script>
  &lt;script src="systemjs.config.js">&lt;/script>
  &lt;script>
    System.import('app').catch(function(err){ console.error(err); });
  &lt;/script>
&lt;/head>
&lt;body>
&lt;app>Loading...&lt;/app>
&lt;/body>
&lt;/html></code></pre>
<p>HTML-фрагмент в каждом приложении содержится либо внутри компонента
  (свойство template), либо в файле, на который ссылается этот компонент с помощью свойства templateURL. Второй вариант позволяет дизайнерам работать над
  интерфейсом вашего приложения, не изучая Angular.</p>
<p>Компонент Angular является центральным элементом новой архитектуры.
  На рис. 1.3 показана общая схема примера Angular-приложения, состоящего из
  четырех компонентов и двух сервисов; все они находятся внутри модуля внедрения зависимостей (Dependency Injection, DI). Этот модуль внедряет сервис Http
  в сервис Service1, а тот, в свою очередь, внедряется в компонент GrandChild2. Эта схема отличается от приведенной рис. 1.1, где был показан принцип работы
  AngularJS.</p>

<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/c4T0ynJ3/image.png' border='0' alt='image'/></a>

<p>Самый простой способ объявления компонента заключается в написании класса
  с помощью TypeScript (можно использовать ES5, ES6 или Dart). В приложении Б
  мы кратко расскажем о том, как писать компоненты Angular на TypeScript, а также приведем пример кода. Попробуйте понять этот код, прочитав минимальное
  количество пояснений.</p>

<p>Класс TypeScript содержит аннотацию метаданных @NgModule и представляет
  собой модуль. Класс TypeScript включает аннотацию метаданных @Component
  и представляет собой компонент. Аннотация @Component (также известная как
  декоратор) имеет свойство template, указывающее на фрагмент HTML, который
  должен быть отрисован в браузере.</p>

<p>Аннотации метаданных дают возможность изменять свойства компонентов во
  время разработки. Шаблон HTML может включать в себя выражения для привязки
  данных, окруженных двойными фигурными скобками. Ссылки на обработчики
  событий помещены в свойство template аннотации @Component и реализованы как
  методы класса. Еще одним примером аннотации метаданных выступает аннотация
  @Injectable, позволяющая отметить элемент, с которым должен работать модуль DI.</p>

<p>
  Аннотация @Component также содержит селектор, объявляющий имя пользовательского тега, который будет использован в документе HTML. Когда Angular
  видит элемент HTML, чье имя соответствует селектору, он знает, какой элемент его реализует. В следующем фрагменте HTML показан родительский компонент
  <span class="code">&lt;auction-application></span> с одним потомком, <span class="code">&lt;search-product></span>:</p>
<pre><code >&lt;body>
&lt;auction-application>
  &lt;search-product [productID]= "123">&lt;/search-product>
&lt;/auction-application>
&lt;/body></code></pre>


<p>Предок отправляет данные потомкам путем привязки к входным свойствам потомка (обратите внимание на квадратные скобки в предыдущем фрагменте кода),
  а потомок общается с предками, отправляя события с помощью своих выходных
  свойств.</p>
<p>В конце главы вы найдете рис. 1.7, на котором показана главная страница (компонент-предок), чьи элементы-потомки окружены толстыми границами.</p>
<p>В следующем фрагменте кода показывается класс SearchComponent. Вы можете
  включить его в документ HTML как <span class="code">&lt;search-product></span>, поскольку его объявление
    содержит свойство selector с таким же именем:</p>
  <pre><code >@Component({
      selector: 'search-product',
      template:
              `&lt;form>
   &lt;div>
   &lt;input id="prodToFind" #prod>
   &lt;button (click)="findProduct(prod.value)">Find Product&lt;/button>
   Product name: {{product.name}}
   &lt;/div>
   `&lt;/form>
    })
    class SearchComponent {
      @Input() productID: number;
      product: Product; // Опустим код класса Product
      findProduct(prodName: string){
        // Здесь будет расположен реализация обработчика щелчков кнопкой мыши
      }
      // Здесь будет расположен другой код
    }</code></pre>



<p>Если вы знакомы с любым объектно-ориентированным языком, имеющим
  классы, то должны понять большую часть предыдущего фрагмента кода. Аннотированный класс SearchComponent объявляет переменную product, которая может
  представлять объект с несколькими свойствами, и одно из них (name) привязано
  к представлению ({{product.name}}). Локальная переменная шаблона #prod будет
  иметь ссылку на элемент <input>, поэтому вам не нужно запрашивать DOM для
  того, чтобы получить введенное значение.</p>
<p>Выражение (click) представляет собой событие щелчка кнопкой мыши.
  Функция обработчика событий получает значение аргумента из входного параметра productID, который будет заполнен родительским элементом путем
  привязки.</p>
<p>Мы кратко рассмотрели пример компонента. Более подробное описание содержимого этих элементов будет представлено в начале следующей главы. Не стоит
  беспокоиться, если вы раньше никогда не работали с классами, — данная тема раскрывается в приложениях А и Б. На рис. 1.4 показана внутренняя работа примера
  компонента, выполняющего поиск некоторых продуктов.</p>
<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/ydFCfJ5k/image.png' border='0' alt='image'/></a>
<p>Компонент отрисовывает данные продукта, полученные из сервиса, представленного классом. В TypeScript класс Product будет выглядеть следующим
  образом:</p>
<pre><code >class Product{
  id: number,
  name: string;
  description: string;
  bid: number;
  price: number;
// Здесь будут расположены конструктор и другие методы
}</code></pre>
<p>Обратите внимание: TypeScript позволяет объявить переменные класса с помощью
  типов. Чтобы указать компоненту пользовательского интерфейса SearchComponent
  на данные, можно объявить переменную класса, такую как product:</p>

<h2>Что нужно знать перед изучением Angular?</h2>
<p>Ожидается, что вы знакомы с HTML, CSS и TypeScript</p>


<h2>Видео</h2>
<p>Компонентны Angular: шаблоны, связывание данных, формы, маршрутизация, Observables, PWA</p>
<p>Браузеры не понимают TypeScript. Код TS транспилируется в JS</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>

<h2>Типичные задачи и их решения с помощью Angular</h2>

<table class="table table-bordered">
  <thead>
  <tr>
    <th>Задача</th>
    <th>Способ решения Angular 2</th>
    <th>Способ решение Angular>17</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>Реализация бизнес-логики</td>
    <td>Создайте класс, и Angular создаст его объект и внедрит в компонент. Вы можете также использовать оператор <span class="code">new</span></td>
    <td>Создайте класс с декоратором <span class="code">@Injectable()</span> для сервиса. Используйте <span class="code">inject()</span> для внедрения зависимостей или конструктор</td>
  </tr>
  <tr>
    <td>Реализация компонента с пользовательским интерфейсом</td>
    <td>Создайте класс с аннотацией <span class="code">@Component</span></td>
    <td>Создайте класс с декоратором <span class="code">@Component()</span>. В Angular 17 можно использовать автономные компоненты (<span class="code">standalone: true</span>).</td>
  </tr>
  <tr>
    <td>Определение шаблона HTML для отрисовки компонентов</td>
    <td>Укажите либо код HTML в аннотации <span class="code">@Component</span> с помощью свойства <span class="code">template</span>, либо имя файла HTML в <span class="code">templateURL</span></td>
    <td>Используйте встроенный шаблон в декораторе <span class="code">template</span> или внешний файл через <span class="code">templateUrl</span>. Поддерживается новый синтаксис управления потоком (<span class="code">@if</span>, <span class="code">@for</span>).</td>
  </tr>
  <tr>
    <td>Манипуляции с HTML</td>
    <td>Примените одну из структурных директив (<span class="code">*ngIf</span>, <span class="code">*ngFor</span>) или создайте собственный класс с аннотацией <span class="code">@Directive</span></td>
    <td>Используйте структурные директивы (<span class="code">@if</span>, <span class="code">@for</span>, <span class="code">@switch</span>) или атрибутные директивы (<span class="code">[class]</span>, <span class="code">[style]</span>).</td>
  </tr>
  <tr>
    <td>Отсылка к переменной класса текущего объекта</td>
    <td>Задействуйте ключевое слово <span class="code">this: this.userName="Mary";</span></td>
    <td>Используйте интерполяцию <span class="code">{{ выражение }}</span> или привязку свойств <span class="code">[property]="выражение"</span>.</td>
  </tr>
  <tr>
    <td>Настройка маршрутизатора для приложения с одной страницей</td>
    <td>Сконфигурируйте основанный на компонентах маршрутизатор, позволяющий соотносить компоненты и сегменты URL, и добавьте тег <span class="code">&lt;router-outlet&gt;</span> в шаблон там, где хотите отрисовать элемент</td>
    <td>Используйте <span class="code">RouterModule</span> с <span class="code">Routes</span> или автономную маршрутизацию. Добавьте <span class="code">&lt;router-outlet></span> в шаблон. Поддерживается новый функциональный подход к защите маршрутов. .</td>
  </tr>
  <tr>
    <td>Отображение значения свойства компонента пользовательского интерфейса</td>
    <td>Разместите переменные внутри двойных фигурных скобок внутри шаблона: <span class="code">{{customerName}}</span></td>
    <td>Используйте интерполяцию <span class="code">{{ propertyName }}</span> или привязку свойств <span class="code">[property]="value"</span>. </td>
  </tr>
  <tr>
    <td>Привязка свойства компонента к пользовательскому интерфейсу</td>
    <td>Используйте привязки свойств в квадратные скобки: <span class="code">&lt;input [value]="greeting"&gt;</span></td>
    <td>Используйте <span class="code">[property]="value"</span> для входных свойств и <span class="code">@Input()</span> декоратор. Поддерживается сигнальный API (<span class="code">@Input.required()</span>). </td>
  </tr>
  <tr>
    <td>Обработка событий пользовательского интерфейса</td>
    <td>Окружите имя события круглыми скобками и укажите обработчик: <span class="code">&lt;button (click)="onClickEvent()"&gt;Get Products&lt;/button&gt;</span></td>
    <td>Используйте <span class="code">(event)="handler()"</span> для привязки событий.</td>
  </tr>
  <tr>
    <td>Использование двусторонней привязки</td>
    <td>Задействуйте нотацию <span class="code">[()] : [(ngModel)] = "myComponentProperty"</span></td>
    <td>Имплементируйте интерфейсы жизненного цикла (<span class="code">ngOnInit</span>, <span class="code">ngOnDestroy</span> и т.д.) или используйте хуки композиции (<span class="code">inject()</span> с <span class="code"> effect()</span>).</td>
  </tr>
  <tr>
    <td>Передача данных компоненту</td>
    <td>Укажите для компонента аннотацию <span class="code">@Input</span> и привяжите к ней значения</td>
    <td>Используйте <span class="code">@Input()</span> декоратор. Для реактивных данных используйте сигналы (<span class="code">signal()</span>). </td>
  </tr>
  <tr>
    <td>Передача данных из компонента</td>
    <td>Укажите для компонента аннотацию <span class="code">@Output</span> и используйте <span class="code">EventEmitter</span> для отправки событий</td>
    <td>Используйте <span class="code">@Output()</span> с <span class="code">EventEmitter</span> или сигналы для реактивного подхода. </td>
  </tr>
  <tr>
    <td>Создание запроса HTTP</td>
    <td>Внедрите объект HTTP в компонент и вызовите один из методов HTTP: <span class="code">this.http.get('/products')</span></td>
    <td>Внедрите HttpClient, используйте методы <span class="code">get()</span>, <span class="code">post()</span> и т.д. Поддерживается новый автономный импорт <span class="code">provideHttpClient()</span>.</td>
  </tr>
  <tr>
    <td>Обработка ответов HTTP</td>
    <td>Примените метод <span class="code">subscribe()</span> для результата, который поступает в формате наблюдаемого потока: <span class="code">this.http.get('/products').subscribe(...)</span></td>
    <td>Используйте <span class="code">pipe()</span> с операторами RxJS или новый синтаксис async в шаблонах (<span class="code">@if (data$ | async)</span>).</td>
  </tr>
  <tr>
    <td>Передача фрагмента HTML компоненту-потомку</td>
    <td>Используйте тег <span class="code">&lt;ng-content&gt;</span> в шаблоне потомка</td>
    <td>Используйте проекцию контента через <span class="code">&lt;ng-content></span> или именованные слоты.</td>
  </tr>
  <tr>
    <td>Перехватывание изменения</td>
    <td>Задействуйте привязки для жизненного цикла элемента</td>
    <td>Используйте сигналы (<span class="code">signal()</span>, <span class="code">computed()</span>) или зоны (<span class="code">NgZone</span>). Поддерживается новый режим оптимизации производительности. </td>
  </tr>
  <tr>
    <td>Развертывание</td>
    <td>Используйте сторонние упаковщики наподобие Webpack для упаковки файлов приложений и фреймворков в пакеты JavaScript</td>
    <td>Используйте <span class="code">ng build</span> с флагами оптимизации. Поддерживается SSR (Server-Side Rendering) через <span class="code">@angular/ssr</span>. </td>
  </tr>
  </tbody>
</table>



