<!--<title>Глава 1. Введение в Angular</title>-->
<h1>Глава 1. Введение в Angular</h1>

<h2>Что такое Angular?</h2>
<p>Angular — фреймворк с открытым исходным кодом, написанный на JavaScript
и поддерживаемый компанией Google. Он представляет собой полностью переработанную версию своего популярного предшественника, AngularJS. С помощью
Angular вы можете разрабатывать приложения на JavaScript, Dart или TypeScript.</p>
<h3>Фреймворки</h3>
<p>Обязательно ли использовать фреймворки? Нет, можно написать клиентскую часть веб-приложений на чистом JavaScript. В этом случае не нужно изучать что-то новое, достаточно знания языка JavaScript. Отказ от фреймворков приведет к возникновению трудностей при поддержке совместимости между браузерами, а также к увеличению циклов разработки. Фреймворки же позволяют полностью управлять архитектурой, шаблонами проектирования и стилями кода вашего приложения. Большая часть современных веб-приложений написаны при сочетании нескольких фреймворков и библиотек</p>
<p><b>Полноценные фреймворки</b> содержат все, что понадобится для разработки веб-приложения. Они предоставляют возможность легко структурировать ваш код и <i>поставляются вместе с библиотекой, содержащей компоненты и инструменты для сборки и развертывания приложения</i>.</p>
<ul>
    <p><b>Примеры полноценных фреймворков:</b></p>
    <li><i>Ext JS</i> - полноценный фреймворк, созданный и поддерживаемый компанией Sencha. Он поставляется вместе с полным набором UI-компонентов, включающим продвинутые сетки данных и таблицы (их наличие критически важно для разработки промышленных приложений для офисов). Ext JS значительно увеличивает объем кода программы — вам не удастся найти созданное с его помощью приложение, которое весит меньше 1 Мбайт. Кроме того, данный фреймворк довольно глубоко внедряется — будет трудно при необходимости переключиться на другой инструмент.</li>
    <li><i>Sencha Touch</i> - фреймворк, также предлагаемый Sencha, используемый при создании веб-приложений для мобильных устройств</li>
</ul>
<p><b>Легковесные фреймворки</b> позволяют структурировать веб-приложение, предлагают способ настройки навигации между представлениями, а также разбивают приложения на слои, реализуя шаблон проектирования <span data-tippy-content='«модель — представление — контроллер»'>MVC</span>. Кроме того, существует группа легковесных фреймворков, которые специализируются на тестировании приложений, написанных на JavaScript.</p>
<ul>
    <p><b>Примеры легковесных фреймворков:</b></p>
    <li><b>Angular</b> — фреймворк с открытым исходным кодом, предназначенный для разработки веб-приложений. Упрощает создание пользовательских компонентов, которые могут быть добавлены в документы HTML, а также реализацию логики приложения. Активно использует привязку данных, содержит модуль внедрения зависимостей, поддерживает модульность и предоставляет механизм для настройки маршрутизации. AngularJS был основан на шаблоне MVC, в отличие от Angular. Последний не содержит элементов для создания пользовательского интерфейса.</li>
    <li><b>Ember.js</b> — это фреймворк с открытым исходным кодом, основанный на MVC; служит для разработки веб-приложений. Содержит механизм маршрутизации и поддерживает двухстороннюю привязку данных. В коде этого фреймворка используется множество соглашений, что повышает продуктивность разработчиков ПО.</li>
    <li><b>Jasmine</b> — фреймворк с открытым исходным кодом, предназначенный для тестирования кода JavaScript. Не требует наличия объекта DOM. Содержит набор функций, проверяющих, ведут ли себя части приложения запланированным образом. Нередко используется вместе с Karma — программой для запуска тестов, которая позволяет проводить проверки в разных браузерах.</li>
</ul>

<h3>Часто используемые в связке с Angular библиотеки</h3>
<ul>
    <li><b>jQuery</b> — популярная библиотека для JavaScript. Довольно проста в использовании и не требует значительного изменения стиля написания кода для веб-программ. Позволяет находить объекты DOM и манипулировать ими, а также обрабатывать события браузера и справляться с несовместимостью браузеров.</li>
    <li><b>Bootstrap</b> — библиотека компонентов для создания пользовательского интерфейса с открытым исходным кодом, разработанная компанией Twitter. Они строятся согласно принципам адаптивного веб-дизайна, что значительно повышает ценность библиотеки, если ваше веб-приложение должно автоматически подстраивать свой макет в зависимости от размера экрана устройства пользователя.</li>
    <li><b>React</b> — созданная компанией Facebook библиотека с открытым исходным кодом, предназначенная для сборки пользовательских интерфейсов. Представляет собой слой V в аббревиатуре MVC. Не внедряется глубоко, и ее можно применять вместе с любой другой библиотекой или фреймворком. Создает собственный виртуальный объект DOM, минимизируя доступ к объекту DOM браузера, в результате чего повышается производительность. Что касается отрисовки содержимого, React вводит формат JSX — расширение синтаксиса JavaScript, которое выглядит как XML. Использование JSX рекомендуется, но не обязательно. </li>
    <li><b>Polymer</b> — библиотека, созданная компанией Google для сборки пользовательских компонентов на основе стандарта Web Components. Поставляется вместе с набором интересных настраиваемых элементов пользовательского интерфейса, которые можно включить в разметку HTML в виде тегов. Кроме того, содержит компоненты приложений, предназначенных для работы в режиме офлайн, а также элементы, использующие разнообразные API от Google (например, календарь, карты и др.).</li>
    <li><b>RxJS</b> — набор библиотек, необходимых для создания асинхронных программ и программ, основанных на событиях, с использованием наблюдаемых коллекций. Позволяет приложениям работать с асинхронными потоками данных наподобие серверного потока котировок акций или событий, связанных с движением мыши. С помощью RxJS потоки данных представляются в виде наблюдаемых последовательностей. Эту библиотеку можно применять как с другими фреймворками JavaScript, так и без них.</li>
</ul>


<p></p>
<p></p>




<h2>Почему Angular?</h2>
<p>Приложения Angular строятся на базе паттерна проектирования MVC, который ориентирован на создание приложений, обладающих следующими характеристиками:</p>
<ul>
    <li><i>Простота расширения</i>: если вы понимаете основы, вам будет легко разобраться даже в самом сложном приложении Angular, а это означает, что вы сможете легко расширять приложения для поддержки новой полезной функциональности.</li>
    <li><i>Удобство сопровождения</i>: приложения Angular просты в отладке, в них легко исправляются ошибки, а это означает простоту сопровождения кода в долгосрочной перспективе.</li>
    <li><i>Удобство тестирования</i>: в Angular реализована хорошая поддержка модульного и сквозного тестирования. Следовательно, вы сможете находить и устранять дефекты до того, как ваши пользователи столкнутся с ними.</li>
    <li><i>Стандартизация</i>: Angular работает на основе внутренней функциональности браузера, не создавая никаких препятствий для вашей работы. Это позволяет вам создавать веб-приложения, соответствующие стандартам, в которых задействована новейшая функциональность (например, различные API HTML5), популярные инструменты и фреймворки.</li>
</ul>

<h2>Начало работы с Angular</h2>
<p>Многие инструменты, используемые для разработки приложений Angular, зависят от Node.js.</p>
<p>Полный набор всех выпусков Node с программами установки для Windows
и Mac OS и двоичными пакетами для других платформ доступен по адресу <a href="https://nodejs.org/">nodejs.org</a>.</p>
<p>После завершения установки выполните следующую команду для проверки установки:</p>
<pre><code >node -v</code></pre>

<p>Установка Node.js включает менеджер пакетов проекта <span class="code">npm</span>. Выполните следующую команду, чтобы убедиться в том, что <span class="code">npm</span> работает:</p>
<pre><code >npm -v</code></pre>

<h3>Установка пакета <span class="code">angular-cli</span></h3>
<p>Пакет <span class="code">angular-cli</span> стал стандартным инструментом создания и управления пакетами Angular в ходе разработки. Чтобы установить <span class="code">angular-cli</span>, откройте новую командную строку и введите следующую команду:</p>
<pre><code >npm install --global @angular/cli@1.0.0</code></pre>
<p><b>Все обстоит проще, если вы работаетe в WebStorm. В таком случае во время создания нового проекта можно просто выбрать Angular в качестве типа проекта и дождаться пока базис для проекта Angular будет сгенерирован автоматически.</b></p>

<h3>Создание проекта</h3>
<p>Выберите подходящую папку и выполните следующую команду в режиме командной строки, чтобы создать новый проект с именем <i>todo</i>:</p>
<pre><code >ng new todo</code></pre>
<p>Команда <span class="code">ng</span> предоставляется пакетом <span class="code">angular-cli</span>, а подкоманда <span class="code">ng new</span> создает новый проект. Процесс установки создает папку с именем <i>todo</i>, которая содержит все файлы конфигурации, необходимые для разработки Angular, некоторые временные файлы, упрощающие начальную стадию разработки, и пакеты <span class="code">npm</span>, необходимые для разработки, запуска и развертывания приложений Angular (пакетов <span class="code">npm</span> довольно много; это означает, что создание проекта может занять много времени).</p>

<h3>Создание файла пакета</h3>
<p><span class="code">npm</span> использует файл с именем <span class="code">package.json</span> для чтения списка программных пакетов, необходимых для проекта. Файл <span class="code">package.json</span> создается <span class="code">angular-cli</span> как часть инфраструктуры проекта, но он содержит только базовые пакеты, необходимые для разработки Angular. </p>

<p>Далее нам понадобится пакет Bootstrap, не входящий в базовый набор пакетов. Для его установки введите следующую команду в консоль:
<pre><code >npm install bootstrap</code></pre></p>

<p>В итоге, файл <span class="code">package.json</span> будет иметь следующий вид:</p>
<pre><code >{
    "name": "simple-angular-project",
    "version": "0.0.0",
    "scripts": {
        "ng": "ng",
        "start": "ng serve",
        "build": "ng build",
        "watch": "ng build --watch --configuration development",
        "test": "ng test"
    },
    "private": true,
    "dependencies": {
        "@angular/animations": "^19.0.0",
        "@angular/common": "^19.0.0",
        "@angular/compiler": "^19.0.0",
        "@angular/core": "^19.0.0",
        "@angular/forms": "^19.0.0",
        "@angular/platform-browser": "^19.0.0",
        "@angular/platform-browser-dynamic": "^19.0.0",
        "@angular/router": "^19.0.0",
        "bootstrap": "^5.3.3",
        "rxjs": "~7.8.0",
        "tslib": "^2.3.0",
        "zone.js": "~0.15.0"
    },
    "devDependencies": {
        "@angular-devkit/build-angular": "^19.0.4",
        "@angular/cli": "^19.0.4",
        "@angular/compiler-cli": "^19.0.0",
        "@types/jasmine": "~5.1.0",
        "jasmine-core": "~5.4.0",
        "karma": "~6.4.0",
        "karma-chrome-launcher": "~3.2.0",
        "karma-coverage": "~2.2.0",
        "karma-jasmine": "~5.1.0",
        "karma-jasmine-html-reporter": "~2.1.0",
        "typescript": "~5.6.2"
    }
}</code></pre>

<p>В файле <span class="code">package.json</span> перечислены пакеты, необходимые для начала разработки приложений Angular, и некоторые команды для их использования. Пока нам достаточно понимать, для чего нужна каждая секция файла <span class="code">package.json</span>:</p>

<table><thead>
<tr>
    <th>Имя</th>
    <th>Описание</th>
</tr></thead>
    <tbody>
    <tr>
        <td><span class="code">scripts</span></td>
        <td>Список скриптов, запускаемых в режиме командной строки. Секция <span class="code">scripts</span> в листинге запускает команды, используемые для компиляции исходного кода, и сервер HTTP для разработки</td>
    </tr>
    <tr>
        <td><span class="code">dependencies</span></td>
        <td>Список пакетов <span class="code">npm</span>, от которых зависит работа веб-приложения. Для каждого пакета указан номер версии. В секции <span class="code">dependencies</span> в листинге перечислены базовые пакеты Angular; библиотеки, от которых зависит Angular; и дополнительная CSS-библиотека Bootstrap, которая используется для стилевого оформления контента HTML</td>
    </tr>
    <tr>
        <td><span class="code">devDependencies</span></td>
        <td>Список пакетов <span class="code">npm</span>, которые используются в разработке, но не нужны для работы приложения после его развертывания. В этой секции перечислены пакеты, компилирующие файлы TypeScript, предоставляющие функциональность сервера HTTP в процессе разработки и обеспечивающие тестирование</td>
    </tr>
    </tbody></table>

<h2>Запуск сервера</h2>

<p>Инструментарий и базовая структура находятся на своих местах; пришло время
убедиться в том, что все работает нормально. Выполните следующие команды из
папки todo:</p>
<pre><code >npm serve --port 3000 --open</code></pre>

<p>Команда запускает сервер HTTP для разработки, который был установлен
<span class="code">angular-cli</span> и настроен для работы с инструментарием разработчика Angular. Запуск занимает немного времени для подготовки проекта, а вывод выглядит примерно так:</p>

<div class="code-example-output-title"><span>Вывод:</span>
    <div class="code-example-output">
<pre>
** NG Live Development Server is running on http://localhost:3000 **
Hash: b8843310528d229c2540
Time: 11251ms
chunk {0} polyfills.bundle.js, polyfills.bundle.js.map (polyfills) 158 kB {4}
[initial] [rendered]
chunk {1} main.bundle.js, main.bundle.js.map (main) 3.69 kB {3} [initial]
    [rendered]
chunk {2} styles.bundle.js, styles.bundle.js.map (styles) 9.77 kB {4} [initial]
    [rendered]
chunk {3} vendor.bundle.js, vendor.bundle.js.map (vendor) 2.37 MB [initial]
    [rendered]
chunk {4} inline.bundle.js, inline.bundle.js.map (inline) 0 bytes [entry]
    [rendered]
    webpack: Compiled successfully.
</pre>
    </div>
</div>
<p>Через несколько секунд откроется окно браузера; это
означает, что запуск проекта прошел успешно и в нем используется временный
контент, сгенерированный <span class="code">angular-cli</span>.</p>

<h2>Простое приложение Angular</h2>
<h3>Редактирование файла HTML</h3>
<p>Хотя пакет <span class="code">angular-cli</span> добавил временный контент, мы сейчас удалим все лишнее и начнем с заготовки HTML, содержащей статический контент. Позже эта заготовка будет расширена для Angular. Отредактируйте файл <span class="code">index.html</span> в папке <span class="code">todo/src</span> и включите в него контент:</p>
<pre><code >&lt;!DOCTYPE html>
&lt;html>
&lt;head>
    &lt;title>ToDo&lt;/title>
    &lt;meta charset="utf-8" />
&lt;/head>
&lt;body class="m-a-1">
&lt;h3 class="bg-primary p-a-1">Adam's To Do List&lt;/h3>
&lt;div class="m-t-1 m-b-1">
    &lt;input class="form-control" />
    &lt;button class="btn btn-primary m-t-1">Add&lt;/button>
&lt;/div>
&lt;table class="table table-striped table-bordered">
    &lt;thead>
    &lt;tr>
        &lt;th>Description&lt;/th>
        &lt;th>Done&lt;/th>
    &lt;/tr>
    &lt;/thead>
    &lt;tbody>
    &lt;tr>&lt;td>Buy Flowers&lt;/td>&lt;td>No&lt;/td>&lt;/tr>
    &lt;tr>&lt;td>Get Shoes&lt;/td>&lt;td>No&lt;/td>&lt;/tr>
    &lt;tr>&lt;td>Collect Tickets&lt;/td>&lt;td>Yes&lt;/td>&lt;/tr>
    &lt;tr>&lt;td>Call Joe&lt;/td>&lt;td>No&lt;/td>&lt;/tr>
    &lt;/tbody>
&lt;/table>
&lt;/body>
&lt;/html></code></pre>
в styles.css добавьте строку:
<pre><code >@import "../node_modules/bootstrap/dist/css/bootstrap.min.css";</code></pre>
<p>Сервер HTTP для разработки <span class="code">angular-cli</span> добавляет фрагмент JavaScript в контент HTML, передаваемый браузеру. JavaScript открывает обратное подключение к серверу и ждет сигнала на перезагрузку страницы; сигнал отправляется при обнаружении сервером изменений в любых файлах из каталога todo. Как только вы сохраните файл <span class="code">index.html</span>, сервер обнаружит изменения и отправит сигнал. Браузер перезагружается и выводит новый контент.</p>
<p>При внесении изменений в группу файлов может случиться так, что браузер не сможет загрузить и выполнить приложение. В большинстве случаев сервер HTTP для разработки инициирует перезагрузку в браузере, и все будет нормально.</p>
<p>Элементы HTML в файле <span class="code">index.html</span> показывают, как будет выглядеть простое приложение Angular, которое мы создадим в этой главе. Его ключевые элементы — заголовок с именем пользователя, поле ввода, кнопка для добавления новой задачи в список и таблица со всеми задачами и признаками их завершения.</p>

<h3>Добавление функциональности Angular в проект</h3>
<p>Статическая разметка HTML в файле <span class="code">index.html</span> заменяет простейшее приложение. Пользователь может просматривать список задач, помечать выполненные и создавать новые задачи. В дальнейшем мы добавим в проект Angular и воспользуемся некоторыми базовыми возможностями для того, чтобы вдохнуть жизнь в приложение.</p>
<p>Первым шагом на пути включения Angular в приложение станет подготовка файла <span class="code">index.html</span>. Заменим демонстрационную разметку из прошлой главы на следующую:</p>
<pre><code >&lt;!DOCTYPE html>
&lt;html>
&lt;head>
    &lt;title>ToDo&lt;/title>
    &lt;meta charset="utf-8" />
    &lt;link href="node_modules/bootstrap/dist/css/bootstrap.min.css"
          rel="stylesheet" />
&lt;/head>
&lt;body class="m-a-1">
&lt;todo-app>Angular placeholder&lt;/todo-app>
&lt;/body>
&lt;/html> </code></pre>
<p>Содержимое элемента <span class="code">body</span> заменяется элементом <span class="code">todo-app</span>. В спецификации HTML элемент <span class="code">todo-app</span> отсутствует, и браузер игнорирует его при разборе файла HTML, но этот элемент станет отправной точкой в мире Angular — он заменяется контентом приложения. Если сохранить файл <span class="code">index.html</span>, браузер перезагрузит файл и выведет временный текст.</p>
<p>Несложно заметить, что в данной разметке отсутствуют теги <span class="code">script</span> для встраиваемой функциональности Angular. Это связано с тем, что созданный на базе <span class="code">angular-cli</span>, использует инструмент <i>WebPack</i>, который автоматически генерирует файлы JavaScript для проекта и автоматически встраивает их в файлы HTML, отправляемые браузеру сервером HTTP для разработки.</p>

<h3>Создание модели данных</h3>
<p>Когда я создавал статическую заготовку приложения, данные были распределены
между всеми элементами HTML. Имя пользователя содержалось в заголовке:</p>
<pre><code >&lt;h3 class="bg-primary p-a-1">Adam's To Do List&lt;/h3></code></pre>
<p>Описания задач содержатся в элементах <span class="code">td</span> таблицы:</p>
<pre><code >&lt;tr>&lt;td>Buy Flowers&lt;/td>&lt;td>No&lt;/td>&lt;/tr></code></pre>
<p>Следующая задача — объединить все данные для создания модели данных. Отделение данных от способа их представления для пользователя — один из ключевых принципов паттерна MVC.</p>

<p>Приложения Angular обычно пишутся на TypeScript. TypeScript является надмножеством JavaScript, но одно из его главных преимуществ заключается в том, что он позволяет писать код с использованием новейшей спецификации языка JavaScript, часть возможностей которого не поддерживается некоторыми браузерами, способными к выполнению приложений Angular.</p>
<p>Чтобы создать модель данных приложения, я добавил файл с именем <span class="code">model.ts</span> в папку <span class="code">todo/src/app</span> (файлы TypeScript имеют расширение <span class="code">.ts</span>) и включил код ниже:</p>
<pre><code >var model = {
     user: "Adam",
     items: [
        { action: "Buy Flowers", done: false },
        { action: "Get Shoes", done: false },
        { action: "Collect Tickets", done: true },
        { action: "Call Joe", done: false }]
};</code></pre>
<p>Одна из важнейших особенностей TypeScript заключается в том, что вы можете писать «нормальный» код JavaScript так, как если бы вы писали его непосредственно для браузера. В листинге я использовал синтаксис объектных литералов JavaScript для присваивания значения глобальной переменной с именем <span class="code">model</span>. Объект модели данных содержит свойство <span class="code">user</span>, в котором хранится имя пользователя, и свойство <span class="code">items</span>, которому присваивается массив объектов со свойствами <span class="code">action</span> и <span class="code">done</span>; каждый объект представляет задачу в списке.</p>
<p>Важно отметить, что конфигурация, созданная <span class="code">angular-cli</span>, компилирует только те файлы, которые необходимы для передачи приложения браузеру. Это означает, что файл <span class="code">model.ts</span> не будет компилироваться вплоть до его интеграции в функциональность Angular для приложения.</p>
<p>Этот фрагмент представляет самый важный аспект использования TypeScript: вы не обязаны использовать специфические функции TypeScript и можете писать целые приложения Angular с использованием только возможностей JavaScript, поддерживаемых всеми браузерами. Но полезность TypeScript также в значительной мере обусловлена и тем, что TypeScript берет код, использующий новейшие возможности языка JavaScript, в код, который будет работать везде — даже в браузерах, не поддерживающих эту функциональность. Например, перепишем <span class="code">model.ts</span>:</p>
<pre><code >export class Model {
  user: string;
  items: TodoItem[];

  constructor() {
    this.user = "Adam";
    this.items = [
      new TodoItem("Buy Flowers", false),
      new TodoItem("Get Shoes", false),
      new TodoItem("Collect Tickets", false),
      new TodoItem("Call Joe", false)
    ];
  }
}

export class TodoItem {
  action: string;
  done: boolean;

  constructor(action: string, done: boolean) {
    this.action = action;
    this.done = done;
  }
}</code></pre>
<p>Заметим существенное отличие от привычного нам Javascript - типы декларируются. Мы все еще можем использовать имплицитные типы, но чтобы это работало надо добавить строку в <span class="code">tsconfig.json</span> в разделе <span class="code">"compilerOptions"</span>:</p>
<pre><code >"noImplicitAny": false,</code></pre>

<p>Это стандартный код JavaScript, однако ключевое слово <span class="code">class</span> было добавлено в поздней версии языка, неизвестной многим разработчикам веб-приложений, и оно не поддерживается старыми браузерами. Ключевое слово <span class="code">class</span> используется для определения типов, экземпляры которых создаются ключевым словом <span class="code">new</span>; созданные таким образом объекты обладают четко определенными данными и поведением.</p>
<p>Многие возможности, появившиеся в новых версиях JavaScript, представляют собой «синтаксические удобства» для предотвращения наиболее распространенных ловушек JavaScript, таких как непривычная система типов. Ключевое слово <span class="code">class</span> не влияет на работу с типами в JavaScript; оно всего лишь делает их более знакомыми и удобными для программистов с опытом работы на других языках. Кроме того, классы упрощают работу с фреймворком Angular, спроектированным с учетом новейших возможностей JavaScript.</p>
<p>Ключевое слово <span class="code">export</span> относится к работе с модулями JavaScript. При использовании модулей каждый файл TypeScript или JavaScript считается автономным блоком функциональности, а ключевое слово <span class="code">export</span> идентифицирует данные и типы, которые должны использоваться в других местах приложения. Модули JavaScript используются для управления зависимостями между файлами проекта, а также для того, чтобы разработчику не приходилось вручную управлять сложным набором элементов <span class="code">script</span> в файле HTML.</p>

<h3>Создание шаблона</h3>
<p>Нам понадобится механизм отображения значений данных из модели. В Angular это делается при помощи шаблона — фрагмента HTML с инструкциями, выполняемыми Angular. В ходе создания проекта пакет <span class="code">angular-cli</span> создал файл шаблона с именем <span class="code">app.component.html</span> в папке <span class="code">todo/src/app</span>. Отредактируйте этот файл и добавьте разметку из кода ниже.</p>
<pre><code >&lt;h3 class="bg-primary p-a-1">{{getName()}}'s To Do List&lt;/h3></code></pre>
<p>Вскоре в этот файл будут добавлены другие элементы, а для начала работы хватит одного элемента <span class="code">h3</span>. Для включения значения данных в шаблоне используются двойные фигурные скобки <span class="code">{{</span> и <span class="code">}}</span>; Angular вычисляет заключенное в них выражение и получает значение для вывода.</p>
<p>Символы <span class="code">{{</span> и <span class="code">}}</span> обозначают <b>привязку данных</b>; иначе говоря, они создают отношения между шаблоном и значением данных. Привязка данных принадлежит к числу важных особенностей Angular. В данном случае привязка данных приказывает Angular вызвать функциональность с именем <span class="code">getName</span> и использовать результат как содержимое элемента <span class="code">h3</span>. Функции <span class="code">getName</span> в приложении пока нет, но мы создадим ее в следующем разделе.</p>

<h3>Создание компонента</h3>
<p><b>Компонент</b> (<i>component</i>) Angular отвечает за управление шаблоном и передачу ему необходимых данных и логики. Если это утверждение покажется вам слишком громким, именно компоненты выполняют большую часть тяжелой работы в приложениях Angular. Как следствие, они могут использоваться для самых разных целей.</p>
<p>На данный момент у нас имеется модель данных со свойством <span class="code">user</span>, содержащим выводимое имя, а также шаблон, который выводит имя вызовом свойства <span class="code">getName</span>. Не хватает компонента, который бы заполнял пробел между ними. Пакет <span class="code">angular-cli</span> создал файл компонента с именем <span class="code">app.component.ts</span> в папку <span class="code">todo/src/app</span>; замените исходное содержимое этого файла кодом ниже.</p>
<pre><code >import { Component } from "@angular/core";
import { Model } from "./model";

@Component({
  selector: "todo-app",
  templateUrl: "./app.component.html" // Убедитесь, что путь правильный
})
export class AppComponent {
  model = new Model();

  getName() {
    return this.model.user;
  }
}</code></pre>

<p>Перед вами все тот же код JavaScript, но в нем встречаются возможности, которые вам, может быть, прежде не встречались; тем не менее эти возможности лежат в основе разработки Angular. В коде можно выделить три основные части, описанные ниже.</p>
<h4>Импортирование</h4>
<p>Ключевое слово <span class="code">import</span> составляет пару для ключевого слова <span class="code">export</span> и используется для объявления зависимости от содержимого модуля JavaScript.</p>
<pre><code >...
import { Component } from "@angular/core";
import { Model } from "./model";
...</code></pre>
<p>Первая команда <span class="code">import</span> используется для загрузки модуля <span class="code">@angular/core</span>, содержащего ключевую функциональность Angular, в том числе и поддержку компонентов. При работе с модулями команда <span class="code">import</span> перечисляет импортируемые типы в фигурных скобках. В данном случае команда <span class="code">import</span> используется для загрузки типа <span class="code">Component</span> из модуля. Модуль <span class="code">@angular/core</span> содержит многочисленные классы, упакованные вместе, чтобы браузер мог загрузить их в одном файле JavaScript.</p>
<p>Вторая команда <span class="code">import</span> загружает класс <span class="code">Model</span> из файла в проекте. Цель такого рода команд импортирования начинается с <span class="code">./</span>; это означает, что местонахождение модуля определяется относительно текущего файла.</p>
<p>Обратите внимание: ни в одной команде <span class="code">import</span> не указано расширение файла. Дело в том, что отношениями между целью команды <span class="code">import</span> и файлом, загружаемым браузером, управляет загрузчик модуля.</p>
<h4>Декораторы</h4>
<p>Пожалуй, самая странная часть листинга выглядит так:</p>
<pre><code >...
@Component({
    selector: "todo-app",
    templateUrl: "app/app.component.html"
})
...</code></pre>
<p>Это <b>декоратор</b> (decorator), предоставляющий метаданные о классе. Декоратор <span class="code">@Component</span>, как подсказывает его имя, сообщает Angular, что это компонент. Декоратор передает конфигурационную информацию в своих свойствах; <span class="code">@Component</span>включает свойства с именами <span class="code">selector</span> и <span class="code">templateUrl</span>.</p>
<p>Свойство <span class="code">selector</span> задает селектор CSS, соответствующий элементу HTML, к которому будет применен компонент. В данном случае я указал элемент <span class="code">todo-app</span>, добавленный в файл <span class="code">index.html</span>. При запуске приложения Angular сканирует разметку HTML текущего документа и ищет элементы, соответствующие компонентам. Angular находит элемент <span class="code">todo-app</span> и понимает, что его нужно передать под контроль этому компоненту.</p>
<p>Свойство <span class="code">templateUrl</span> сообщает Angular, где найти шаблон компонента, в данном случае это файл <span class="code">app.component.html</span> в папке <span class="code">app</span> компонента. Далее будут описаны другие свойства, которые могут использоваться с <span class="code">@Component</span> и другими декораторами, поддерживаемыми Angular.</p>

<h4>Класс</h4>
<p>В последней части листинга определяется класс, экземпляр которого создается
    Angular для создания компонента.</p>
<pre><code >...
export class AppComponent {
    model = new Model();
    getName() {
        return this.model.user;
    }
}
...
</code></pre>
<p>Эти команды определяют класс <span class="code">AppComponent</span> со свойством <span class="code">model</span> и функцией <span class="code">getName</span>, которая предоставляет функциональность, необходимую для работы привязки данных в шаблоне.</p>
<p>При создании нового экземпляра класса <span class="code">AppComponent</span> свойству <span class="code">model</span> присваивается новый экземпляр класса <span class="code">Model</span> из листинга выше. Функция <span class="code">getName</span> возвращает значение свойства <span class="code">user</span>, определяемого объектом <span class="code">Model</span>.</p>

<h4>Объединяем...</h4>
<p>У нас есть все три ключевых блока функциональности, необходимых для построения простого приложения Angular: модель, шаблон и компонент. При сохранении изменений в файле <span class="code">app.component.ts</span> функциональности было достаточно для того, чтобы связать их воедино и вывести результат.</p>
<p>Одно из преимуществ использования <span class="code">angular-cli</span> при создании проекта заключается в том, что вам не нужно беспокоиться о создании основных файлов, необходимых для приложения Angular. Недостаток — в том, что, пропуская эти файлы, вы можете упустить важные подробности, заслуживающие внимания. </p>
<p>В приложениях Angular должен присутствовать модуль. Из-за неудачного выбора термина в разработке приложений Angular встречаются модули двух видов. <b>Модуль JavaScript</b> — файл с функциональностью JavaScript, для присоединения которого используется ключевое слово <span class="code">import</span>. К другой категории относятся <b>модули Angular</b>, используемые для описания приложений или групп взаимосвязанных возможностей. У каждого приложения имеется <b>корневой модуль</b>, который предоставляет Angular информацию, необходимую для запуска приложения.</p>
<p>В файл <span class="code">app.module.ts</span> в папке <span class="code">todo/src/app</span> должен быть включен код:</p>
<pre><code >import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpClientModule } from '@angular/common/http';

import { AppComponent } from './app.component';

@NgModule({
declarations: [AppComponent],
imports: [BrowserModule,FormsModule,HttpClientModule],
providers: [], // Здесь можно добавить сервисы
bootstrap: [AppComponent]
})
export class AppModule { }</code></pre>
<p>Основная цель модуля Angular — передача конфигурационной информации в свойствах, определяемых декоратором @NgModule. Пока достаточно знать, что свойство <span class="code">imports</span> декоратора сообщает Angular, что приложение зависит от функций, необходимых для запуска приложений в браузере, а свойства <span class="code">declarations</span> и <span class="code">bootstrap</span> сообщают Angular о компонентах приложения и о том, какой компонент должен использоваться для запуска приложения (в этом простом примере компонент только один, поэтому он является значением обоих свойств).</p>
<p>Приложениям Angular также необходим файл начальной загрузки с кодом, нужным для запуска приложения и загрузки модуля Angular. Чтобы создать файл начальной загрузки, angular-cli создал файл <span class="code">main.ts</span> в папке <span class="code">todo/src</span>. Добавим в него код из листинга ниже:</p>
<pre><code>import { enableProdMode } from '@angular/core';
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { AppModule } from './app/app.module';
import { environment } from './environments/environment';
if (environment.production) {
    enableProdMode();
}
platformBrowserDynamic().bootstrapModule(AppModule);</code></pre>
<p>Если в папке приложения нет каталога <span class="code">environments</span>, то его необходимо создать. Для этого вводим следующую команду:</p>
<pre><code >ng generate environments</code></pre>
<p>После этого заходим в файл environment.ts и заменяем его содержимое следующим кодом:</p>
<pre><code >export const environment = {
    production: true
};</code></pre>
<p>Команды в файле начальной загрузки выбирают платформу, которая должна использоваться, и загружают корневой модуль, который является точкой входа
в приложение.</p>
<p>Вызов метода <span class="code">platformBrowserDynamic().bootstrapModule</span> предназначен для браузерных
приложений — основной темы этой книги. Если вы работаете на разных платформах (скажем, с фреймворком мобильной разработки ionic), используйте другой метод начальной
загрузки для той платформы, с которой вы работаете. Разработчики каждой платформы,
поддерживающей Angular, предоставляют подробную информацию о методе начальной
загрузки для своей платформы.</p>
<p>Браузер выполнил код из файла начальной загрузки; это привело к активизации
среды Angular, которая, в свою очередь, обработала документ HTML и обнаружила элемент <span class="code">todo-app</span>. Свойство <span class="code">selector</span>, использованное для определения компонента, совпадает с элементом <span class="code">todo-app</span>, вследствие чего Angular удаляет временный контент и заменяет его шаблоном компонента, автоматически загружаемым из файла <span class="code">app.component.html</span>. В ходе разбора шаблона обнаруживается конструкция
привязки <span class="code">{{ }}</span>; содержащееся в ней выражение вычисляется, вызывается метод <span class="code">getName</span> и выводится результат. Возможно, этот результат не особо впечатляет,
но это хорошее начало, и оно закладывает основу для дальнейшего расширения
функциональности.</p>

<h2>Расширение функциональности приложения</h2>
<p>Итак, основная структура приложения готова, и мы можем заняться добавлением
остальных возможностей, которые были смоделированы статической разметкой
HTML в начале главы. В следующих разделах будет добавлена таблица со списком задач, а также элемент ввода и кнопка для создания новых записей.</p>
<h3>Добавление таблицы</h3>
<p>Возможности шаблонов Angular выходят далеко за рамки простого вывода значений данных. Полный спектр возможностей шаблонов будет описан далее, но в приложении-примере мы ограничимся возможностью добавления набора элементов HTML в DOM для каждого объекта в массиве. В данном случае таким массивом будет набор задач из модели данных. Для начала в листинге (<span class="code">app.component.ts</span>) ниже в компонент добавляется метод, который предоставляет шаблону массив задач.</p>
<pre><code >import { Component } from "@angular/core";
import { Model } from "./model";

@Component({
    selector: "todo-app",
    templateUrl: "./app.component.html" // Убедитесь, что путь правильный
})
export class AppComponent {
    model = new Model();

    getName() {
        return this.model.user;
    }
    getTodoItems() {
        return this.model.items;
    }
}</code></pre>
<p>Метод <span class="code">getTodoItems</span> возвращает значение свойства items из объекта Model. В листинге ниже шаблон компонента обновляется с использованием нового метода</p>
<pre><code >&lt;h3 class="bg-primary p-a-1">{{getName()}}'s To Do List&lt;/h3>
&lt;table class="table table-striped table-bordered">
    &lt;thead>
    &lt;tr>&lt;th>&lt;/th>&lt;th>Description&lt;/th>&lt;th>Done&lt;/th>&lt;/tr>
    &lt;/thead>
    &lt;tbody>
    &lt;tr *ngFor="let item of getTodoItems(); let i = index">
        &lt;td>{{ i + 1 }}&lt;/td>
        &lt;td>{{ item.action }}&lt;/td>
        &lt;td [ngSwitch]="item.done">
            &lt;span *ngSwitchCase="true">Yes&lt;/span>
            &lt;span *ngSwitchDefault>No&lt;/span>
        &lt;/td>
    &lt;/tr>
    &lt;/tbody>
&lt;/table></code></pre>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
