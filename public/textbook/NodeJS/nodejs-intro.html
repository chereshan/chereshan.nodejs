<!--<title>Глава 1. Знакомство с NodeJS</title>-->
<h1>Глава 1. Знакомство с NodeJS</h1>

<h2>Исторический контекст и Node.js</h2>
<p>В 2009 г., спустя годы после того как JavaScript стал стандартом в веб-программировании, <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D0%BB%D1%8C,_%D0%A0%D0%B0%D0%B9%D0%B0%D0%BD">Райан Даль</a> разглядел потенциал JavaScript как серверного языка и создал <b>Node.js</b>. </p>
<p>Это было плодотворное время для интернет-технологий. <i>Ruby</i> (а также <i>Ruby on Rails)</i> заимствовал немало отличных идей из теории вычислительной техники, объединив их с некоторыми собственными идеями, и продемонстрировал миру более быстрый способ создания сайтов и веб-приложений. Корпорация Microsoft в героической попытке прийти в соответствие эпохе Интернета сделала с <i>.NET</i> удивительные вещи, учтя ошибки не только Ruby on Rails, но и языка Java.</p>
<p>Сегодня благодаря технологиям <span data-tippy-content='Это процесс преобразования исходного кода, написанного на одном языке программирования, в эквивалентный код на другом языке программирования, который обычно находится на том же уровне абстракции. Этот термин часто используется в контексте преобразования кода из одного стандарта языка (например, JavaScript) в другой стандарт (например, ES5 в ES6) или из одного языка в другой (например, TypeScript в JavaScript).'>транскомпиляции</span>, таким как <i>Babel</i>, веб-разработчики могут свободно использовать самые последние функции языка JavaScript, не боясь оттолкнуть пользователей с более старыми браузерами.
<i>Webpack</i> стал универсальным решением для управления зависимостями в веб-приложениях и обеспечения производительности. Такие фреймворки, как <i>React</i>, <i>Angular</i> и <i>Vue</i>, поменяли подход к веб-разработке, а библиотеки для работы с декларативной объектной моделью документов (DOM) (такие как <i>jQuery</i>) — это уже вчерашний день.</p>
<!--todo: выше исторический контекст, а не история node-->
<p>В основе Node лежит ядро JavaScript. Для большинства реализаций используется ядро V8. Исходный код V8, изначально созданный компанией Google для Chrome, был переведен в открытый доступ в 2008 году. Ядро JavaScript V8 было разработано для повышения скорости выполнения JavaScript за счет включения JIT-компилятора (<span data-tippy-content='технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы.'>Just-In-Time</span>), который преобразует JavaScript в машинный код вместо того, чтобы его интерпретировать (что считалось нормой для JavaScript в течение многих лет). Ядро V8 написано на C++.</p>



<h2>Что такое Node?</h2>
<p><b>Node.js</b> — асинхронная, однопоточная, управляемая событиями исполнительная платформа JavaScript с мощной, но компактной стандартной библиотекой. По порядку разберем, что это значит. </p>
<p><b>Исполнительная платформа</b> (англ. <i>Execution Platform</i>) - это программная платформа, которая обеспечивает среду для выполнения приложений, сервисов или задач. Она предоставляет набор инструментов, библиотек и сервисов, необходимых для запуска и управления приложениями. Исполнительная платформа обеспечивает <b>(1)</b> выполнение кода, <b>(2)</b> управление ресурсами (память, процессорное время, ввод/вывод), <b>(3)</b> обеспечение безопасности (аутентификация, авторизация, шифрование), <b>(4)</b> мониторинг и управление (сбор логов, анализ производительности, управление конфигурацией). </p>
<ul>
    <b>Примеры исполнительных платформ:</b>
    <li><b>Java Virtual Machine (JVM)</b>: исполнительная платформа для приложений, написанных на языке Java.</li>
    <li><b>.NET Common Language Runtime (CLR)</b>: исполнительная платформа для приложений, написанных на языках C#, F#, Visual Basic .NET и других.</li>
    <li><b>Node.js</b>: исполнительная платформа для приложений, написанных на языке JavaScript.</li>
    <li><b>Google Apps Script</b>: исполнительная платформа для автоматизации задач и создания приложений на основе Google Sheets, Google Docs и других сервисов Google.</li>
    <li><b>AWS Lambda</b>: исполнительная платформа для серверных приложений, написанных на различных языках программирования, без необходимости управления серверами.</li>
</ul>

<p><b>Асинхронная исполнительная платформа</b> (англ. <i>Asynchronous Execution Platform</i>) - это тип исполнительной платформы, которая позволяет выполнять несколько задач или приложений одновременно, не блокируя основной поток выполнения (<span data-tippy-content='неблокирующий доступ позволяет многим задачам или приложениям использовать ресурсы одновременно'>неблокирующий доступ</span>). Это означает, что платформа может обрабатывать несколько запросов или задач <i>асинхронно</i>, не ожидая завершения предыдущей задачи.</p>

<ul>
    <b>Примеры асинхронных исполнительных платформ:</b>
    <li><b>Node.js</b> - это асинхронная исполнительная платформа для приложений, написанных на языке JavaScript. Она использует неблокирующий ввод/вывод и асинхронные callback-функции для обеспечения высокой производительности.</li>
    <li><b>Apache Kafka</b> - это распределенная асинхронная исполнительная платформа для обработки потоков данных в реальном времени.</li>
    <li><b>AWS Lambda</b> - это асинхронная исполнительная платформа для серверных приложений, написанных на различных языках программирования. Она позволяет выполнять код в ответ на события, не требуя управления серверами.</li>
    <li><b>Google Cloud Tasks</b> - это асинхронная исполнительная платформа для выполнения задач в облаке. Она позволяет планировать и выполнять задачи асинхронно, не блокируя основной поток выполнения.</li>
</ul>

<p><b>Управляемая событиями исполнительная платформа</b> (англ. <i>Event-Driven Execution Platform</i>) - это тип исполнительной платформы, которая выполняет код или задачи в ответ на события или триггеры. Это означает, что платформа ожидает события, такого как запрос от пользователя, изменение данных или срабатывание таймера, и затем выполняет соответствующий код или задачу.</p>

<ul>
    <b>Примеры управляемых событиями исполнительных платформ:</b>
    <li><b>Serverless computing platforms</b>: платформы, такие как <i>AWS Lambda</i>, <i>Google Cloud Functions</i> и <i>Azure Functions</i></li>
    <li><b>Message queues</b>: такие как <i>RabbitMQ</i>, <i>Apache Kafka</i> и <i>Amazon SQS</i></li>
    <li><b>Webhooks</b>: такие как <i>Slack Webhooks</i> и <i>GitHub Webhooks</i></li>
</ul>

<p>Среда <b>Node</b> — это JavaScript с привязками к лежащей в основе операционной системе (ОС), что делает возможным написание программ на JavaScript, которые выполняют чтение и запись файлов, запускают дочерние процессы и взаимодействуют через сеть. В результате среда Node пригодна в качестве:</p>
<ul>
    <li>современной альтернативы сценариям командной оболочки, которая не обладает загадочным синтаксисом <span class="code">bash</span> и других оболочек <i>Unix</i>;</li>
    <li>универсального языка программирования для выполнения доверенных программ, не подверженного ограничениям безопасности, которые веб-браузеры налагают на ненадежный код;</li>
    <li>популярной среды для написания эффективных веб-серверов с высокой степенью параллелизма.</li>
</ul>
<p>Определяющей характеристикой среды Node является ее <span data-tippy-content="однопоточный (<i>Single-Threaded</i>): все задачи или операции выполняются в рамках одного потока выполнения.">однопоточный</span> основанный на событиях <span data-tippy-content="Параллелизм (<i>Concurrency</i>): несколько задач или операций выполняются одновременно, что увеличивает производительность и эффективность.">параллелизм</span>, обеспечиваемый по умолчанию <span data-tippy-content="задачи или операции выполняются асинхронно, не блокируя основной поток выполнения.">асинхронным</span> API. Помимо Node, к примерам однопоточного параллелизма относятся следующие технологии <span data-tippy-content='Cooperative scheduling - это подход, при котором несколько задач или операций выполняются асинхронно в рамках одного потока, но с помощью explicit yield или cooperative scheduling.'><i>Cooperative scheduling</i></span> и <span data-tippy-content='async/await - это синтаксический сахар, который позволяет писать асинхронный код, который выглядит как синхронный код.'><i>Async/await</i></span>.</p>


<p>Теперь о библиотеках. Помимо исполняемого файла <span class="code">Node</span> установка Node также включает <span class="code">npm</span> — диспетчер пакетов, который обеспечивает легкий доступ к обширной экосистеме инструментов и библиотек JavaScript.</p>

<h3>Разница между асинхронностью, однопоточностью и параллелизмом</h3>
<p>Более четко разграничим асинхронность, однопоточность и параллелизм.</p>

<ul>
    <li><p><b>Асинхронность</b> - это способ выполнения задач или операций, при котором они не блокируют основной поток выполнения. Асинхронные задачи или операции выполняются в фоновом режиме, не мешая основному потоку выполнения. Примеры: Async/await в JavaScript, Callback-функции в Node.js, Futures и Promises в Java.</p>
        <p><b>Основной <span data-tippy-content='Поток выполнения (англ. Thread) - это последовательность инструкций, которые выполняются процессором в рамках одного процесса. Это основная единица выполнения программы, которая может быть выполнена одновременно с другими потоками выполнения.'>поток выполнения</span> </b>(англ. <i>Main Thread</i>) - это поток выполнения, который запускается при запуске программы или приложения. Это поток, который выполняет основную логическую часть программы или приложения, а также управляет ресурсами (память, файлы и сетевые соединения). Примеры: <span class="code">main</span>-функции C++, Java и Python. Дополнительные и фоновые потоки отличаются тем, что запускаются из основного потока.</p>
        <p></p></li>
    <li><p><b>Однопоточность</b> (англ. <i>Single Thread</i>) - это способ выполнения задач или операций, при котором они выполняются в рамках одного потока выполнения. Однопоточность не обязательно требует асинхронности, но может использовать ее для выполнения задач или операций в фоновом режиме. Примеры: Single-threaded programming в C++, Cooperative scheduling в Node.js, Async/await в JavaScript (при использовании одного потока).</p></li>
    <li><p><b>Параллелизм</b> (англ. <i>Concurrency</i>) - это способ выполнения задач или операций, при котором они выполняются одновременно, используя несколько ресурсов, таких как ядра процессора, потоки или процессы. Примеры: Многопоточность в Java, Параллельное программирование в C++, Distributed computing в Hadoop.</p></li>
</ul>

<p>Суммируем. Все 3 понятия - это способы выполнения задач и операций. Однако параллелизм всегда асинхронен. Асинхронность же необязательно подразумевает параллелизма. Однопоточность может быть или не быть асинхронной или параллельной. </p>
<ul>
    <li><b>Параллелизм ⇒ Многопоточность</b>: если задачи выполняются параллельно, то они должны выполняться в нескольких потоках;</li>
    <li><b>Многопоточность ⇏ Параллелизм</b>: многопоточность не требует нескольких процессоров или ядер для выполнения задач одновременно. Многопоточность также не подразумевает параллельности выполнения задач, они могут быть последовательными, но в нескольких потоках;</li>
    <li><b>Многопоточность и Асинхронность</b>:
        <ul>
            <li>Асинхронная операцию чтения файла, которая выполняется в одном потоке. Операция чтения файла выполняется асинхронно, но не параллельно.</li>
            <li>Параллельная операция вычисления матрицы, которая выполняется в нескольких потоках. Операция вычисления матрицы выполняется параллельно, но не асинхронно.</li>
        </ul>
    </li>
</ul>



<h2>Почему Node?</h2>
<h3>Node проще аналогов</h3>
<p>В некотором смысле у Node много общего с другими популярными веб-серверами,
такими как разработанный Microsoft веб-сервер <i>Internet Information Services</i> (IIS) или <i>Apache</i>. Но интереснее узнать, в чем его отличия. Так что начнем с этого.</p>
<p>Аналогично Express подход Node к веб-серверам чрезвычайно минималистичен.
В отличие от IIS или Apache, для освоения которых могут понадобиться годы,
Node легок в установке и настройке. Это не значит, что настройка серверов Node
на максимальную производительность в условиях промышленной эксплуатации
тривиальна, просто конфигурационные опции проще и яснее.</p>

<h3>Однопоточность</h3>
<p>Другое базовое различие между Node и более традиционными веб-серверами — <b>однопоточность</b> Node. Сначала это может показаться шагом назад, но впоследствии становится ясно, что это гениальная идея. </p>
<p><b>Однопоточность чрезвычайно упрощает задачу написания веб-приложений, а если вам требуется производительность многопоточного приложения, можете просто запустить больше экземпляров Node и, в сущности, получить преимущества многопоточности</b>.</p>
<p>Дальновидный читатель, вероятно, посчитает это каким-то шаманством. В конце концов, разве реализация <span data-tippy-content='Многопоточность - это способ выполнения нескольких задач или потоков выполнения одновременно в рамках одного процесса. Это позволяет повысить производительность и эффективность программы, поскольку несколько задач могут быть выполнены одновременно, не блокируя друг друга.'>многопоточности</span> с помощью <span data-tippy-content='Параллелизм - это способ выполнения нескольких задач одновременно, используя несколько процессоров или ядер процессора'>серверного параллелизма</span> (в противоположность параллелизму приложений) просто не перемещает сложность в другое место вместо ее устранения? Возможно, но опыт показывает, что сложность оказывается перемещенной именно туда, где она и должна быть. Более того, с ростом популярности облачных вычислений и рассмотрения серверов как обычных товаров этот подход становится более разумным.</p>
<p>IIS и Apache, конечно, мощные веб-серверы, разработанные для того, чтобы выжимать из современного сильнейшего аппаратного обеспечения производительность до последней капли. Это, однако, имеет свою цену: чтобы добиться такой производительности, для их установки и настройки работникам необходима высокая квалификация.</p>
<p>Программные потоки (<i>threads</i>) являются стандартным источником ошибок, и хотя некоторые из недавно появившихся языков программирования, включая Go и Rust, пытаются предоставить безопасные инструменты параллельного программирования, <b>Node работает с моделью, используемой в браузере</b>.</p>
<p>Браузерный код представляет собой последовательность команд, которые выполняются одна за одной; код не выполняется параллельно. Для пользовательских интерфейсов такая модель не имеет смысла: пользователь не хочет дожидаться завершения медленных операций (например, обращений к данным по сети или к файлам). Для решения этой проблемы в браузерах используются события: когда пользователь щелкает на кнопке, инициируется событие, и выполняется функция, которая была определена ранее, но еще не выполнялась. Тем самым предотвращаются некоторые проблемы, встречающиеся в многопоточном программировании, включая взаимные блокировки (<i>deadlocks</i>) ресурсов и состояния гонки (<i>race conditions</i>).</p>

<h3>Способ написания приложений Node</h3>
<p>Если говорить о способе написания приложений, то <b>приложения Node больше похожи на приложения PHP или Ruby, чем на приложения .NET или Java</b>. Движок JavaScript, используемый Node, не только компилирует JavaScript во внутренний машинный код (подобно C или C++), но и делает это прозрачным образом (это часто называется компиляцией на лету или <i>JIT-компиляцией</i>), так что с точки зрения пользователя код ведет себя как чистый интерпретируемый язык программирования. Отсутствие отдельного шага компиляции уменьшает сложность обслуживания и развертывания: достаточно просто обновить файл JavaScript, и ваши изменения автоматически станут доступны.</p>

<h3>Независимость от платформы</h3>
<p>Другое захватывающее достоинство приложений Node — невероятная независимость Node от платформы.</p>
<p>Например, вы можете запустить приложение .NET на сервере под управлением Linux с помощью Mono, но это очень нелегкая задача ввиду разнородности документации и системной несовместимости.</p>
<p>Аналогично можете выполнять PHP-приложения на сервере под управлением Windows, но их настройка обычно не так проста, как на машине с Linux. </p>
<p>В то же время Node элементарно устанавливается на всех основных операционных системах (Windows, OS X и Linux) и облегчает совместную работу. Для команд веб-разработчиков смесь PC и компьютеров Macintosh вполне обычна.</p>

<h3>Событийно-ориентированное программирование</h3>
<p>Базовым принципом Node является <b>событийно-ориентированное программирование</b>. Для вас как программиста это означает необходимость понимать, какие события вам доступны и как на них реагировать. Многие люди знакомятся с событийно-ориентированным программированием в процессе реализации пользовательского интерфейса: пользователь что-то нажимает — и вы обрабатываете событие клика.</p>
<p>Это хороший способ, но очевидно, что программист не контролирует момент, когда пользователь что-то нажимает или собирается нажать, поэтому событийно-ориентированное программирование должно быть интуитивно понятным. Мысленный переход к реагированию на события на сервере может оказаться чуть более сложным, но и здесь принцип прежний.</p>

<h2>Экосистема Node</h2>
<p>В сердцевине стека, конечно, находится Node. Это программное обеспечение, которое позволяет выполнять JavaScript-код на сервере без участия браузера, что, в свою очередь, позволяет использовать фреймворки, написанные на JavaScript, такие как <b>Express</b>. </p>
<p>Другим важным компонентом является база данных. Все веб-приложения, кроме самых простых, потребуют базы данных, и существуют базы данных, которые лучше других подходят экосистеме Node.</p>
<p>Ничего удивительного, что имеются интерфейсы для всех ведущих реляционных баз данных (<i>MySQL</i>, <i>MariaDB</i>, <i>PostgreSQL</i>, <i>Oracle</i>, <i>SQL Server</i>, <i>NoSQL-базы данных</i>, <i>MongoDB</i>): было бы глупо пренебрегать этими признанными китами. </p>

<h3>Стеки технологий с Node.js</h3>
<p>Поскольку создание работоспособного сайта зависит сразу от нескольких технологических составляющих, были придуманы акронимы для описания стека, на котором основан сайт. Например, сочетание <span class="code">Linux</span>, <span class="code">Apache</span>, <span class="code">MySQL</span>, <span class="code">PHP</span> именуется стеком <span class="code">LAMP</span>. </p>
<p>Валерий Карпов, программист из MongoDB, изобрел акроним <span class="code">MEAN</span>: <span class="code">Mongo</span>, <span class="code">Express</span>, <span class="code">Angular</span> и <span class="code">Node</span>. Действительно легко запоминающийся, он имеет и свои ограничения: существует столько разных вариантов выбора баз данных и инфраструктуры разработки приложений, что MEAN не охватывает всего разнообразия экосистемы (а также оставляет за скобками важный компонент, — <i>механизм рендеринга</i>).</p>
<p>Обязательный компонент, конечно, Node. Хотя есть и другие серверные JavaScript-контейнеры, Node становится преобладающим. Express тоже не единственный доступный фреймворк веб-приложений, хотя он и приближается к Node по распространенности. </p>
<p>Два других компонента, обычно существенных для разработки веб-приложений, — <b>сервер баз данных</b> и <b>механизм рендеринга</b> (это либо <b>шаблонизатор</b> наподобие Handlebars, либо <b>фреймворк одностраничных приложений</b>, вроде React).</p>

<h2>Начало работы с Node</h2>
<h3>Установка Node</h3>
<p>Начать установку Node проще всего со страницы <a href="https://nodejs.org/en/download/package-manager">Downloads</a> проекта Node.js. Если ваше окружение подготовлено к сборке, загрузите исходный код и постройте Node напрямую.</p>
<p>Если вы решите компилировать Node прямо на своей машине, вы должны настроить правильную среду сборки и установить необходимые инструменты сборки. Например, в Ubuntu (Linux) установка инструментов, необходимых для Node, выполняется следующей командой:</p>
<pre><code >apt-get install make g++ libssl-dev git</code></pre>
<h3>Создание проекта Node</h3>
<p>Чтобы использовать npm, создайте файл package.json в каталоге, содержащем проект Node. Проще всего поручить создание файла package.json менеджеру npm.</p>
<p>Введите следующую команду в командной строке:</p>
<pre><code >mkdir example-project
cd example-project
npm init -y</code></pre>
<p>Открыв файл <i>package.json</i>, вы увидите простые данные в формате JSON с описанием вашего проекта. Если теперь установить модуль некоторый модуль с ключом <span class="code">--save</span>, <span class="code">npm</span> автоматически обновит файл <span class="code">package.json</span>. Например: :</p>
<pre><code >npm i --save express</code></pre>
<p>Если теперь открыть файл package.json, вы увидите, что в свойстве <span class="code">dependencies</span> добавился пакет express. Кроме того, в папке node_modules появился каталог express. Он содержит только что установленную версию Express.</p>
<p>Таким образом, чтобы создать простейшей веб-приложение Node (с использованием Express) нам надо в терминале вызвать следующие команды:</p>
<pre><code >mkdir hello_express
cd hello_express
npm init -y
npm i express --save</code></pre>


<h2>Простой веб-сервер с помощью Node</h2>
<p>Если вы когда-либо создавали статический сайт или работали с PHP или ASP,
вероятно, вам привычна идея веб-сервера (например, Apache), выдающего статические файлы таким образом, что браузер может видеть их по сети. Например, если вы создаете файл <span class="code">about.html</span> и помещаете его в соответствующий каталог, то можете затем перейти по адресу <span class="code">http://localhost/about.html</span>. В зависимости от настроек веб-сервера вы можете даже опустить <span class="code">.html</span>, но связь между URL и именем файла очевидна: веб-сервер просто знает, где на компьютере находится файл, и выдает его браузеру.</p>
<p>Node предлагает парадигму, отличную от той, что имеет обычный веб-сервер:
создаваемое вами приложение и является веб-сервером. Node просто обеспечивает
вас фреймворком для создания веб-сервера.</p>

<h3>"Hello, world!"</h3>
<p>Начнем с традиционного.</p>
<pre><code>const http = require('http');

http.createServer(function(request, response) {
    response.writeHead(200, {'Content-Type': 'text/plain'});
    response.end('Hello World\n');
}).listen(8124);

console.log('Server running at http://127.0.0.1:8124/');</code></pre>
<p>Теперь вызовем команду в консоли:</p>
<pre><code >npm start</code></pre>
<p>JavaScript создает веб-сервер, который при обращении к нему из браузера выводит веб-страницу со словами <i>«Hello, World»</i>.</p>
<p>Сначала программа включает необходимый для запуска простого сервера HTTP-модуль с подходящим именем <span class="code">http</span>. Внешняя функциональность Node подключается при помощи модулей, экспортирующих определенные типы функциональности, которая может использоваться в приложении (или другом модуле). Модули очень похожи на библиотеки в других языках программирования.</p>
<p>Модуль импортируется командой Node <span class="code">require</span>, а результат присваивается локальной переменной. После импортирования локальная переменная может использоваться для создания экземпляра веб-сервера функцией <span class="code">http.createServer()</span>. В параметрах функции встречается одна из фундаментальных
конструкций Node: <b>функция обратного вызова</b> (<i>callback</i>). Эта
анонимная функция передает веб-запрос и ответ коду, который обрабатывает
веб-запрос и предоставляет ответ.</p>
<p>Напомним, что JavaScript — <b>однопоточный</b> (<i>single-threaded</i>) язык, и поэтому для имитации асинхронного выполнения в Node используется цикл событий, а функции обратного вызова вызываются при срабатывании определенного события. В примере выше функция обратного вызова вызывается при получении веб-запроса.</p>
<p>Сообщение <span class="code">console.log()</span> выводится на терминал сразу же при вызове создания сервера. Программа не прекращает работу в блокирующем режиме, ожидая веб-запроса.</p>
<p>После того как сервер будет создан и получит запрос, функция обратного
вызова передает браузеру простой текстовый заголовок с кодом статуса 200,
выводит сообщение <span class="code">Hello World</span> и завершает ответ.</p>
<p>Даже лучше присвоить экземпляр сервера константной переменной и переписать наш пример следующим образом: </p>
<pre><code >const http = require('http')
const port = process.env.PORT || 3000
const server = http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/plain' })
    res.end('Hello world!')
})
server.listen(port, () => console.log(
`сервер запущен на порте ${port};\n` +
`http://localhost:${port}\n`+
'нажмите Ctrl+C для завершения...'))</code></pre>
<p>В этом примере кода событие неявное: обрабатываемое событие — HTTP-запрос. Метод <span class="code">http.createServer</span> принимает функцию в качестве аргумента, она будет вызываться каждый раз при выполнении HTTP-запроса. Наша простая программа просто устанавливает в качестве типа содержимого неформатированный текст и отправляет строку <span class="code">Hello world!</span>.</p>

<h3>Расширяем "Hello, world!"</h3>
<p>Расширим пример, включив в него обработку входящего запроса. Имя выделяется из строки и используется для определения типа возвращаемого контента. Почти для любого имени будет возвращен персонализированный ответ, но если использовать в запросе параметр <span class="code">name=burningbird</span>, вы получите изображение.</p>
<p>Если строка запроса не используется или в нем не указано имя, переменной
<span class="code">name</span> присваивается значение <span class="code">'world'</span>.</p>

<pre><code>const http = require('http');
const fs = require('fs');
http.createServer(function (req, res) {
    var name = require('url').parse(req.url, true).query.name;
    if (name === undefined) name = 'world';
    if (name == 'burningbird') {
        var file = 'phoenix5a.png';
        fs.stat(file, function (err, stat) {
            if (err) {
            console.error(err);
            res.writeHead(200, {'Content-Type': 'text/plain'});
            res.end("Sorry, Burningbird isn't around right now \n");
        } else {
            var img = fs.readFileSync(file);
            res.contentType = 'image/png';
            res.contentLength = stat.size;
            res.end(img, 'binary');
        }
    });
    } else {
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end('Hello ' + name + '\n');
    }
}).listen(8124);</code></pre>
<p>В начале кода в приложение включается новый модуль с именем <span class="code">fs</span>. Это модуль файловой системы (<i>File System</i>), с которым вы близко познакомитесь в последующих главах. Но при этом в программе импортируется еще один модуль, но не так, как два других:
свойства экспортируемых модулей могут объединяться в цепочки, что позволяет импортировать модуль и использовать его функции в одной строке. Это
часто происходит в модуле <span class="code">url</span>, единственная цель которого — предоставить инструменты для работы с URL-адресами.</p>
<p>Имена параметров ответа (<i>response</i>) и запроса (<i>request</i>) для удобства часто сокращаются до <span class="code">res</span> и <span class="code">req</span> соответственно. После разбора запроса для получения значения <span class="code">name</span> программа сначала проверяет, равен ли параметр <span class="code">undefined</span>.</p>
<p>Если параметр не определен, используется значение по умолчанию <span class="code">world</span>. Если же значение <span class="code">name</span> существует, оно снова проверяется и сравнивается с <span class="code">burningbird</span>. Если значения не совпадают, то приложение возвращает почти такой же ответ, как в исходном приложении, не считая того, что в возвращаемое сообщение подставляется переданное имя.</p>
<p>Но если параметр <span class="code">name</span> содержит строку <span class="code">burningbird</span>, это означает, что вместо текста придется иметь дело с изображением. Метод <span class="code">fs.stat()</span> не только
проверяет, что файл существует, но также возвращает объект с информацией
о файле, включающей его размер. Значение используется для создания заголовка контента.</p>
<p>Если файл не существует, то приложение корректно обрабатывает ситуацию:
оно выводит дружелюбное сообщение об ошибке и информацию на консоль,
для чего на этот раз используется метод <span class="code">console.error()</span>:</p>
<pre><code >{ [Error: ENOENT: no such file or directory, stat 'phoenix5a.png']
errno: -2,
code: 'ENOENT',
syscall: 'stat',
path: 'phoenix5a.png'}</code></pre>
<p>Если файл существует, то изображение загружается в переменную и возвращает его в ответе, изменяя значения в заголовке соответствующим образом.</p>
<p>Метод <span class="code">fs.stat()</span> использует стандартный для Node паттерн функции обратного вызова с передачей значения ошибки в первом параметре. Эта часть кода может просто необычно выглядеть и быть не похожей на другие функции Node, которые встречались ранее. Главное отличие — использование синхронной функции
<span class="code">readFileSync()</span> вместо асинхронной версии <span class="code">readFile()</span>.</p>
<p>Node поддерживает как синхронную, так и асинхронную версию большинства
функций файловой системы. Обычно <b>использование синхронных операций
в веб-запросах в Node считается крайне нежелательным</b>, но такая возможность
существует.</p>



<h3>Маршрутизация</h3>
<p>Как только вы начнете думать, опираясь на термины событийно-ориентированного программирования, вы будете видеть события повсюду. Одним из таких событий является переход пользователя с одной страницы или области приложения на другую. То, как приложение отвечает на этот переход, называется <b>маршрутизацией</b>.</p>
<p>Маршрутизация относится к механизму выдачи клиенту контента, который он запрашивал. Для клиент-серверных веб-приложений клиент определяет желаемый
контент в URL, а именно путь и строку запроса</p>
<p>По сложившейся традиции серверная маршрутизация напрямую зависит от пути
и строки запроса, хотя доступна и другая информация: заголовки, домен, IP-адрес
и т. д. Благодаря этому сервер может учитывать, например, приблизительное
физическое местоположение пользователя или предпочитаемый им язык.</p>
<p>Расширим наш пример с «Hello world!» так, чтобы происходило что-то более
интересное. Создадим минимальный сайт, состоящий из домашней страницы,
страниц <i>О нас</i> и <i>Не найдено</i>. Пока будем придерживаться предыдущего примера и просто начнем выдавать неформатированный текст вместо HTML-кода:</p>
<pre><code >const http = require('http')
const port = process.env.PORT || 3000
const server = http.createServer((req,res) => {
// Приводим URL к единому виду, удаляя
// строку запроса, необязательную косую черту
// в конце строки и переводя в нижний регистр.
    const path = req.url.replace(/\/?(?:\?.*)?$/, '').toLowerCase()
    switch(path) {
        case '':
        res.writeHead(200, { 'Content-Type': 'text/plain' })
        res.end('Homepage')
        break
    case '/about':
        res.writeHead(200, { 'Content-Type': 'text/plain' })
        res.end('About')
        break
    default:
        res.writeHead(404, { 'Content-Type': 'text/plain' })
        res.end('Not Found')
        break
    }
})
server.listen(port, () => console.log(`сервер запущен на порте ${port};\n` +
`http://localhost:${port}\n`+
`http://localhost:${port}/about\n`+
`http://localhost:${port}/404\n`+
'нажмите Ctrl+C для завершения...'))</code></pre>

<h3>Раздача статических ресурсов</h3>
<p>Теперь, когда заработала простейшая маршрутизация, раздадим какой-нибудь
реальный HTML-код и логотип. Они носят название <span data-tippy-content='Раздача статических ресурсов с помощью Node подходит для нужд разработкии небольших проектов. В проектах побольше вы, вероятно, захотите использовать для этих целей прокси-сервер, такой как Nginx или CDN.'><b>статических ресурсов</b></span>, поскольку обычно не изменяются (в отличие, например, от тикера: каждый раз, когда вы перезагружаете страницу, биржевые котировки меняются).</p>

<p>Если вы работали с Apache или IIS, то, вероятно, просто создавали HTML-файл,
переходили к нему и автоматически открывали в браузере. Node работает иначе:
нам придется выполнить работу по открытию файла, его чтению и отправке его
содержимого браузеру. Так что создадим в нашем проекте каталог <span class="code">public</span> (в следующей главе станет понятно, почему мы не называем его <span class="code">static</span>). В нем создадим
<span class="code">home.html</span>, <span class="code">about.html</span>, <span class="code">404.html</span>, подкаталог с названием <span class="code">img</span> и изображение с именем <span class="code">img/logo.jpg</span>. Выполните эти шаги самостоятельно: раз вы читаете эту книгу,
то, вероятно, знаете, как создать HTML-файл и найти картинку. В ваших HTML-файлах ссылайтесь на логотип следующим образом: <span class="code">&lt;img src="/img/logo.jpg" alt="logo"></span>.</p>
<p>Теперь внесем изменения в файл <span class="code">helloworld.js</span>:</p>
<pre><code >const http = require('http')
const fs = require('fs')
const port = process.env.PORT || 3000
function serveStaticFile(res, path, contentType, responseCode = 200) {
    fs.readFile(__dirname + path, (err, data) => {
    if(err) {
        res.writeHead(500, { 'Content-type': 'text/plain' })
        return res.end('500 — Внутренняя ошибка')
    }
    res.writeHead(responseCode, { 'Content-type': contentType })
        res.end(data)
    })
}
const server = http.createServer((req,res) => {
// Приводим URL к единому виду, удаляя
// строку запроса, необязательную косую черту
// в конце строки и переводя в нижний регистр.
const path = req.url.replace(/\/?(?:\?.*)?$/, '').toLowerCase()
switch(path) {
    case '':
        serveStaticFile(res, '/public/home.html', 'text/html')
        break
    case '/about':
        serveStaticFile(res, '/public/about.html', 'text/html')
        break
    case '/img/logo.png':
        serveStaticFile(res, '/public/img/logo.png', 'image/png')
        break
    default:
        serveStaticFile(res, '/public/404.html', 'text/html', 404)
        break
    }
})
server.listen(port, () => console.log(`сервер запущен на порте ${port}; ` +
'нажмите Ctrl+C для завершения...'))</code></pre>
<p>Обратите внимание, что мы создали функцию-хелпер, <span class="code">serveStaticFile</span>, выполняющую большой объем работы. <span class="code">fs.readFile</span> — асинхронный метод для чтения файлов. Существует синхронная версия этой функции — <span class="code">fs.readFileSync</span>, но чем быстрее вы начнете мыслить асинхронно, тем лучше.</p>
 <p>В функции <span class="code">fs.readFile</span> используется шаблон под названием «обратный вызов» (<i>callbacks</i>). Вы предоставляете функцию обратного вызова (<i>callback function</i>), и после того, как работа выполнена, происходит вызов этой функции (так сказать, она «вызывается обратно»). В этом случае <span class="code">fs.readFile</span> читает содержимое указанного файла и выполняет функцию обратного вызова по завершении чтения файла. Если файла не существует или были проблемы с правами доступа при чтении файла, устанавливается значение переменной <span class="code">err</span> и функция возвращает код состояния HTTP <span class="code">500</span>, указывающий на ошибку сервера. Если файл был прочитан успешно, он отправляется клиенту с заданным кодом ответа и типом содержимого.</p>
<p>Запись <span class="code">__dirname</span> будет соответствовать каталогу, в котором находится выполняемый скрипт. Если ваш скрипт размещен в <span class="code">/home/sites/app.js</span>, <span class="code">__dirname</span> будет соответствовать <span class="code">/home/sites</span>. Использовать такую удобную глобальную переменную везде, где возможно, — хорошая идея. Если этого не сделать, можно получить трудно диагностируемые ошибки при запуске приложения из другого каталога.</p>
<h2>Node не только для веб-приложений</h2>
<p>Не вся веб-разработка связана с построением веб-приложений. Иногда разработчику приходится решать такие задачи, как например извлечение данных со старого сайта, которые должны использоваться при его обновлении.</p>
<h3>Средства командной строки и демоны</h3>
<p>Node используется для написания средств командной строки, таких как менеджеры процессов и транспиляторы JavaScript, используемые разработчиками JavaScript. Однако Node также может стать удобной платформой для написания удобных средств командной строки, которые выполняют другие операции, включая преобразование графики, и сценариев для управления воспроизведением мультимедийных материалов.</p>
<p>Ниже приведен простой пример, который вы можете опробовать. Создайте новый
файл с именем <span class="code">cli.js</span> и добавьте в него следующие строки:</p>
<pre><code >const [nodePath, scriptPath, name] = process.argv;
console.log('Hello', name);</code></pre>
<p>Запустите сценарий командой <span class="code">cli.js yourName</span>; вы увидите сообщение <span class="code">Hello yourName</span>. В сценарии функциональность деструктуризации ES2015 используется для извлечения третьего аргумента из <span class="code">process.argv</span>. Объект <span class="code">process</span> доступен в любой программе; с его помощью программа получает аргументы, заданные пользователем при запуске.</p>
<p>У программ командной строки Node также имеются полезные возможности. Если
добавить в начало программы строку, которая начинается с <span class="code">#!</span>, и предоставить файлу разрешение на исполнение (<span class="code">chmod+x cli.js</span>) , вы сможете заставить командный интерпретатор использовать Node при запуске программы. После этого программы Node можно будет запускать точно так же, как любые другие сценарии командного интерпретатора. Для систем семейства Unix добавляется следующая строка:</p>
<pre><code >#!/usr/bin/env node</code></pre>
<p>При таком использовании Node вы сможете заменить свои сценарии командного
интерпретатора командами Node. Это означает, что Node можно будет использовать с любыми другими инструментами командной строки, включая фоновые программы. Программы Node могут запускаться при помощи cron или работать
в фоновом режиме как демоны</p>
<h3>Настольные приложения</h3>
<p>Если вы работали с текстовым редактором Atom или Visual Studio Code — знайте,
что вы все это время использовали Node. Фреймворк Electron использует Node для
реализации своих операций, поэтому каждый раз, когда требуется выполнить ввод/
вывод с диском или сетью, Electron обращается к Node. Также Electron использует
Node для управления зависимостями; это означает, что вы сможете добавлять пакеты из npm в проекты Electron.</p>
<h3>Приложения, хорошо подходящие для Node</h3>
<p>Мы рассмотрели некоторые разновидности приложений, которые можно построить с Node, но существуют некоторые типы приложений, в которых Node особенно заметно превосходит конкурентов.</p>
<p>Node обычно используется для создания веб-приложений реального времени; к этой категории может относиться что угодно, от пользовательских приложений (скажем, чат-серверов) до внутренних систем сбора аналитики. Так как функции в JavaScript являются полноправными объектами, а в Node имеется встроенная модель событий, написание асинхронных программ реального времени проходит более естественно, чем в других языках сценариев.</p>
<p>Если вы строите традиционные веб-приложения MVC (Model-View-Controller), Node хорошо подходит и для них. На базе Node строятся многие популярные системы ведения блогов, например Ghost; платформа Node хорошо зарекомендовала себя для подобных веб-приложений. Стиль разработки отличается системы WordPress, построенной с использованием PHP, но Ghost поддерживает многие аналогичные возможности, включая шаблоны и многопользовательские средства администрирования.</p>
<p>Node также может делать то, что в других языках делается намного сложнее. Node базируется на JavaScript, поэтому в Node возможно выполнение браузерного кода JavaScript. Сложные клиентские приложения могут адаптироваться для выполнения на сервере Node, что позволяет серверам заранее генерировать веб-приложения; это сокращает время визуализации страниц в браузере и упрощает работу поисковых систем.</p>
<p>Наконец, если вы занимаетесь построением настольных или мобильных приложений, опробуйте фреймворк Electron, работающий на базе Node. В наши дни, когда веб-интерфейсы пользователя не уступают настольным, настольные приложения Electron могут конкурировать с платформенными веб-приложениями при сокращенном времени разработки. Electron также поддерживает три основные платформы, поэтому ваш код будет работать в Windows, Linux и macOS.</p>

<h2>Параметры <span data-tippy-content='командная строка=терминал=консоль'>командной строки</span> Node</h2>

<p>В предыдущем пункте Node запускается в командной строке без параметров командной строки. Однако они могут быть весьма полезны.</p>
<p>Чтобы получить информацию обо всех доступных параметрах, воспользуйтесь
ключом <span class="code">-h</span> или <span class="code">--help</span>.</p>
<p>С этим параметром команда node выводит список всех параметров и синтаксис
запуска приложения Node:</p>
<pre><code >Usage: node [options] [ -e script | script.js ] [arguments]
node debug script.js [arguments]</code></pre>
<p>Для получения версии Node используется следующая команда:</p>
<pre><code >$ node -v или --version</code></pre>
<p>Для проверки синтаксиса приложения Node используется параметр <span class="code">-c</span>. С этим
параметром команда node проверяет синтаксис без запуска приложения:</p>
<pre><code >$ node -c or --check script.js</code></pre>
<p>Чтобы получить информацию о параметрах V8, введите следующую команду:</p>
<pre><code >$ node --v8-options</code></pre>
<p>Очень полезный параметр Node — <span class="code">-p</span> или <span class="code">–print</span> — обрабатывает строку сценария Node и выводит результаты. Данная возможность особенно полезна
при проверке свойств окружения процесса. В следующем примере выводятся все значения свойства
<span class="code">process.env</span>:</p>
<pre><code >$ node -p "process.env</code></pre>

<h3>Обновление Node</h3>
<p>Версию Node можно проверить следующей командой:</p>
<pre><code >node -v</code></pre>
<p>Если вы используете программу установки пакетов, то запуск процедуры обновления пакетов приведет к обновлению Node и всего остального программного обеспечения на сервере (<i>в системе Windows команда sudo не нужна</i>):</p>
<pre><code >sudo apt-get update
sudo apt-get upgrade --show-upgraded</code></pre>
<p>Также для обновления Node можно воспользоваться менеджером пакетов npm.
Последовательность команд обновления выглядит так:</p>
<pre><code >sudo npm cache clean -f
sudo npm install -g
sudo n stable</code></pre>
<p>Программа <span class="code">npm</span> (<b>Node Package Manager</b>) обновляется чаще, чем Node. Чтобы обновить только <span class="code">npm</span>, выполните следующую команду:</p>
<pre><code >sudo npm install npm -g n</code></pre>

<h2>Отладчик Node</h2>
<p>В поставку Node включается отладчик с поддержкой пошагового выполнения и <span data-tippy-content='Read-Eval-Print Loop'>REPL</span>. Работа отладчика основана на взаимодействии с вашей программой по сетевому протоколу. Чтобы запустить программу в отладчике, укажите аргумент debug в командной строке</p>
<pre><code>node debug hello.js</code></pre>
<div class="code-example-output-title"><span>Вывод:</span>
<div class="code-example-output">
<pre>
< Debugger listening on [::]:5858
connecting to 127.0.0.1:5858 ... ok
break in node-http.js:1
>   1 const http = require('http');
    2 const port = 8080;
    3 ...
</pre>
</div>
</div>
<p>Node поддерживает отладочный протокол Chrome. Чтобы отладить сценарий
с использованием средств разработчика Chrome, укажите флаг <span class="code">--inspect</span> при запуске программы:</p>
<pre><code >node --inspect --debug-brk</code></pre>
<p>Node запускает отладчик и прерывает выполнение в первой строке. На
консоль выводится URL-адрес; откройте его в Chrome для использования
встроенного отладчика Chrome. Отладчик Chrome позволяет выполнять код
строку за строкой, при этом он выводит значения всех переменных и объектов.
Этот способ намного удобнее ввода команды <span class="code">console.log</span>.</p>

<h2>Диспетчер пакетов <span class="code">npm</span></h2>
<p><span class="code">npm</span> — повсеместно распространенная система управления пакетами для Node.</p>
<p>В целом двумя основными задачами системы управления пакетами являются
установка пакетов и управление зависимостями. <span class="code">npm</span> — быстрая и эффективная система управления пакетами, которой, как мне кажется, экосистема Node обязана своим быстрым ростом и разнообразием.</p>
<p><span class="code">npm</span> устанавливается при инсталляции Node, так что, если вы следовали перечисленным ранее шагам, она у вас уже есть.</p>
<p>Основная команда, которую вы будете использовать с <span class="code">npm</span> (что неудивительно), — <span class="code">install</span>. Например, чтобы установить <span class="code">nodemon</span> (популярную утилиту для
автоматической перезагрузки программы Node после внесения изменений в исходный код), можно выполнить следующую команду в консоли:</p>
<pre><code >npm install -g nodemon</code></pre>
<p>Флаг <span class="code">-g</span> сообщает <span class="code">npm</span> о необходимости глобальной установки пакета, означающей его доступность по всей системе. Это различие будет понятнее, когда мы
рассмотрим файлы <span class="code">package.json</span>. Пока же примем за эмпирическое правило, что утилиты JavaScript, такие как <i>nodemon</i> или <i>gulp-cli</i>, обычно будут устанавливаться глобально, а специфические для вашего веб-приложения пакеты — нет. Под служебными программами чаще всего понимаются запускаемые из командной строки.</p>

<h3>Базовые модули Node</h3>
<p>Сами стандарты JavaScript не включают никаких средств для работы с сетью — и даже файлового ввода/вывода в том виде, в котором его представляет большинство разработчиков серверного кода. Чтобы Node можно было использовать для серверного программирования, в эту платформу необходимо было добавить средства для работы с файлами и сетевых операций TCP/IP.</p>
<h4>Файловая система</h4>
<p>В поставку Node включается <b>библиотека файловой системы</b> (<span class="code">fs</span>, <span class="code">path</span>), <b>клиенты и серверы TCP</b> (<span class="code">net</span>), <b>поддержка HTTP</b> (<span class="code">http</span> и <span class="code">https</span>) и <b>разрешения доменных имен</b> (<span class="code">dns</span>). Также имеется полезная библиотека, которая используется в основном для <b>написания тестов</b> (<span class="code">assert</span>), и библиотека операционной системы <b>для запроса информации о платформе</b> (<span class="code">os</span>).</p>
<p>Node также содержит ряд уникальных библиотек. Модуль <span class="code">events</span> — небольшая библиотека <b>для работы с событиями</b> — используется в качестве основы для многих API Node. Например, модуль <span class="code">stream</span> использует модуль <span class="code">events</span><b> для предоставления абстрактных интерфейсов для работы с потоками данных</b>. Поскольку все потоки данных в Node используют одни и те же API, вы можете легко составлять программные компоненты; если у вас имеется объект чтения файлового потока, вы можете направить его через преобразование <span class="code">zlib</span>, которое <b>выполняет сжатие данных</b>, а затем через объект записи в файловый поток для записи данных в файл.</p>
<p>В следующем листинге продемонстрировано использование модуля Node fs для создания потоков чтения и записи, которые могут направляться через другой поток (<span class="code">gzip</span>) для преобразования данных — в данном случае их сжатия:</p>
<pre><code >const fs = require('fs');
const zlib = require('zlib');
const gzip = zlib.createGzip();
const outStream = fs.createWriteStream('output.js.gz');
fs.createReadStream('./node-stream.js')
    .pipe(gzip)
    .pipe(outStream);</code></pre>


<h3>Сетевые операции</h3>
<p>Существует распространенное мнение, что создание простого сервера H TTP было настоящим примером программы <i>«Hello World»</i> для Node. Чтобы построить сервер на базе Node, необходимо загрузить модуль http и передать ему функцию. Функция получает два аргумента: входной запрос и выходной ответ:</p>
<pre><code >const http = require('http');
const port = 8080;
const server = http.createServer((req, res) => {
    res.end('Hello, world.');
});
server.listen(port, () => {
    console.log('Server listening on: http://localhost:% s', port);
});</code></pre>


<h2>Среда хостинга Node</h2>
<p>Когда вы будете
готовы предоставить расширенный доступ к своим приложениям, вам придется найти либо среду для запуска приложения Node, либо хост, специально предоставляющий поддержку приложений Node. Первый вариант потребует существенного опыта управления сервером, доступным из Интернета, а второй нередко ограничивает то, что вы можете (или не можете) делать в своих приложениях Node.</p>

<h3>Хостинг Node на вашем сервере, VPS или управляемом хосте</h3>
<p>Хостинг Node на виртуальном частном сервере (<b>VPS</b>, <i>Virtual Private Server</i>) — простое решение. Вам не потребуется привилегированный доступ к VPS, и вы сможете делать практически все, что захотите, при условии, что это не создаст опасности для других пользователей, работающих на том же компьютере. Большинство компаний, предоставляющих услуги VPS, принимают меры к тому, чтобы все учетные записи были изолированы друг от друга и ни одна учетная запись не могла захватить все доступные ресурсы.</p>
<p>Однако с VPS возникает та же проблема, что и с собственным сервером: вам придется заниматься сопровождением сервера. В частности, вам придется настроить систему электронной почты и альтернативный веб-сервер (вероятнее всего, Apache или Nginx) для работы с брандмауэрами и другими средствами
безопасности, электронной почтой и т. д. Все это не просто.</p>
<p>Тем не менее, если вы уверенно чувствуете себя в области управления всеми аспектами среды, доступной из Интернета, VPS может предоставить бюджетный вариант хостинга приложений Node — по крайней мере до того, как вы будете готовы запустить приложение в эксплуатацию (в этом случае можно рассмотреть возможность хостинга приложения в облаке).</p>

<h3>Облачный хостинг</h3>
<p>В наши дни приложения размещаются на облачных серверах так же часто, как и на компьютерах отдельных лиц и групп. Приложения Node хорошо подходят
для реализаций на базе облачных технологий.</p>
<p>Когда вы размещаете приложение Node в облаке, вы фактически строите приложение на вашем собственном сервере или PC, тестируете его, убеждаетесь
в том, что оно работает так, как нужно, и пересылаете приложение на облачный
сервер. Облачный сервер для Node позволяет создать нужное вам приложение
Node с использованием ресурсов баз данных и любых других необходимых
систем, но без прямого управления сервером. Вы можете сосредоточиться
на функциональности приложения Node, не отвлекаясь на серверы FTP или
электронной почты или общее управление сервером.</p>
<p>Почти
все операции с приложениями Node, включая отправку приложений на облачный сервер, выполняются через Git. Когда речь заходит о Git, эта система обычно ассоциируется с GitHub. Сопровождение исходного кода Node.js осуществляется на GitHub, как и код многих (если не всех) существующих модулей Node.</p>
<p>Парадигма хостинга приложений Node в облаке на разных хостах имеет много
общего. Сначала вы создаете приложение Node (локально либо на своем сервере). Когда все будет готово к тестированию среды развертывания, пора переходить к поиску облачного сервера. Для большинства известных мне серверов вы
создаете учетную запись, создаете новый проект и указываете, что приложение
работает на базе Node, если облачный сервер поддерживает хостинг разных
сред. Возможно, вам также придется указать другие необходимые ресурсы
(например, доступ к базе данных).</p>
<h2>Лицензирование</h2>
<p>При разработке веб-приложений Node вы можете обнаружить, что уделяете лицензированию больше внимания, чем когда-либо раньше.</p>
<p>Одно из преимуществ экосистемы Node — огромный набор доступных пакетов.
Однако у каждого из этих пакетов свои правила лицензирования, хуже того, каждый пакет может зависеть от других пакетов, а значит, условия лицензирования различных частей написанного вами приложения могут оказаться запутанными.</p>
<p>Однако есть и хорошие новости. Одна из наиболее популярных лицензий для
пакетов Node — лицензия <b>MIT</b> исключительно либеральна и позволяет вам делать практически все, что хотите, включая использование пакета в программном обеспечении с закрытым исходным кодом. Но не следует просто предполагать, что каждый используемый вами пакет лицензирован MIT.</p>
<p>Хотя MIT — самая распространенная лицензия, вы можете также увидеть следующие лицензии:</p>
<ul>
    <li><b>Стандартная общественная лицензия GNU</b> (<i>GNU General Public License, GPL</i>) — распространенная лицензия для программного обеспечения с открытым исходным кодом, искусно разработанная для того, чтобы сохранить свободу программного обеспечения. Это значит, что, если вы используете лицензированный по GPL код в своем проекте, проект тоже обязан быть GPL-лицензированным. Естественно, это означает, что проект не может иметь закрытый исходный код</li>
    <li><b>Apache 2.0</b> - это лицензия, которая, подобно MIT, позволяет использовать другую лицензию для проекта, в том числе лицензию с закрытым исходным кодом. Вы обязаны, однако, включить уведомление о компонентах, использующих лицензию Apache 2.0.</li>
    <li><b>Лицензия Университета Беркли для ПО</b> (<i>Berkeley Software Distribution, BSD</i>) - подобно Apache, лицензия, которая позволяет использовать для проекта какую угодно лицензию при условии включения уведомления об использующих лицензию BSD компонентах.</li>
</ul>