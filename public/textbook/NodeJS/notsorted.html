<!--<title>Глава 999. Не сортировано</title>-->
<h1>Глава 999. Не сортировано</h1>
<h2>Неблокирующий ввод/вывод</h2>
<p>Что это означает в контексте программирования <i>"на стороне сервера"</i>? Запросы ввода/вывода (например, обращения к диску или сетевым ресурсам) выполняются относительно медленно, поэтому исполнительная среда не должна блокировать выполнение бизнес-логики во время чтения файлов или передачи сообщений по сети. </p>
<p>Для этого в Node используются три концепции:
<b>события</b>, <b>асинхронные API</b>, <b>неблокирующий ввод/вывод</b>.</p>
<p><b>Неблокирующий ввод/вывод</b> — низкоуровневый термин с точки зрения программиста Node. Он означает, что программа может обратиться с запросом к сетевому ресурсу и заняться чем-то другим. А потом, когда сетевая операция будет завершена, выполняется функция обратного вызова, которая обработает результат.</p>
<p>На <a href="#async_nonblocking_components">рис. ниже</a> изображено типичное веб-приложение Node, использующее библиотеку веб-программирования Express для обработки заказов в магазине. В нем:</p>
<ol>
    <li>Браузер выдает запрос на приобретение продукта;</li>
    <li>приложение проверяет текущее состояние складских запасов</li>
    <li>создает учетную запись для пользователя</li>
    <li>отправляет квитанцию по электронной почте</li>
    <li>возвращает HTTP-ответ в формате JSON</li>
    <b>Одновременно с этим:</b>
    <li>квитанция отправляется по электронной почте</li>
    <li>база данных обновляется информацией от пользователя и данными заказа</li>
</ol>
<p>По сути, перед нами прямолинейный императивный код JavaScript, но исполнительная среда работает параллельно, потому что она использует неблокирующий ввод/вывод.</p>
<a id="async_nonblocking_components" href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/qMCJhnpt/image.png' border='0' alt='image'/></a>
<p>На <a href="#async_nonblocking_components">рис. выше</a> приложение обращается к базе данных по сети. В Node сетевые операции выполняются без блокировки, потому что Node при помощи библиотеки <span class="code">libuv</span> использует неблокирующие сетевые вызовы операционной системы. Эта функциональность по-разному реализована для Linux, macOS и Windows, но вам придется иметь дело только с удобной библиотекой JavaScript для работы с базами данных. Хотя вы пишете команды типа <span class="code">db.insert(query, err => {})</span>, Node во внутренней реализации выполняет оптимизированные неблокирующие сетевые операции.</p>
<p>Обращения к диску происходят примерно так же, но, как ни странно, полного совпадения нет. Когда приложение генерирует квитанцию, отправляемую по электронной почте, и шаблон сообщения читается с диска, <span class="code">libuv</span> использует пул потоков для создания иллюзии использования неблокирующего вызова. Управление пулом потоков — довольно тяжелое дело, но понять команду <span class="code">email.send('template.ejs', (err, html) => {})</span> определенно намного проще.</p>
<p>Истинное преимущество использования асинхронных API с неблокирующими операциями ввода/вывода заключается в том, что Node может заниматься другими делами во время выполнения относительно медленных процессов. И хотя выполняться может только однопоточное и однопроцессное веб-приложение Node, в любой момент времени оно может обрабатывать сразу несколько подключений от тысяч потенциальных посетителей сайта. Чтобы понять, как это происходит, необходимо познакомиться с циклом событий.</p>
<h2>Цикл событий</h2>
<p>Cосредоточимся на одном конкретном аспекте: <b>обработке запросов браузера</b>. <a href="#async_nonblocking_components">В примере выше</a> базовый модуль с именем <span class="code">http.Server</span> обрабатывает запрос с использованием потоков, событий и парсера HTTP-запросов Node, который содержит платформенный код. При этом инициируется выполнение функции обратного вызова в вашем приложении, которая была добавлена средствами библиотеки веб-приложений Express. Выполняемая функция обратного вызова выдает запрос к базе данных, и в конечном итоге приложение отвечает данными JSON с использованием HTTP. Весь процесс использует как минимум три неблокируемых сетевых вызова: один для запроса, один для базы данных и один для ответа. Как Node планирует все эти неблокирующие сетевые операции? Ответ: при помощи <b>цикла событий</b>. На <a href="#event-cycle">рис. ниже</a> показано, как цикл событий используется для этих трех сетевых операций</p>
<a id="event-cycle" href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/02YZZWf7/image.png' border='0' alt='image'/></a>
<p>Цикл событий работает в одном направлении (он реализуется очередью <span data-tippy-content='"first-in-first-out"="первым пришел, первым вышел"'>FIFO</span> и проходит через несколько фаз. На <a href="#event-cycle">рис. выше</a> показана упрощенная последовательность важнейших фаз, выполняемых при каждой итерации цикла:</p>
<ol>
    <li>Сначала выполняются таймеры, выполнение которых запланировано функциями JavaScript <span class="code">setTimeout</span> и <span class="code">setInterval</span>.</li>
    <li>Затем выполняются обратные вызовы ввода/вывода, поэтому если один из неблокирующих сетевых вызовов вернул какой-либо ввод/вывод, в этот момент будет инициирован ваш обратный вызов.</li>
    <li>В фазе опроса читаются новые события ввода/вывода</li>
    <li>в конце инициируются обратные вызовы, запланированные функцией <span class="code">setImmediate</span>. Это особый случай, потому что он позволяет запланировать немедленное выполнение обратных вызовов после текущих обратных вызовов ввода/вывода, уже находящихся в очереди.</li>
</ol>


<h2>Основы программирования в Node</h2>
<h3>Вывод на консоль</h3>
<p>Если вы привыкли к программированию на JavaScript для веб-браузеров, тогда одним из небольших сюрпризов, касающихся Node, будет то, что функция
    <span class="code">console.log()</span> предназначена не только для отладки. Она является простейшим способом отображения сообщения пользователю в Node или в более общем плане отправки вывода в поток stdout. Вот как выглядит классическая
    программа <span class="code">“Hello World”</span> в Node:</p>
<pre><code >console.log("Hello World!");</code></pre>

<p>В веб-браузерах <span class="code">console.log()</span>, <span class="code">console.warn()</span> и <span class="code">console.error()</span>, как правило, отображают маленькие значки рядом со своим выводом в консоли инструментов разработчика, чтобы обозначать различные журнальные
    сообщения.</p>

<h3>Аргументы командной строки и переменные среды</h3>
<p>Если вы ранее писали программы в стиле Unix, предназначенные для вызова из окна терминала или другого интерфейса командной строки, то вам известно, что такие программы обычно получают свой ввод в первую очередь из аргументов командной строки и во вторую очередь из переменных среды.</p>
<p>Среда Node следует таким соглашениям Unix. Программа Node может читать свои аргументы командной строки из массива строк <span class="code">process.argv</span>. Первый элемент этого массива всегда будет путем к исполняемому файлу Node. Второй аргумент — путь к файлу кода JavaScript, который Node выполняет. Оставшиеся элементы в массиве <span class="code">process.argv</span> являются аргументами, отделенными друг от друга пробелами, которые вы передали в командной строке, когда вызывали Node. Например, пусть вы сохранили приведенную ниже очень короткую программу Node в файле <span class="code">argv.js</span>:</p>
<pre><code>console.log(process.argv);</code></pre>
<p><b>Вывод:</b></p>
<pre><code >$ node --trace-uncaught argv.js --arg1 --arg2 filename
[
    '/usr/local/bin/node',
    '/private/tmp/argv.js',
    '--arg1',
    '--arg2',
    'filename'
]</code></pre>
<p>Здесь необходимо отметить два момента:</p>
<ul>
    <li>Первый и второй элементы <span class="code">process.argv</span> будут полными путями в файловой системе к исполняемому файлу Node и запущенному файлу кода JavaScript, даже если вы не вводили их в таком виде.</li>
    <li>Аргументы командной строки, которые предназначены для Node и интерпретируются им, потребляются самим исполняемым файлом Node и не присутствуют в <span class="code">process.argv</span>. (Аргумент командной строки <span class="code">--trace-uncaught</span> в предыдущем примере фактически не делает ничего полезного; он нужен лишь для того, чтобы продемонстрировать его отсутствие в выводе.) Любые аргументы (наподобие <span class="code">--arg1</span> и <span class="code">filename</span>) следующие после имени файла кода JavaScript, будут появляться в <span class="code">process.argv</span>.</li>
</ul>
<p>Программы Node могут также принимать ввод от переменных среды в стиле
    Unix. Среда Node делает их доступными через объект <span class="code">process.env</span>. Именами свойств этого объекта будут имена переменных среды, а значениями (всегда строковыми) свойств — значения переменных среды.</p>
<p>Вот неполный список переменных среды в некоторой системе:</p>
<pre><code >$ node -р -е 'process.env'
{
    SHELL: '/bin/bash',
    USER: 'david',
    PATH: '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin',
    PWD: '/tmp',
    LANG: 'en_US.UTF-8',
    HOME: '/Users/david',
}</code></pre>
<p>Вы можете использовать <span class="code">node -h</span> или <span class="code">node -help</span>, чтобы выяснить, для чего предназначены аргументы командной строки <span class="code">-р</span> и <span class="code">-е</span>. Однако имейте в виду, что вы могли бы переписать предыдущую строку следующим образом: <span class="code">node --eval 'process.env' --print</span>.</p>


<h2>Структурирование и повторное использование функциональности Node</h2>
<p>При создании приложения, с использованием Node или без, часто наступает момент, когда хранить весь код в одном файле становится слишком неудобно. В традиционном решении этой проблемы, представленном на <a id="#traditional-structure">рис. ниже</a>, разработчик брал файл с большим объемом кода и разбивал его на отдельные файлы.</p>
<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/XY3BYkt8/image.png' border='0' alt='image'/></a>
<p>В реализациях некоторых языков (таких как PH P и Ruby) внедрение логики из другого файла (включаемого) означает, что вся логика, выполняемая в файле, влияет на глобальную область видимости. Все создаваемые переменные и все функции, объявленные во включаемом файле, заменяют переменные и функции, созданные и объявленные приложением.</p>
<p>Предположим, вы программируете на PHP, и ваше приложение содержит следующую логику:</p>
<pre><code >function uppercase_trim($text) {
    return trim (strtoupper($text));
}
include('string_handlers.php');</code></pre>
<p>Если файл <span class="code">string_handlers.php</span> также попытается определить функцию <span class="code">uppercase_trim</span>, вы получите сообщение об ошибке:</p>
<div class="code-example-output-title"><span>Вывод:</span>
<div class="code-example-output">
<pre>
Fatal error: Cannot redeclare uppercase_trim()
</pre>
</div>
</div>
<p>В PHP эта проблема решается за счет использования пространств имен; аналогичную функциональность Ruby предлагает в виде модулей. Однако Node в принципе избегает эту потенциальную проблему, не предоставляя простых возможностей для случайного загрязнения глобального пространства имен</p>
<p>Модули Node упаковывают код для повторного использования, но при этом не изменяют глобальную область видимости.</p>
<p>Предположим, вы разрабатываете систему управления контентом (CMS) с открытым кодом на языке PHP и хотите использовать стороннюю библиотеку API, которая не использует пространства имен. Библиотека может содержать класс с таким же именем, как у вашего приложения, и этот класс нарушит работу вашего приложения, если только вы не переименуете свой класс в приложении или библиотеке. Однако изменение имени класса в приложении может создать проблемы у других разработчиков, которые пользуются вашей CMS-системой в своих проектах. После переименования класса в библиотеке вам придется помнить о необходимости повторять этот трюк каждый раз, когда вы обновляете библиотеку в дереве исходного кода вашего приложения. Конфликты имен — проблема, которую лучше избегать.</p>
<p>Имена модулей позволяют выбрать, какие функции и переменные из включенного файла будут доступны для приложения. Если модуль возвращает более одной функции или переменной, модуль может указать их заданием свойств объекта с именем <span class="code">exports</span>. Если модуль возвращает одну функцию или переменную, вместо этого можно задать свойство <span class="code">module.exports</span>. На рис. ниже показано, как работает эта схема.</p>
<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/XJw0qdRf/image.png' border='0' alt='image'/></a>
<p>Заполнение свойства module.exports или объекта exports позволяет модулю выбрать, какая информация должна быть доступна приложению</p>
<p>Избегая загрязнения глобальной области видимости, система модулей Node предотвращает конфликты имен или упрощает повторное использование кода. После этого модули могут быть опубликованы в реестре npm (менеджер пакетов), сетевой подборке готовых модулей Node, и распространяться в сообществе Node. При этом пользователям модулей не нужно беспокоиться о том, что модуль случайно заменит переменные и функции другого модуля.</p>
<h2>Создание проекта Node</h2>
<pre><code >mkdir my_module
cd my_module
npm init -y</code></pre>

<p>Таким образом, npm создаст файл <span class="code">package.json</span> со значениями по умолчанию. Если вы хотите полностью управлять процессом создания проекта, опустите флаг <span class="code">-y</span>; npm задаст ряд вопросов о лицензии проекта, имени автора и т. д. После того как все будет сделано, просмотрите содержимое файла <span class="code">package.json</span>. Вы можете отредактировать его вручную, но помните: файл должен содержать корректную разметку JSON.</p>

<h3>Создание модулей</h3>
<p>Модуль может представлять собой как отдельный файл, так и каталог с одним или несколькими файлами - <span class="code">my_module.js</span>.</p>


Если модуль оформлен в виде каталога, основному файлу в этом каталоге, который будет обрабатываться, обычно присваивается имя <span class="code">index.js</span>, а путь к этому файлу будет иметь вид <span class="code">my_module/index.js</span>.
<p>Чтобы создать типичный модуль, создайте файл, определяющий свойства объекта <span class="code">exports</span> с любыми данными (строками, объектами, функциями и т. д.).</p>
<p>Чтобы продемонстрировать, как создаются базовые модули, мы добавим простейшую функциональность перерасчета валют в файл <span class="code">currency.js</span>. Этот файл, представленный в следующем листинге, содержит две функции для пересчета канадских долларов в американские, и наоборот.
</p>
<pre><code >const canadianDollar = 0.91;
function roundTwo(amount) {
    return Math.round(amount * 100) / 100;
}
exports.canadianToUS = canadian => roundTwo(canadian * canadianDollar);
//Функция canadianToUS определяется в exports,
//чтобы она могла использоваться
//в коде, требующем этот модуль.
exports.USToCanadian = us => roundTwo(us / canadianDollar);</code></pre>
<p>Обратите внимание: задаются только два свойства объекта <span class="code">exports</span>. Таким образом, для приложения, включающего модуль, будут доступны только две функции: <span class="code">canadianToUS</span> и <span class="code">USToCanadian</span>. Переменная <span class="code">canadianDollar</span> закрыта от внешнего доступа: она влияет на логику работы <span class="code">canadianToUS</span> и <span class="code">USToCanadian</span>, но приложение не сможет обратиться к ней напрямую.</p>
<p>Чтобы использовать новый модуль в программе, воспользуйтесь функцией Node <span class="code">require</span> и передайте путь к нужному модулю в аргументе. Node выполняет синхронный поиск модуля и загружает его содержимое. Сначала Node ищет файлы среди базовых модулей, затем в текущем каталоге, и наконец, в каталоге <span class="code">node_modules</span>.</p>
<p>Require — одна из немногих синхронных операций ввода/вывода в Node.
    Так как модули часто используются и обычно включаются в начале файла,
    синхронность require помогает сохранить чистоту, упорядоченность и удобочитаемость кода.
</p>
<p>Старайтесь избегать использования require в частях вашего приложения, выполняющих интенсивный ввод/вывод. Любой синхронный вызов блокирует
    работу, не позволяя Node делать что-либо до завершения вызова. Например,
    если вы запустили H T T P-сервер, выполнение require для каждого входного
    запроса снизит быстродействие приложения. Как правило, именно по этой
    причине require и другие синхронные операции используются только при
    начальной загрузке приложения.</p>
<pre><code >const currency = require('./currency');
//./ в пути означает, что модуль находится
// в 1 каталоге со скриптом приложения
console.log('50 Canadian dollars equals this amount of US dollars:');
console.log(currency.canadianToUS(50));
console.log('30 US dollars equals this amount of Canadian dollars:');
console.log(currency.USToCanadian(30));</code></pre>
<p>Включение модуля с путем, начинающимся с <span class="code">./</span>, означает, что если вы создаете
    свой сценарий приложения с именем <span class="code">test-currency.js</span> в каталоге <span class="code">currency_app</span>, то файл
    модуля <span class="code">currency.js</span> (рис. 2.4) также должен существовать в каталоге currency_app. При
    необходимости расширение <span class="code">.js</span> подставляется по умолчанию, так что при желании
    его можно опустить. Если расширение <span class="code">.js</span> не указано, Node также проверит файл
    <span class="code">.json</span> с заданным именем. Файлы <span class="code">JSON</span> загружаются как объекты JavaScript. Если аргумент require начинается с ./, Node проверяет тот каталог,
    в котором находится выполняемый файл</p>
<p>После того как Node найдет и обработает ваш модуль, функция require возвращает
    содержимое объекта exports, определенного в модуле. После этого вы сможете
    использовать две функции, возвращаемые модулем, для пересчета сумм в другую
    валюту.</p>
<p>Если вы захотите определить структуру модулей, разместите модули в подкаталогах.
    Если, например, вы хотите хранить модуль currency в папке lib/, приведите строку
    require к следующему виду:</p>
<pre><code >const currency = require('./lib/currency');</code></pre>
<h3>Настройка создания модуля с использованием <span class="code">module.exports</span></h3>
<p>Хотя заполнение объекта exports функциями и переменными хорошо подходит для
    большинства случаев, время от времени требуется создать модуль с отклонением
    от этой модели.</p>
<p>Например, модуль пересчета валют из предыдущего раздела можно переписать
    таким образом, чтобы он возвращал одну функцию-конструктор Currency вместо
    объекта, содержащего функции. Объектно-ориентированная реализация может
    выглядеть примерно так:
</p>
<pre><code >const Currency = require('./currency');
const canadianDollar = 0.91;
const currency = new Currency(canadianDollar);
console.log(currency.canadianToUS(50));</code></pre>
<p>Возвращение функции из require (вместо объекта) сделает ваш код более элегантным — если это единственное, что требуется от модуля.</p>
<p>Казалось бы, чтобы создать модуль, возвращающий одну переменную или функцию, нужно присвоить exports то, что вы хотите вернуть. Однако такое решение
    не сработает, потому что Node не ожидает, что exports будет присваиваться любой
    другой объект, функция или переменная. Код модуля в следующем листинге пытается присвоить exports функцию (листинг 2.3).</p>
<p>Модуль ниже не будет работать:</p>
<pre><code >class Currency {
constructor(canadianDollar) {
this.canadianDollar = canadianDollar;
}
roundTwoDecimals(amount) {
return Math.round(amount * 100) / 100;
}
canadianToUS(canadian) {
return this.roundTwoDecimals(canadian * this.canadianDollar)
}
USToCanadian(us) {
return this.roundTwoDecimals(us / this.canadianDollar);
}
}
exports = Currency;
//Ошибка; Node не позволяет переписывать exports.
</code></pre>
<p>Чтобы приведенный код модуля работал так, как ожидается, нужно заменить exports
    на module .exports. Механизм module .exports позволяет экспортировать одну переменную, функцию или объект. Если вы создаете модуль, который заполняет как exports,
    так и module.exports, то возвращается module.exports, а exports игнорируется.</p>
<p>ЧТО В ДЕЙСТВИТЕЛЬНОСТИ ЭКСПОРТИРУЕТСЯ/]. В конечном итоге в вашем приложении экспортируется module.exports.
    exports задается как глобальная ссылка на module.exports — изначально это
    пустой объект, к которому можно добавлять свойства. exports.myFunc — сокращенная запись для module.exports.myFunc.
    В результате присваивание exports другой ссылки разрывает связь между
    module.exports и exports. Так как экспортируется module.exports, exports работает не так, как ожидается, — он уже не ссылается на module.exports. Чтобы
    сохранить эту связь, снова включите в module.exports ссылку на exports:
    module.exports = exports = Currency;
    Использовав exports или module.exports в зависимости от ваших потребностей, вы сможете распределить функциональность по модулям и избежать
    проблем с постоянно растущими сценариями приложения.
</p>
<h3>Повторное использование модулей
    с папкой node_modules</h3>
<p>Включение модулей с указанием их местонахождения в файловой системе относительно приложения полезно для организации кода, специфического для
    данного приложения. Иначе дело обстоит с кодом, предназначенным для использования в нескольких приложениях или распространения среди других
    разработчиков. Node имеет уникальный механизм повторного использования
    кода, который позволяет включать модули без точной информации об их м естонахождении в файловой системе. Этот механизм основан на использовании
    каталогов node_modules.
</p>
<p>В приведенном ранее примере включался модуль ./c u rre n c y . Если убрать . /
    и включить просто currency, Node начинает искать этот модуль по схеме, представленной на рис. 2.5.</p>
<p>Переменная окружения NODE_PATH позволяет выбрать альтернативные каталоги для
    хранения модулей Node. Если переменная NODE_PATH используется, ей должен быть
    присвоен список каталогов, разделенных символом точки с запятой (;) в Windows
    или двоеточием (:) в других операционных системах.
</p>
<h3>Потенциальные проблемы</h3>
<p>Хотя система модулей Node устроена достаточно прямолинейно, вы должны учитывать два обстоятельства.</p>
<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/rw0x9gCc/image.png' border='0' alt='image'/></a>
<p>Во-первых, если модуль представляет собой каталог, файл в каталоге модуля,
    который будет обработан, должен называться index.js, если только обратное не
    указано в файле package.json в каталоге модуля. Чтобы задать другой файл вместо index.js, файл package.json должен содержать данные JSO N (JavaScript Object
    Notation), определяющие объект с ключом main и значением, которое определяет
    путь к основному файлу в каталоге модуля. Эти правила обобщены в блок-схеме
    на рис. 2.6.</p>
<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/rFzr8gHW/image.png' border='0' alt='image'/></a>

<p>Пример файла package.json, который назначает основным файлом currency.js:
</p>
<pre><code >{
"main": "currency.js"
}</code></pre>

<p>Другое обстоятельство, о котором следует помнить, — это способность Node кэшировать модули как объекты. Если два файла в приложении включают один и тот же модуль, то данные, возвращенные для первого вызова require, будут сохранены в памяти,
    поэтому второму вызову require не нужно будет проверять исходные файлы модуля.
    А это означает, что загрузка модуля с вызовом require в том же процессе вернет тот
    же объект. Представьте, что вы создаете веб-приложение MVC, у которого имеется основной объект приложения. Вы можете настроить этот объект, экспортировать его,
    а затем включить в любой точке проекта вызовом require. Если в объект приложения
    были добавлены полезные данные конфигурации, вы сможете обратиться к ним из
    других файлов — при условии, что проект имеет следующую структуру каталогов:
</p>
<pre><code >проект
    app.j s
    models
        post.js</code></pre>

<p>Лучший способ освоиться с системой модулей Node — поэкспериментировать с ней
    и самостоятельно проверить поведение, описанное в этом разделе. Теперь, когда вы
    в общих чертах понимаете, как работают модули, можно переходить к средствам
    асинхронного программирования.</p>
<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/bdXpfzMm/image.png' border='0' alt='image'/></a>
<p></p>


