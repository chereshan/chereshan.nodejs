<!--<title>Глава 999. Не сортировано</title>-->
<h1>Глава 999. Не сортировано</h1>
<h2>Неблокирующий ввод/вывод</h2>
<p>Что это означает в контексте программирования <i>"на стороне сервера"</i>? Запросы ввода/вывода (например, обращения к диску или сетевым ресурсам) выполняются относительно медленно, поэтому исполнительная среда не должна блокировать выполнение бизнес-логики во время чтения файлов или передачи сообщений по сети. </p>
<p>Для этого в Node используются три концепции:
<b>события</b>, <b>асинхронные API</b>, <b>неблокирующий ввод/вывод</b>.</p>
<p><b>Неблокирующий ввод/вывод</b> — низкоуровневый термин с точки зрения программиста Node. Он означает, что программа может обратиться с запросом к сетевому ресурсу и заняться чем-то другим. А потом, когда сетевая операция будет завершена, выполняется функция обратного вызова, которая обработает результат.</p>
<p>На <a href="#async_nonblocking_components">рис. ниже</a> изображено типичное веб-приложение Node, использующее библиотеку веб-программирования Express для обработки заказов в магазине. В нем:</p>
<ol>
    <li>Браузер выдает запрос на приобретение продукта;</li>
    <li>приложение проверяет текущее состояние складских запасов</li>
    <li>создает учетную запись для пользователя</li>
    <li>отправляет квитанцию по электронной почте</li>
    <li>возвращает HTTP-ответ в формате JSON</li>
    <b>Одновременно с этим:</b>
    <li>квитанция отправляется по электронной почте</li>
    <li>база данных обновляется информацией от пользователя и данными заказа</li>
</ol>
<p>По сути, перед нами прямолинейный императивный код JavaScript, но исполнительная среда работает параллельно, потому что она использует неблокирующий ввод/вывод.</p>
<a id="async_nonblocking_components" href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/qMCJhnpt/image.png' border='0' alt='image'/></a>
<p>На <a href="#async_nonblocking_components">рис. выше</a> приложение обращается к базе данных по сети. В Node сетевые операции выполняются без блокировки, потому что Node при помощи библиотеки <span class="code">libuv</span> использует неблокирующие сетевые вызовы операционной системы. Эта функциональность по-разному реализована для Linux, macOS и Windows, но вам придется иметь дело только с удобной библиотекой JavaScript для работы с базами данных. Хотя вы пишете команды типа <span class="code">db.insert(query, err => {})</span>, Node во внутренней реализации выполняет оптимизированные неблокирующие сетевые операции.</p>
<p>Обращения к диску происходят примерно так же, но, как ни странно, полного совпадения нет. Когда приложение генерирует квитанцию, отправляемую по электронной почте, и шаблон сообщения читается с диска, <span class="code">libuv</span> использует пул потоков для создания иллюзии использования неблокирующего вызова. Управление пулом потоков — довольно тяжелое дело, но понять команду <span class="code">email.send('template.ejs', (err, html) => {})</span> определенно намного проще.</p>
<p>Истинное преимущество использования асинхронных API с неблокирующими операциями ввода/вывода заключается в том, что Node может заниматься другими делами во время выполнения относительно медленных процессов. И хотя выполняться может только однопоточное и однопроцессное веб-приложение Node, в любой момент времени оно может обрабатывать сразу несколько подключений от тысяч потенциальных посетителей сайта. Чтобы понять, как это происходит, необходимо познакомиться с циклом событий.</p>
<h2>Цикл событий</h2>
<p>Cосредоточимся на одном конкретном аспекте: <b>обработке запросов браузера</b>. <a href="#async_nonblocking_components">В примере выше</a> базовый модуль с именем <span class="code">http.Server</span> обрабатывает запрос с использованием потоков, событий и парсера HTTP-запросов Node, который содержит платформенный код. При этом инициируется выполнение функции обратного вызова в вашем приложении, которая была добавлена средствами библиотеки веб-приложений Express. Выполняемая функция обратного вызова выдает запрос к базе данных, и в конечном итоге приложение отвечает данными JSON с использованием HTTP. Весь процесс использует как минимум три неблокируемых сетевых вызова: один для запроса, один для базы данных и один для ответа. Как Node планирует все эти неблокирующие сетевые операции? Ответ: при помощи <b>цикла событий</b>. На <a href="#event-cycle">рис. ниже</a> показано, как цикл событий используется для этих трех сетевых операций</p>
<a id="event-cycle" href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/02YZZWf7/image.png' border='0' alt='image'/></a>
<p>Цикл событий работает в одном направлении (он реализуется очередью <span data-tippy-content='"first-in-first-out"="первым пришел, первым вышел"'>FIFO</span> и проходит через несколько фаз. На <a href="#event-cycle">рис. выше</a> показана упрощенная последовательность важнейших фаз, выполняемых при каждой итерации цикла:</p>
<ol>
    <li>Сначала выполняются таймеры, выполнение которых запланировано функциями JavaScript <span class="code">setTimeout</span> и <span class="code">setInterval</span>.</li>
    <li>Затем выполняются обратные вызовы ввода/вывода, поэтому если один из неблокирующих сетевых вызовов вернул какой-либо ввод/вывод, в этот момент будет инициирован ваш обратный вызов.</li>
    <li>В фазе опроса читаются новые события ввода/вывода</li>
    <li>в конце инициируются обратные вызовы, запланированные функцией <span class="code">setImmediate</span>. Это особый случай, потому что он позволяет запланировать немедленное выполнение обратных вызовов после текущих обратных вызовов ввода/вывода, уже находящихся в очереди.</li>
</ol>


<h2>Основы программирования в Node</h2>
<h3>Вывод на консоль</h3>
<p>Если вы привыкли к программированию на JavaScript для веб-браузеров, тогда одним из небольших сюрпризов, касающихся Node, будет то, что функция
    <span class="code">console.log()</span> предназначена не только для отладки. Она является простейшим способом отображения сообщения пользователю в Node или в более общем плане отправки вывода в поток stdout. Вот как выглядит классическая
    программа <span class="code">“Hello World”</span> в Node:</p>
<pre><code >console.log("Hello World!");</code></pre>

<p>В веб-браузерах <span class="code">console.log()</span>, <span class="code">console.warn()</span> и <span class="code">console.error()</span>, как правило, отображают маленькие значки рядом со своим выводом в консоли инструментов разработчика, чтобы обозначать различные журнальные
    сообщения.</p>

<h3>Аргументы командной строки и переменные среды</h3>
<p>Если вы ранее писали программы в стиле Unix, предназначенные для вызова из окна терминала или другого интерфейса командной строки, то вам известно, что такие программы обычно получают свой ввод в первую очередь из аргументов командной строки и во вторую очередь из переменных среды.</p>
<p>Среда Node следует таким соглашениям Unix. Программа Node может читать свои аргументы командной строки из массива строк <span class="code">process.argv</span>. Первый элемент этого массива всегда будет путем к исполняемому файлу Node. Второй аргумент — путь к файлу кода JavaScript, который Node выполняет. Оставшиеся элементы в массиве <span class="code">process.argv</span> являются аргументами, отделенными друг от друга пробелами, которые вы передали в командной строке, когда вызывали Node. Например, пусть вы сохранили приведенную ниже очень короткую программу Node в файле <span class="code">argv.js</span>:</p>
<pre><code>console.log(process.argv);</code></pre>
<p><b>Вывод:</b></p>
<pre><code >$ node --trace-uncaught argv.js --arg1 --arg2 filename
[
    '/usr/local/bin/node',
    '/private/tmp/argv.js',
    '--arg1',
    '--arg2',
    'filename'
]</code></pre>
<p>Здесь необходимо отметить два момента:</p>
<ul>
    <li>Первый и второй элементы <span class="code">process.argv</span> будут полными путями в файловой системе к исполняемому файлу Node и запущенному файлу кода JavaScript, даже если вы не вводили их в таком виде.</li>
    <li>Аргументы командной строки, которые предназначены для Node и интерпретируются им, потребляются самим исполняемым файлом Node и не присутствуют в <span class="code">process.argv</span>. (Аргумент командной строки <span class="code">--trace-uncaught</span> в предыдущем примере фактически не делает ничего полезного; он нужен лишь для того, чтобы продемонстрировать его отсутствие в выводе.) Любые аргументы (наподобие <span class="code">--arg1</span> и <span class="code">filename</span>) следующие после имени файла кода JavaScript, будут появляться в <span class="code">process.argv</span>.</li>
</ul>
<p>Программы Node могут также принимать ввод от переменных среды в стиле
    Unix. Среда Node делает их доступными через объект <span class="code">process.env</span>. Именами свойств этого объекта будут имена переменных среды, а значениями (всегда строковыми) свойств — значения переменных среды.</p>
<p>Вот неполный список переменных среды в некоторой системе:</p>
<pre><code >$ node -р -е 'process.env'
{
    SHELL: '/bin/bash',
    USER: 'david',
    PATH: '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin',
    PWD: '/tmp',
    LANG: 'en_US.UTF-8',
    HOME: '/Users/david',
}</code></pre>
<p>Вы можете использовать <span class="code">node -h</span> или <span class="code">node -help</span>, чтобы выяснить, для чего предназначены аргументы командной строки <span class="code">-р</span> и <span class="code">-е</span>. Однако имейте в виду, что вы могли бы переписать предыдущую строку следующим образом: <span class="code">node --eval 'process.env' --print</span>.</p>


<h2>Структурирование и повторное использование функциональности Node</h2>
<p>При создании приложения, с использованием Node или без, часто наступает момент, когда хранить весь код в одном файле становится слишком неудобно. В традиционном решении этой проблемы, представленном на <a id="#traditional-structure">рис. ниже</a>, разработчик брал файл с большим объемом кода и разбивал его на отдельные файлы.</p>
<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/XY3BYkt8/image.png' border='0' alt='image'/></a>
<p>В реализациях некоторых языков (таких как PH P и Ruby) внедрение логики из другого файла (включаемого) означает, что вся логика, выполняемая в файле, влияет на глобальную область видимости. Все создаваемые переменные и все функции, объявленные во включаемом файле, заменяют переменные и функции, созданные и объявленные приложением.</p>
<p>Предположим, вы программируете на PHP, и ваше приложение содержит следующую логику:</p>
<pre><code >function uppercase_trim($text) {
    return trim (strtoupper($text));
}
include('string_handlers.php');</code></pre>
<p>Если файл <span class="code">string_handlers.php</span> также попытается определить функцию <span class="code">uppercase_trim</span>, вы получите сообщение об ошибке:</p>
<div class="code-example-output-title"><span>Вывод:</span>
<div class="code-example-output">
<pre>
Fatal error: Cannot redeclare uppercase_trim()
</pre>
</div>
</div>
<p>В PHP эта проблема решается за счет использования пространств имен; аналогичную функциональность Ruby предлагает в виде модулей. Однако Node в принципе избегает эту потенциальную проблему, не предоставляя простых возможностей для случайного загрязнения глобального пространства имен</p>
<p>Модули Node упаковывают код для повторного использования, но при этом не изменяют глобальную область видимости.</p>
<p>Предположим, вы разрабатываете систему управления контентом (CMS) с открытым кодом на языке PHP и хотите использовать стороннюю библиотеку API, которая не использует пространства имен. Библиотека может содержать класс с таким же именем, как у вашего приложения, и этот класс нарушит работу вашего приложения, если только вы не переименуете свой класс в приложении или библиотеке. Однако изменение имени класса в приложении может создать проблемы у других разработчиков, которые пользуются вашей CMS-системой в своих проектах. После переименования класса в библиотеке вам придется помнить о необходимости повторять этот трюк каждый раз, когда вы обновляете библиотеку в дереве исходного кода вашего приложения. Конфликты имен — проблема, которую лучше избегать.</p>
<p>Имена модулей позволяют выбрать, какие функции и переменные из включенного файла будут доступны для приложения. Если модуль возвращает более одной функции или переменной, модуль может указать их заданием свойств объекта с именем <span class="code">exports</span>. Если модуль возвращает одну функцию или переменную, вместо этого можно задать свойство <span class="code">module.exports</span>. На рис. ниже показано, как работает эта схема.</p>
<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/XJw0qdRf/image.png' border='0' alt='image'/></a>
<p>Заполнение свойства module.exports или объекта exports позволяет модулю выбрать, какая информация должна быть доступна приложению</p>
<p>Избегая загрязнения глобальной области видимости, система модулей Node предотвращает конфликты имен или упрощает повторное использование кода. После этого модули могут быть опубликованы в реестре npm (менеджер пакетов), сетевой подборке готовых модулей Node, и распространяться в сообществе Node. При этом пользователям модулей не нужно беспокоиться о том, что модуль случайно заменит переменные и функции другого модуля.</p>
<h2>Создание проекта Node</h2>
<pre><code >mkdir my_module
cd my_module
npm init -y</code></pre>

<p>Таким образом, npm создаст файл <span class="code">package.json</span> со значениями по умолчанию. Если вы хотите полностью управлять процессом создания проекта, опустите флаг <span class="code">-y</span>; npm задаст ряд вопросов о лицензии проекта, имени автора и т. д. После того как все будет сделано, просмотрите содержимое файла <span class="code">package.json</span>. Вы можете отредактировать его вручную, но помните: файл должен содержать корректную разметку JSON.</p>

<h3>Создание модулей</h3>
<p>Модуль может представлять собой как отдельный файл, так и каталог с одним или несколькими файлами - <span class="code">my_module.js</span>.</p>


Если модуль оформлен в виде каталога, основному файлу в этом каталоге, который будет обрабатываться, обычно присваивается имя <span class="code">index.js</span>, а путь к этому файлу будет иметь вид <span class="code">my_module/index.js</span>.
<p>Чтобы создать типичный модуль, создайте файл, определяющий свойства объекта <span class="code">exports</span> с любыми данными (строками, объектами, функциями и т. д.).</p>
<p>Чтобы продемонстрировать, как создаются базовые модули, мы добавим простейшую функциональность перерасчета валют в файл <span class="code">currency.js</span>. Этот файл, представленный в следующем листинге, содержит две функции для пересчета канадских долларов в американские, и наоборот.
</p>
<pre><code >const canadianDollar = 0.91;
function roundTwo(amount) {
    return Math.round(amount * 100) / 100;
}
exports.canadianToUS = canadian => roundTwo(canadian * canadianDollar);
//Функция canadianToUS определяется в exports,
//чтобы она могла использоваться
//в коде, требующем этот модуль.
exports.USToCanadian = us => roundTwo(us / canadianDollar);</code></pre>
<p>Обратите внимание: задаются только два свойства объекта <span class="code">exports</span>. Таким образом, для приложения, включающего модуль, будут доступны только две функции: <span class="code">canadianToUS</span> и <span class="code">USToCanadian</span>. Переменная <span class="code">canadianDollar</span> закрыта от внешнего доступа: она влияет на логику работы <span class="code">canadianToUS</span> и <span class="code">USToCanadian</span>, но приложение не сможет обратиться к ней напрямую.</p>
<p>Чтобы использовать новый модуль в программе, воспользуйтесь функцией Node <span class="code">require</span> и передайте путь к нужному модулю в аргументе. Node выполняет синхронный поиск модуля и загружает его содержимое. Сначала Node ищет файлы среди базовых модулей, затем в текущем каталоге, и наконец, в каталоге <span class="code">node_modules</span>.</p>
<p>Require — одна из немногих синхронных операций ввода/вывода в Node.
    Так как модули часто используются и обычно включаются в начале файла,
    синхронность require помогает сохранить чистоту, упорядоченность и удобочитаемость кода.
</p>
<p>Старайтесь избегать использования require в частях вашего приложения, выполняющих интенсивный ввод/вывод. Любой синхронный вызов блокирует
    работу, не позволяя Node делать что-либо до завершения вызова. Например,
    если вы запустили H T T P-сервер, выполнение require для каждого входного
    запроса снизит быстродействие приложения. Как правило, именно по этой
    причине require и другие синхронные операции используются только при
    начальной загрузке приложения.</p>
<pre><code >const currency = require('./currency');
console.log('50 Canadian dollars equals this amount of US dollars:');
console.log(currency.canadianToUS(50));
console.log('30 US dollars equals this amount of Canadian dollars:');
console.log(currency.USToCanadian(30));</code></pre>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>






