<!--<title>Глава 2. Структурные элементы NodeJS</title>-->


<body>
<script src="../common/counters_body.js"></script>

<h1>Глава 2. Структурные элементы NodeJS</h1>
<p>Объект <span class="code">buffer</span> принадлежит к числу глобальных объектов Node. Другой пример глобального объекта — сам объект <span class="code">global</span>, хотя в Node он принципиально отличается от глобального объекта, к которому мы привыкли по браузеру.
Разработчикам Node также доступен другой глобальный объект, <span class="code">process</span>, — он связывает приложение Node со средой, в которой оно выполняется.</p>
<p>К счастью, один из аспектов Node — асинхронная природа, управляемая событиями, — должен быть хорошо знаком разработчикам интерфейсных приложений. Просто приложение Node ожидает открытия файла, а не нажатия кнопки
пользователем.</p>
<h2>Объекты <span class="code">global</span> и <span class="code">process</span></h2>
<p>Два важнейших объекта в Node — <span class="code">global</span> и process. Объект <span class="code">global</span> немного
похож на глобальный объект в браузере, хотя между ними существуют очень
серьезные различия. Объект process, напротив, существует только в Node.</p>
<h3>Объект <span class="code">global</span></h3>
<p>В браузере переменная, объявленная на верхнем уровне, объявляется глобально. В Node дело обстоит иначе. Переменная, объявленная в модуле или приложении Node, не обладает глобальной доступностью; она ограничивается модулем или приложением. Таким образом, можно объявить «глобальную» переменную с именем <span class="code">str</span> в модуле и в приложении, использующем этот модуль, и никакого конфликта не будет.</p>
<p>Для демонстрации создадим простую функцию, которая прибавляет число
к базовому значению и возвращает результат. Функция будет создана как
библиотека JavaScript для использования в веб-странице, а также как модуль
для использования в приложении Node.</p>
<p>Код библиотеки JavaScript из файла <span class="code">add2.js</span> объявляет переменную base, присваивает ей значение 2, после чего прибавляет переданное число:</p>
<pre><code >//add2.js
var base = 2;
function addtwo(input) {
return parseInt(input) + base;
}</code></pre>
Затем создадим очень простой модуль, который делает то же самое, но с использованием синтаксиса модуля Node.
<pre><code >//addtwo.js:
var base = 2;
exports.addtwo = function(input) {
return parseInt(input) + base;
};</code></pre>
<p>А теперь посмотрим, чем различается концепция глобальности в двух разных
средах. Библиотека <span class="code">add2.js</span> используется в веб-странице, которая также объявляет переменную <span class="code">base</span>:</p>
<pre><code >&lt;!DOCTYPE html>
&lt;html>
&lt;head>
    &lt;script src="add2.js">&lt;/script>
    &lt;script>
        var base = 10;
        console.log(addtwo(10));
    &lt;/script>
&lt;/head>
&lt;body>
&lt;/body>
&lt;/html></code></pre>
При обращении к веб-странице в браузере на консоли браузера выводится
значение 20 (вместо ожидаемого 12). Дело в том, что все переменные, объявленные за пределами функции в JavaScript, добавляются в один глобальный
объект. Объявляя новую переменную с именем base в веб-странице, мы переопределяем значение во включенном файле сценария.
Теперь используем модуль addtwo в приложении Node:
<pre><code >
//addtwo.js
var path = require('path');
var addtwo = require( path.resolve( __dirname, "./addtwo.js" )).addtwo;
var base = 10;
console.log(addtwo(base));</code></pre>
<p>В приложении Node результат равен 12. Объявление новой переменной base
в приложении Node никак не повлияло на значение base в модуле, потому что
они существуют в разных глобальных пространствах имен.</p>
<p>Устранение общего пространства имен — безусловное усовершенствование,
но оно не универсально. Объект <span class="code">global</span> во всех средах предоставляет доступ
к глобально доступным объектам и функциям Node, включая объект <span class="code">process</span>. Чтобы убедиться в этом, просто добавьте следующую команду
в файл и запустите приложение. Команда выводит все глобально доступные
объекты и функции:</p>
<pre><code >console.log(global);</code></pre>

<h2>Объект <span class="code">process</span></h2>
<p>Объект process принадлежит к числу важнейших компонентов среды Node,
так как он предоставляет информацию о среде выполнения. Кроме того, через
объект <span class="code">process</span> выполняется стандартный ввод/вывод, вы можете корректно авершить приложение Node и даже выдать сигнал при завершении итерации в цикле событий Node</p>
Мы рассмотрим получение информации о среде выполнения объекта process, а также
исключительно важные средства стандартного ввода/вывода.
Объект process предоставляет доступ к информации как о среде Node, так
и о среде выполнения программы. Для получения информации мы воспользуемся параметром командной строки <span class="code">-p</span>, который выполняет сценарий и возвращает полученный результат. Например, для проверки свойства process.
versions введите следующую команду:
<pre><code >$ node -p "process.versions"
{ http_parser: '2.5.0',
node: '4.2.1',
v8: '4.5.103.35',
uv: '1.7.5',
zlib: '1.2.8',
ares: '1.10.1-DEV',
icu: '56.1',
modules: '46',
openssl: '1.0.2d' }</code></pre>
<p>Команда выводит список различных компонентов Node и зависимостей, включая версии v8, OpenSSL (библиотека, используемая для безопасной передачи
данных), собственно Node и т. д.</p>
<p>Свойство process.env предоставляет богатую информацию о том, что Node
знает о вашей среде разработки:</p>
<pre><code >$ node -p "process.env"</code></pre>
Чтобы просмотреть содержимое process.release, введите следующую команду:
<pre><code >$ node -p "process.release"</code></pre>
<p>Информация о среде позволяет разработчику понять, что видит Node до и после разработки. Не включайте зависимости от этих данных прямо в приложение, потому что, как вы уже видели, они могут различаться между версиями
Node. Тем не менее не жалейте времени на анализ этих данных.</p>

<p>Стандартные потоки представляют собой заранее определенные каналы передачи данных между приложением и средой: <b>стандартный ввод</b> (<span class="code">stdin</span>), <b>стандартный вывод</b> (<span class="code">stdout</span>) и <b>стандартный поток ошибок</b> (<span class="code">stderr</span>). В приложении
Node эти каналы обеспечивают взаимодействие между приложением Node
и терминалом, своего рода механизм прямого «общения» с приложением.</p>
<p>Node поддерживает каналы с тремя функциями <span class="code">process</span>:</p>
<ul>
    <li><span class="code">process.stdin</span>: поток с поддержкой чтения для <span class="code">stdin</span>;</li>
    <li><span class="code">process.stdout</span>: поток с поддержкой записи для <span class="code">stdout</span>;</li>
    <li><span class="code">process.stderr</span>: поток с поддержкой записи для <span class="code">stderr</span>.</li>
</ul>
<p>Вы не можете закрывать эти потоки в своем приложении. Поддерживается
только чтение данных из канала <span class="code">stdin</span> и запись в каналы <span class="code">stdout</span> и <span class="code">stderr</span>.</p>
<p>Функции ввода/вывода process наследуют от <span class="code">EventEmitter</span>; это означает, что они могут генерировать события, а вы можете
перехватывать эти события и обрабатывать любые данные. Чтобы обработать
входные данные с использованием <span class="code">process.stdin</span>, прежде всего необходимо назначить кодировку потока. Если этого не сделать, вы получите результаты
в виде буфера, а не в виде строки:</p>
<pre><code >process.stdin.setEncoding('utf8');</code></pre>
Затем начинается прослушивание события <span class="code">readable</span>, которое сообщает о поступлении блока данных, готового к чтению. Затем функция <span class="code">process.stdin.read()</span> используется для чтения данных, и если данные отличны от <span class="code">null</span>, они
копируются в <span class="code">process.stdout</span> при помощи функции <span class="code">process.stdout.write()</span>:
<pre><code >process.stdin.on('readable', function() {
var input = process.stdin.read();
if (input !== null) {
// Эхо-вывод текста
process.stdout.write(input);
}
});</code></pre>
<p>В принципе можно пропустить назначение кодировки и получить те же результаты; программа будет читать буфер и выводить буфер, но для пользователя приложения все выглядит так, словно вы работаете с текстом (строка). На
самом деле это не так. Следующая функция <span class="code">process</span>, которую мы рассмотрим,
демонстрирует эти различия.</p>
В главе 1 был создан очень простой веб-сервер, который прослушивал запрос и выводил сообщение. Чтобы завершить программу, вам придется либо
уничтожить процесс с использованием сигнала, либо нажать клавиши Ctrl+C.
Также возможен другой вариант: завершить приложение из кода самого приложения при помощи process.exit(). Вы даже можете передать информацию
о том, успешно ли завершилось приложение или произошла ошибка.
Мы изменим тестовое приложение ввода/вывода так, чтобы оно «прослушивало» строку выхода и при ее обнаружении программа завершалась. Полный
код приложения представлен
<pre><code >process.stdin.setEncoding('utf8');
process.stdin.on('readable', function() {
    var input = process.stdin.read();
    if (input !== null) {
        /*Эхо-вывод текста*/
        process.stdout.write(input);
        var command = input.trim();
        if (command == 'exit')
            process.exit(0);
    }
});</code></pre>
Если запустить это приложение, любая введенная строка будет немедленно повторяться в выводе. А если ввести команду exit, то приложение завершается,
не требуя нажатия Ctrl+C.
Если убрать вызов функции process.stdin.setEncoding() в начале кода, произойдет ошибка. Дело в том, что буферы не поддерживают функцию trim().
Можно преобразовать буфер в строку, а затем выполнить trim:
Запись в объект process.stderr выполняется при возникновении ошибки. Почему именно этот объект, а не process.stdout? По той же причине, по которой
был создан канал stderr: чтобы отделить ожидаемый вывод от возникающих
проблем. В некоторых системах вывод stderr даже может обрабатываться отдельно от stdout (например, сообщения stdout сохраняются в журнале, а вывод
stderr выводится на консоль).

<h2>Буферы, типизованные массивы и строки</h2>
В браузерном языке JavaScript на первых порах необходимость в обработке
двоичных данных (потока октетов) вообще не возникала. Изначально язык
JavaScript предназначался для работы со строковыми значениями, выводимыми в окнах уведомлений или на формах. Даже когда появление Ajax изменило
правила игры, данные между клиентом и сервером передавались в строковой
форме (Юникод).
Однако ситуация изменилась с усложнением потребностей разработчиков.
Сейчас наряду с Ajax приходится иметь дело и с WebSocket. Кроме того,
возможности того, что можно делать в браузере, тоже расширились: кроме
простой работы с формами появились такие новые технологии, как WebGL
и Canvas.
В JavaScript и в браузере проблема решается при помощи объекта <span class="code">ArrayBuffer</span>,
для работы с которым используются типизованные массивы. В Node для этой
цели используется объект <span class="code">Buffer</span>
Буферы Node в настоящее время базируются на Uint8Array — одном из типизованных массивов, представляющих собой массив 8-разрядных
целых чисел без знака. Впрочем, это не означает, что один может использоваться вместо другого. В Node класс Buffer является основной структурой данных,
используемой в большинстве операций ввода/вывода, и попытка заменить его
типизованным массивом приведет к сбою приложения. Кроме того, преобразование буфера Node в типизованный массив возможно, но оно не обходится без
проблем. Согласно документации Buffer API, при «преобразовании» буфера
в типизованный массив:
<ul>
    <li>Память буфера копируется, а не открывается для общего доступа.</li>
    <li>Память буфера интерпретируется как массив, а не как массив байтов.
        Другими словами, конструкция new Uint32Array(new Buffer([1,2,3,4]))
        создает массив Uint32Array с четырьмя элементами [1,2,3,4], а не
        Uint32Array с одним элементом [0x1020304] или [0x4030201].
    </li>
</ul>
Таким образом, вы можете использовать в Node оба способа обработки потока
октетов, но чаще всего будете использовать буфер. Итак, что же собой представляет буфер Node?
Октет — единица измерения в информатике. Его длина
равна 8 битам, отсюда и название «октет». В системах с 8-разрядными
байтами октет и байт эквивалентны. Поток — всего лишь последовательность данных. Таким образом, двоичный файл представляет собой
обычную последовательность октетов.
Буфер Node содержит низкоуровневые двоичные данные, которые были созданы за пределами кучи (heap) V8. Для управления буфером используется
класс Buffer. После того как память будет выделена, изменить размер буфера
не удастся.
Буфер по умолчанию используется для работы с файлами: если только при
чтении и записи в файл не была назначена конкретная кодировка, данные читаются или записываются в буфер. В Node v4 для непосредственного создания
буфера используется ключевое слово <span class="code">new</span>:
<pre><code >let buf = new Buffer(24);</code></pre>
Учтите, что, в отличие от ArrayBuffer, при создании нового буфера Node его
содержимое не инициализируется. Если вы хотите избежать неприятных сюрпризов при работе с буфером, который может содержать всевозможные аномальные (а возможно, конфиденциальные) данные, буфер лучше заполнить
сразу же после его создания:
<pre><code >let buf = new Buffer(24);
buf.fill(0); // Буфер заполняется нулями</code></pre>
Также возможно частичное заполнение буфера с указанием начального и конечного значения.
Также можно создать новый буфер напрямую, передав функции-конструктору
массив октетов, другой буфер или строку. Буфер создается с копированием
содержимого переданного объекта. Для строки, если она не хранится в кодировке UTF-8, необходимо указать кодировку; по умолчанию строки Node
хранятся в кодировке UTF-8 (<span class="code">utf8</span> или <span class="code">utf-8</span>)
<pre><code >let str = 'New String';
let buf = new Buffer(str);</code></pre>
в Node v6 на смену конструкторам пришли новые методы Buffer для
создания буферов: <span class="code">Buffer.from()</span>, <span class="code">Buffer.alloc()</span> и <span class="code">Buffer.allocUnsafe()</span>.
При передаче массива функция <span class="code">Buffer.from()</span> возвращает буфер с копией
содержимого. Однако если передать массив функции <span class="code">ArrayBuffer</span> с необязательными параметрами смещения и длины, буфер использует ту же память,
что и <span class="code">ArrayBuffer</span>. При передаче буфера копируется содержимое буфера, а при
передаче строки происходит копирование строки.
Функция <span class="code">Buffer.alloc()</span> создает заполненный буфер определенного размера,
а <span class="code">Buffer.allocUnsafe()</span> создает буфер определенного размера, который может
содержать старые или конфиденциальные данные и в дальнейшем должен
быть заполнен вызовом <span class="code">buf.fill()</span>.
<pre><code>'use strict';
let a = [1,2,3];
let b = Buffer.from(a);
console.log(b);
let a2 = new Uint8Array([1,2,3]);
let b2 = Buffer.from(a2);
console.log(b2);
let b3 = Buffer.alloc(10);
console.log(b3);
let b4 = Buffer.allocUnsafe(10);
console.log(b4);</code></pre>
<div class="code-example-output-title"><span>Вывод:</span>
<div class="code-example-output">
<pre>
&lt;Buffer 01 02 03>
&lt;Buffer 01 02 03>
&lt;Buffer 00 00 00 00 00 00 00 00 00 00>
&lt;Buffer a0 64 a3 03 00 00 00 00 01 00>
</pre>
</div>
</div>
Обратите внимание на артефакты данных при использовании Buffer.
<span class="code">allocUnsafe()</span> вместо <span class="code">Buffer.alloc()</span>.
<h2>Буферы, JSON, StringDecoder и строки UTF-8</h2>
Буфер можно преобразовать в формат JSON и в строковую форму. Сохраните
следующий фрагмент в файле Node и выполните его в командной строке:
<pre><code>"use strict";
let buf = new Buffer('This is my pretty example');
let json = JSON.stringify(buf);
console.log(json);</code></pre>
<div class="code-example-output-title"><span>Вывод:</span>
<div class="code-example-output">
<pre>
{"type":"Buffer",
"data":[84,104,105,115,32,105,115,32,109,121,32,112,114,101,116,
116,121,32,101,120,97,109,112,108,101]}
</pre>
</div>
</div>
В формате JSON сначала указывается тип преобразуемого объекта <span class="code">Buffer</span>, а затем следуют его данные. Разумеется, то, что вы видите, — данные после сохранения в буфере в виде последовательности октетов, непонятной для человека.
Чтобы вернуться к исходному состоянию данных, можно восстановить содержимое буфера по объекту JSON, а затем воспользоваться методом <span class="code">Buffer.toString()</span> для преобразования в строку
Строка преобразуется в буфер и JSON, затем обратно в буфер и в строку
<pre><code >"use strict";
let buf = new Buffer('This is my pretty example');
let json = JSON.stringify(buf);
let buf2 = new Buffer(JSON.parse(json).data);
console.log(buf2.toString()); // this is my pretty example</code></pre>
Различия между функциями преобразования продемонстрированы в следующем приложении Node. Знак евро (€) кодируется тремя октетами, но первый
буфер содержит только два октета. Второй буфер содержит третий октет.
<pre><code >"use strict";
let StringDecoder = require('string_decoder').StringDecoder;
let decoder = new StringDecoder('utf8');
let euro = new Buffer([0xE2, 0x82]);
let euro2 = new Buffer([0xAC]);
console.log(decoder.write(euro));
console.log(decoder.write(euro2));
console.log(euro.toString());
console.log(euro2.toString());</code></pre>
В результате при использовании StringDecoder на консоль выводится пустая строка и вторая строка со знаком евро (€), а при использовании buffer.
toString() — две строки абракадабры.
Строку также можно преобразовать в существующий буфер вызовом buffer.
write(). Однако при этом важно, чтобы буфер имел правильный размер для хранения количества октетов, необходимых для представления символов.
И снова для представления знака евро необходимы три октета(0xE2, 0x82,
0xAC):
<pre><code >let buf = new Buffer(3);
buf.write('€','utf-8');</code></pre>
Этот пример также наглядно показывает, что количество символов UTF-8 не
эквивалентно количеству октетов в буфере. Если у вас возникнут сомнения,
проверьте размер буфера при помощи buffer.length:

<h2>Операции с буфером</h2>
Для чтения и записи содержимого буфера с заданным смещением примеряются различные типизованные функции. Примеры использования этих функций
представлены в следующем фрагменте, который записывает в буфер четыре
8-разрядных целых числа без знака, а затем снова читает и выводит их:

<pre><code >var buf = new Buffer(4);
// Запись значений в буфер
buf.writeUInt8(0x63,0);
buf.writeUInt8(0x61,1);
buf.writeUInt8(0x74,2);
buf.writeUInt8(0x73,3);
// Вывод буфера в строковом виде
console.log(buf.toString());</code></pre>
Попробуйте выполнить этот пример: скопируйте код в файл и выполните его.
Вы также можете прочитать каждое отдельное 8-разрядное число методом
buffer.readUInt8().
Node поддерживает чтение и запись 8-, 16- и 32-разрядных целых чисел со
знаком и без, а также вещественных чисел одинарной и двойной точности. Для
всех типов, кроме 8-разрядных целых чисел, также можно выбрать формат
с прямым (little-endian) или обратным (big-endian) порядком байтов. Несколько примеров поддерживаемых функций:
<ul>
    <li>buffer.readUIntLE(): чтение значения с заданным смещением и прямым
        порядком байтов.
    </li>
    <li>buffer.writeUInt16BE(): запись 16-разрядного целого без знака с заданным смещением и обратным порядком байтов.</li>
    <li>buffer.readFloatLE(): чтение вещественного числа одинарной точности
        с заданным смещением и прямым порядком байтов</li>
    <li>buffer.writeDoubleBE(): запись 64-разрядного вещественного числа
        двойной точности с заданным смещением и обратным порядком байтов.</li>
</ul>
8-разрядные целые числа также можно записывать напрямую в формате, сходном с форматом массива:
<pre><code >var buf = new Buffer(4);
buf[0] = 0x63;
buf[1] = 0x61;
buf[2] = 0x74;
buf[3] = 0x73;</code></pre>
роме чтения и записи по заданному смещению вы также можете создать
срез — новый буфер, содержащий часть старых данных, вызовом buffer.
slice(). В этой возможности особенно интересно то, что изменение содержимого нового буфера также приводит к изменению содержимого старого буфера.
3. Демонстрация автоматического изменения старого буфера при
изменении нового буфера
<pre><code >var buf1 = new Buffer('this is the way we build our buffer');
var lnth = buf1.length;
// Создание нового буфера как среза старого
var buf2 = buf1.slice(19,lnth);
console.log(buf2.toString()); // build our buffer
//Изменение второго буфера
buf2.fill('*',0,5);
console.log(buf2.toString()); // ***** our buffer
// Проверка содержимого первого буфера
console.log(buf1.toString()); // this is the way we ***** our buffer</code></pre>
Если вам потребуется проверить буферы на совпадение содержимого, используйте функцию buffer.equals():
<pre><code >if (buf1.equals(buf2)) console.log('buffers are equal');</code></pre>
Вы также можете скопировать байты из одного буфера в другой вызовом
buffer.copy(). Дополнительные параметры позволяют скопировать все байты
или их часть. Учтите, что, если размер второго буфера недостаточен для размещения всего содержимого, будет скопирована только помещающаяся часть
байтов:
<pre><code >var buf1 = new Buffer('this is a new buffer with a string');
// Копирование буфера
var buf2 = new Buffer(10);
buf1.copy(buf2);
console.log(buf2.toString()); // this is a</code></pre>
Для сравнения байтов используется метод buffer.compare(), который возвращает признак относительного расположения сравниваемых буферов в лексикографическом порядке. Если сравниваемый буфер предшествует второму, то
возвращается значение –1; если нет — значение 1. Если два буфера содержат
одинаковые байты, то возвращается 0:
<pre><code >var buf1 = new Buffer('1 is number one');
var buf2 = new Buffer('2 is number two');
var buf3 = new Buffer(buf1.length);
buf1.copy(buf3);
console.log(buf1.compare(buf2)); // -1
console.log(buf2.compare(buf1)); // 1
console.log(buf1.compare(buf3)); // 0</code></pre>
Существует еще один класс буфера SlowBuffer, который может использоваться, если вам когда-нибудь потребуется сохранить содержимое небольшого
буфера в течение продолжительного времени. Обычно Node выделяет память
для небольших буферов (менее 4 Кбайт) в заранее выделенном блоке памяти.
Это делается для того, чтобы механизму уборки мусора не приходилось отслеживать и освобождать большое количество мелких блоков памяти.
Класс SlowBuffer позволяет создавать мелкие буферы за пределами заранее
выделенного блока памяти, чтобы они могли существовать в течение более
долгого периода времени. Впрочем, как нетрудно представить, этот класс может существенно повлиять на быстродействие программы. Используйте его
только в том случае, если никакое другое решение не подходит.

<h2>Обратные вызовы и асинхронная обработка событий в Node</h2>
Язык JavaScript является однопоточным, то есть синхронным по своей природе. Это означает, что код JavaScript выполняется строка за строкой до тех
пор, пока приложение не будет завершено. Так как среда Node базируется на
JavaScript, она наследует это однопоточное синхронное поведение.
Но если в приложении используется функциональность, требующая ожидания некоторого условия (например, открытия файла), получения веб-ответа
или другой аналогичной операции, блокирование приложения до завершения
операции создаст серьезную критическую точку в серверном приложении.
Для предотвращения блокировки используется цикл событий.


<h3>Очередь событий (цикл)</h3>
Для достижения асинхронной функциональности приложение может пойти по
одному из двух путей. Первый вариант — выделить каждый продолжительный процесс в отдельный программный поток (thread). В это время остальной код
выполняется параллельно. Недостаток многопоточного решения заключается
в том, что потоки обходятся дорого. Они требуют значительных затрат ресурсов и сильно повышают сложность приложения.
Второй вариант — использование событийной архитектуры. В этом случае
при запуске процесса, занимающего много времени, приложение не ожидает
его завершения. Вместо этого процесс сигнализирует о своем завершении выдачей события. Событие помещается в специальную очередь (цикл событий).
Зависимая функциональность регистрирует свой интерес к данному событию
в приложении, и когда событие извлекается из очереди и обрабатывается,
зависимая функциональность активизируется и получает данные, сопровождающие событие.
JavaScript в браузере и Node выбирают второй подход. В браузере при назначении элементу обработчика щелчка вы регистрируете событие (подписываетесь
на него) и определяете функцию обратного вызова, которая будет вызываться
при возникновении события; таким образом, выполнение остального кода
приложения может продолжаться:
<pre><code >&lt;div id="someid"> &lt;/div>
&lt;script>
    document.getElementById("someid").addEventListener("click",
        function(event) {
            event.target.innerHTML = "I been clicked!";
        }, false);
&lt;/script></code></pre>
Node использует собственный цикл событий, но вместо ожидания событий
пользовательского интерфейса (например, щелчков на элементах) этот цикл
обеспечивает поддержку серверной функциональности — прежде всего ввода/
вывода. События могут сообщать об открытии файла; о том, что его содержимое прочитано в буфер; о получении веб-запроса от пользователя и т. д. Все эти
процессы могут не только занимать много времени, но и создавать значительную конкуренцию за ресурсы, а каждое обращение к ресурсу обычно блокирует этот ресурс от других обращений до завершения исходного процесса. Кроме
того, приложения на базе веб-технологий зависят от действий пользователя,
а иногда и от действий других приложений.
Node обрабатывает все события в очереди по порядку. Добравшись до события,
которое вас интересует, Node вызывает указанную вами функцию обратного
вызова (callback) и передает ей всю информацию, связанную с событием.
В простейшем веб-сервере, созданном в первом примере из главы 1, был
представлен цикл событий в действии. Я повторю код, чтобы вам было проще
следить за происходящим:
<pre><code >var http = require('http');
http.createServer(function (request, response) {
response.writeHead(200, {'Content-Type': 'text/plain'});
response.end('Hello World\n');
}).listen(8124);
console.log('Server running at http://127.0.0.1:8124/');</code></pre>
Базовый веб-сервер с дополнительными событиями
<pre><code >var http = require('http');
var server = http.createServer();
server.on('request', function (request, response) {
    console.log('request event');
    response.writeHead(200, {'Content-Type': 'text/plain'});
    response.end('Hello World\n');
});
server.on('connection', function() {
    console.log('connection event');
});
server.listen(8124, function() {
    console.log('listening event');
});
console.log('Server running on port 8124');</code></pre>
Обратите внимание: requestListener(), функция обратного вызова серверного запроса, уже не вызывается в функции http.createServer(). Вместо этого
приложение присваивает только что созданный сервер HTTP переменной,
которая затем используется для перехвата двух событий:
<ul>
    <li>Событие request, генерируемое каждый раз при выдаче веб-запроса
        клиентом.
    </li>
    <li>Событие connection, генерируемое каждый раз, когда новый клиент
        подключается к веб-приложению.</li>
</ul>
В обоих случаях для подписки на события используется функция on(), наследуемая классом сервера HTTP от класса EventEmitter. Объект, от которого
наследуется эта функциональность, будет рассмотрен в следующем разделе,
а пока займемся самими событиями. В этом примере приложение подписывается еще на одно событие — событие прослушивания, для которого функция
обратного вызова используется с функцией HTTP server.listen().
Итак, имеется один объект — сервер HTTP и три события — request, connection
и listening. Что же происходит при создании приложения и выдаче веб-запросов?
При запуске приложения немедленно выводится сообщение о том, что сервер
выполняется на порте 8124. Это объясняется тем, что приложение не блокируется при создании сервера, подключении клиента или когда начинается прослушивание запросов. Таким образом, сообщение console.log() впервые отрабатывает после прохождения всех неблокирующих асинхронных функций.
Следующее сообщение — «listening event». Сразу же после создания сервера
необходимо начать прослушивание новых подключений и запросов. Для этого
вызывается функция server.listen(). Дожидаться событий «сервер создан» не
нужно, так как функция http.createServer() немедленно возвращает управление. Вы можете убедиться в этом, вставив сообщение console.log() прямо
после вызова функции http.createServer(). Если вы добавите эту строку, она
первой будет выведена на консоль при запуске приложения.
В предыдущей версии приложения вызов server.listen() был объединен в цепочку с вызовом http.createServer(), но это не обязательно. Такая конструкция — вопрос удобства и элегантности кода, с генерированием событий она не
связана. С другой стороны, server.listen() — асинхронная функция с функцией обратного вызова, активизируемой при выдаче события прослушивания.
Таким образом, сообщение будет выведено после сообщения о выполнении
сервера на порте 8124.
Никакие другие сообщения не выводятся до тех пор, пока к веб-приложению
не подключится клиент. Тогда выводится сообщение о событии подключения
(connection), потому что это событие первым генерируется при появлении
нового клиента. За ним выводится одно или два сообщения о событии запроса (request); различия связаны с особенностями выдачи запросов к новым сайтам
в браузере. Chrome запрашивает ресурс, но также запрашивает и значок сайта
favicon.ico, поэтому приложение получает два запроса. Firefox и IE этого не
делают, поэтому для этих браузеров приложение получает только одно сообщение о запросе.
Если обновить запрос страницы в том же браузере, вы получите только
сообщение(-я) о событии запроса. Подключение уже установлено, и оно сохраняется до тех пор, пока пользователь не закроет браузер или не произойдет
какой-нибудь тайм-аут. При обращении к одному ресурсу из разных браузеров
для каждого из них генерируется отдельное событие подключения.
При обращении к веб-приложению из Chrome на консоль выводится следующая последовательность сообщений:
<ol>
    <li>Server running on port 8124.</li>
    <li>Listening event.</li>
    <li>Connection event.</li>
    <li>Request event</li>
    <li>Request event.</li>
</ol>

Если у вас в модуле или прямо в приложении определяется функция, которая
должна быть асинхронной, она определяется по специальным правилам, описанным в следующем разделе.

<h3>Создание асинхронной функции обратного вызова</h3>
тобы продемонстрировать фундаментальную структуру функциональности
обратных вызовов, в листинге 2.5 представлено полноценное приложение
Node, в котором создается объект с единственной функцией doSomething().
Функция получает три аргумента: первый возвращается как данные при отсутствии ошибки, второй должен содержать строку, а в третьем передается функция обратного вызова. Если второй аргумент doSomething() отсутствует или не
содержит строку, то объект создает новый объект Error, который возвращается
функцией обратного вызова. Если ошибки не происходит, вызывается функция обратного вызова, коду ошибки присваивается null, а функция возвращает
данные (в этом случае первый аргумент.)
Ключевые элементы функциональности обратного вызова выделены жирным
шрифтом в листинге 2.5.
Фундаментальная структура функциональности
обратного вызова

<pre><code >var fib = function (n) {
if (n &lt; 2) return n;
return fib(n - 1) + fib(n - 2);
};
var Obj = function() { };
Obj.prototype.doSomething = function(arg1_) {
var callback_ = arguments[arguments.length - 1];
callback = (typeof(callback_) == 'function' ? callback_ : null);
var arg1 = typeof arg1_ === 'number' ? arg1_ : null;
if (!arg1)
return callback(new Error('first arg missing or not a number'));
process.nextTick(function() {
// Блокирующая операция
var data = fib(arg1);
callback(null, data);
});
}
var test = new Obj();
var number = 10;
test.doSomething(number, function(err,value) {
if (err)
console.error(err);
else
console.log('fibonaci value for %d is %d', number, value);
});
console.log('called doSomething');</code></pre>
Первое, что нужно сделать, — проследить за тем, что в последнем аргументе передается функция обратного вызова, а в первом аргументе функции обратного
вызова — код ошибки. Мы не можем определить намерения пользователя, но
можем убедиться в том, что последний аргумент содержит функцию, и этого
достаточно.
Второй ключевой аспект — создание объекта Node Error при возникновении ошибки и возвращение его как результата функции обратного вызова.
В асинхронной архитектуре положиться на throw...catch нельзя, так чтообработка ошибок должна выполняться в объекте Error в функции обратного
вызова.
Последний критичный аспект функциональности — вызов функции обратного
вызова с передачей данных функции при отсутствии ошибки. Но чтобы обратный вызов был асинхронным, мы вызываем его в функции process.nextTick().
Причина в том, что process.nextTick() гарантирует, что цикл событий будет
очищен перед вызовом функции. Это означает, что вся синхронная функциональность будет обработана до активизации блокирующей функциональности
(если она есть). В примере блокировка происходит не из-за ввода/вывода,
а из-за того, что операция нагружает процессор. Возможно, вызов функции,
генерирующей последовательность Фибоначчи для значения 10, займет немного времени, но со значением 50 и более (в зависимости от ресурсов вашей
системы) задержка станет более заметной. Функция Фибоначчи вызывается
в process.nextTick(); это гарантирует, что функциональность, нагружающая
процессор, будет выполняться асинхронно
Короче говоря, все остальное может изменяться, но следующие четыре ключевых аспекта должны присутствовать всегда:
<ul>
    <li>Убедитесь в том, что последний аргумент содержит функцию обратного
        вызова.</li>
    <li>Создайте объект Node Error и верните его в первом аргументе функции
        обратного вызова, если произошла ошибка</li>
    <li>Если ошибки нет, вызовите функцию обратного вызова, присвойте
        аргументу ошибки null и передайте все нужные данные.</li>
    <li>Функция обратного вызова должна вызываться из process.nextTick(),
        чтобы процесс не блокировался.</li>
</ul>
Если заменить значение number на 10, приложение выдаст на консоль следующий результат:
called doSomething
[Error: first argument missing or not a number]
Если просмотреть код в каталоге lib установки Node, вы увидите, что паттерн
с функцией обратного вызова в последней позиции постоянно встречается
в нем. Функциональность может изменяться, но паттерн остается постоянным.
Этот метод достаточно прост, и он обеспечивает непротиворечивость результатов асинхронных методов.
Ранее я упоминала о том, что объект http.Server наследует от другого объекта,
и именно таким образом он наделяется способностью генерирования событий.
Этот объект с именем EventEmitter будет рассмотрен в следующем разделе.
Цикл событий Node является однопоточным. Однако это не означает, что во время его выполнения в фоновом режиме не работают другие программные потоки.
Node обращается к функциональности (например, функциональности файловой системы fs), реализованной на C++, а не на JavaScript. Функциональность
fs использует рабочие потоки для достижения своих целей. Кроме того, Node
использует библиотеку libuv, которая использует пул рабочих потоков для реализации своей функциональности. Конкретное количество потоков зависит от
операционной системы.
Если вы будете ограничиваться JavaScript и создавать модули JavaScript, вам
никогда не придется беспокоиться о рабочих потоках и libuv. Факт: меня похлопали по плечу и предложили не забивать голову мыслями о рабочих потоках.
В прошлом мне доводилось работать с многопоточными средами, так что меня
такой подход устраивает.

<h2>EventEmitter</h2>
Стоит немного поскрести многие базовые объекты Node, и под оболочкой обнаружится EventEmitter. Каждый раз, когда вы видите объект, генерирующий
событие, которое обрабатывается функцией on, знайте: перед вами EventEmitter.
Понимание того, как работает класс EventEmitter, и умение его использовать —
две важнейшие составляющие программирования для Node.
Класс EventEmitter обеспечивает асинхронную обработку событий в Node.
Чтобы продемонстрировать его базовую функциональность, напишем короткое тестовое приложение.
Начнем с включения модуля Events:
var events = require('events');
Затем создадим экземпляр EventEmitter:
var em = new events.EventEmitter();
Только что созданный объект EventEmitter используется для выполнения двух
важнейших задач: присоединения обработчика к событию и генерирования
самого события. Обработчик события EventEmitter.on() активизируется при
генерировании конкретного события. Первый параметр метода содержит имя
события; во втором передается функция обратного вызова для выполнения
некоторой функциональности:
em.on('someevent', function(data) { ... });
Событие генерируется для объекта методом EventEmitter.emit() при выполнении некоторого условия:
if (somecriteria) {
en.emit('data');
}
Простейшая проверка функциональности EventEmitter
var eventEmitter = require('events').EventEmitter;
var counter = 0;
var em = new eventEmitter();
setInterval(function() { em.emit('timed', counter++); }, 3000);
em.on('timed', function(data) {
console.log('timed ' + data);
});

При запуске приложения хронометражные сообщения о событиях выводятся
на консоль до момента завершения приложения. Главный вывод, который
следует сделать из этого простого примера: событие генерируется функцией
EventEmitter.emit(), а функция EventEmitter.on() может использоваться для
перехвата этого события и его обработки.
Этот пример интересен, но не особенно полезен. Нас в данном случае интересует возможность добавления функциональности EventEmitter к существующим объектам, а не использование экземпляров EventEmitter в приложениях.
Именно эту задачу решают http.Server и многие другие классы с поддержкой
событий в Node.
Функциональность EventEmitter наследуется, и чтобы наследование стало
возможным, приходится использовать другой объект Node, Util. Модуль Util
импортируется в приложение следующей командой:
var util = require('util');
Модуль Util чрезвычайно полезен. Основная его функциональность будет рассмотрена в главе 11, когда мы займемся отладкой приложений Node. Впрочем,
одна из функций — util.inherits() — потребуется прямо сейчас.
Функция util.inherits() позволяет одному конструктору унаследовать методы прототипа другого — суперконструктора. Чтобы функция util.inherits()
была еще более интересной, вы также можете обращаться к суперконструктору
прямо в функциях конструктора.
Функция util.inherits() позволяет унаследовать функциональность очереди
сообщений Node от EventEmitterв любом классе:
util.inherits(Someobj, EventEmitter);
В результате вызова util.inherits() с объектом вы можете вызвать метод
emit с методами объекта и программировать обработчики для экземпляров
объекта:
Someobj.prototype.someMethod = function() { this.emit('event'); };
...
Someobjinstance.on('event', function() { });
Вместо того чтобы разбираться, как EventEmitter работает в абстрактном
смысле, перейдем к листингу 2.7, в котором продемонстрировано использование класса, наследующего функциональность EventEmitter. В приложении
создается новый класс inputChecker. Конструктор получает два значения, имячеловека (name) и имя файла (file). Он присваивает первое значение свойству, а также создает ссылку на поток с поддержкой записи при помощи метода
createWriteStream модуля File System.
Объект также содержит метод check, который проверяет входные данные на
конкретные команды. Одна команда (wr:) генерирует событие записи, а другая
(en:) — событие завершения. Если команда не задана, генерируется событие
эхо-вывода. Экземпляр объекта предоставляет обработчики для всех трех событий. Для события записи выполняется запись в выходной файл, для ввода
без команды выполняется эхо-вывод входных данных, а для события завершения приложение завершается методом process.exit.
Все входные данные поступают из стандартного входного потока (process.
stdin). Для записи выходных данных используется поток с возможностью
записи; таким образом, на заднем плане создается новый приемник вывода,
в очередь которого будут поступать будущие операции записи. Такой способ
вывода в файл более эффективен, особенно если ожидается частое выполнение
операций, как в данном приложении. Эхо-вывод реализуется простым выводом в process.stdout.
Создание объекта, наследующего от EventEmitter
"use strict";
var util = require('util');
var eventEmitter = require('events').EventEmitter;
var fs = require('fs');
function InputChecker (name, file) {
this.name = name;
this.writeStream = fs.createWriteStream('./' + file + '.txt',
{'flags' : 'a',
'encoding' : 'utf8',
'mode' : 0o666});
};
util.inherits(InputChecker,eventEmitter);
InputChecker.prototype.check = function check(input) {
// Удаление лишних пропусков
let command = input.trim().substr(0,3);
// Обработка команды
// Команда wr: входные данные записываются в файл
if (command == 'wr:') {
this.emit('write',input.substr(3,input.length));
// Команда en: процесс завершается
} else if (command == 'en:') {
this.emit('end');
// Эхо-вывод в стандартный выходной поток
} else {
this.emit('echo',input);
}
};
// Тестирование нового объекта и обработки событий
let ic = new InputChecker('Shelley','output');
ic.on('write', function(data) {
this.writeStream.write(data, 'utf8');
});
ic.on('echo', function( data) {
process.stdout.write(ic.name + ' wrote ' + data);
});
ic.on('end', function() {
process.exit();
});
// Получение ввода после назначения кодировки
process.stdin.setEncoding('utf8');
process.stdin.on('readable', function() {
let input = process.stdin.read();
if (input !== null)
ic.check(input);
});
Обратите внимание: функциональность также включает метод обработчика
события process.stdin.on, так как process.stdin — один из многих объектов
Node, наследующих от EventEmitter.
Функция on() в действительности является сокращенной формой записи для
функции EventEmitter.addListener, получающей те же параметры. Таким образом, следующий фрагмент:
ic.addListener('echo', function( data) {
console.log(this.name + ' wrote ' + data);
});
в точности эквивалентен:
ic.on('echo', function( data) {
console.log(this.name + ' wrote ' + data);
});
Для прослушивания следующего события можно использовать метод
EventEmitter.once():
ic.once(event, function);
При превышении десяти слушателей для события по умолчанию выводится
предупреждение. Чтобы изменить количество максимальных слушателей,
используйте команду setMaxListeners с числом. Значение 0 соответствует неограниченному количеству слушателей.
Слушателей можно удалять вызовом EventEmitter.removeListener():
ic.on('echo', callback);
ic.removeListener('echo',callback);
Этот вызов удаляет из массива слушателей одного слушателя с сохранением
порядка остальных.
Однако если вы по какой-то причине скопировали массив слушателей с использованием EventEmitter.listeners(), вам придется создать его заново после
удаления слушателей.
<h2>Цикл событий Node и таймеры</h2>
В браузере для работы с таймерами существуют setTimeout() и setInterval();
эти функции также доступны и в Node. Они не совсем равноценны, потому
что браузер использует цикл событий, реализуемый на уровне ядра браузера,
а цикл событий Node реализуется библиотекой C++, libuv, но в основном различия между ними несущественны.
Функция Node setTimeout() получает в первом параметре функцию обратного
вызова, во втором — время задержки (в миллисекундах), а также необязательный список аргументов:
setTimeout(function(name) {
console.log('Hello ' + name);
}, 3000, 'Shelley');
console.log("waiting on timer...");
Имя в списке аргументов передается в аргументе функции обратного вызова в setTimeout(). Продолжительность задержки устанавливается равной
3000 миллисекунд. Сообщение console.log() «waiting on timer...» выводится
почти немедленно, так как функция setTimeout() выполняется асинхронно.
Таймер можно отменить, если ваше приложение присвоит его переменной при
создании. Я изменю предыдущую версию приложения Node и включу в него
ускоренную отмену и вывод сообщения:
var timer1 = setTimeout(function(name) {
console.log('Hello ' + name);
}, 30000, 'Shelley');
console.log("waiting on timer...");
setTimeout(function(timer) {
clearTimeout(timer);
console.log('cleared timer');
}, 3000, timer1);
Таймер устанавливается на очень долгий период времени. У нового таймера
будет достаточно времени для вызова функции обратного вызова, которая
непосредственно отменяет таймер.
Функция setInterval() работает аналогично setTimeout(), если не считать того,
что таймер продолжает повторно срабатывать, пока приложение не будет завершено или таймер не будет сброшен вызовом clearInterval(). В следующем
примере вместо setTimeout() демонстрируется использование setInterval():
сообщение повторяется девять раз перед отменой таймера
var interval = setInterval(function(name) {
console.log('Hello ' + name);
}, 3000, 'Shelley');
setTimeout(function(interval) {
clearInterval(interval);
console.log('cleared timer');
}, 30000, interval);
console.log('waiting on first interval...');

Как указано в документации Node, нет гарантий того, что функция обратного
вызова будет вызвана ровно через n миллисекунд (для любого n). Этим она
не отличается от использования setTimeout() в браузере — у нас нет полного контроля над окружением и разные факторы могут вызвать небольшую
задержку таймера. В большинстве случаев расхождения в периодичности
срабатывания функций таймера не ощущается. Впрочем, если вы создаете
анимации, задержка может стать заметной.

Существует две функции, специфичные для Node, которые могут использоваться с таймерами/интервалами, возвращаемыми при вызове setTimeout()
или setInterval(): ref() и unref(). Если вызвать unref() для таймера и это
единственное событие в очереди событий, то таймер отменяется, а программа
сможет завершиться. Если вызвать ref() для того же объекта таймера, программа будет выполняться до тех пор, пока таймер не будет обработан.

Вернемся к первому примеру, создадим таймер с большей продолжительностью, вызовем для него unref() и посмотрим, что произойдет:
var timer = setTimeout(function(name) {
console.log('Hello ' + name);
}, 30000, 'Shelley');
timer.unref();
console.log("waiting on timer...");

Запущенное приложение выводит сообщение на консоль, а затем завершается.
Причина в том, что таймер, установленный вызовом setTimeout(), является
единственным событием в очереди событий приложения. А если добавить еще
одно событие? Изменим программу, добавим интервал и тайм-аут и вызовем
unref() для тайм-аута:

var interval = setInterval(function(name) {
console.log('Hello ' + name);
}, 3000, 'Shelley');
var timer = setTimeout(function(interval) {
clearInterval(interval);
console.log('cleared timer');
}, 30000, interval);
timer.unref();
console.log('waiting on first interval...');






Таймер получает возможность продолжать; это означает, что он завершает
интервал. Однако именно интервальные события позволили таймеру просуществовать достаточно долго для того, чтобы таймер мог сбросить интервал.
Последняя пара таймерных функций уникальна для Node: setImmediate()
и clearImmediate(). Функция setImmediate() создает событие, но это событие имеет более высокий приоритет, чем события, созданные setTimeout()
и setInterval(). Однако при этом оно не превосходит по приоритету события ввода/вывода и с ним не связывается собственный таймер. Событие
setImmediate() генерируется после всех событий ввода/вывода, до событий
таймера, и в текущей очереди событий. Если вызвать его из функции обратного вызова, то оно помещается в следующий цикл событий после завершения
того цикла, в котором оно было вызвано. Фактически эти функции позволяют
добавить событие в текущий или в следующий цикл событий без лишних
таймеров. Этот способ эффективнее setTimeout(callback, 0), потому что он
превосходит по приоритету другие события таймеров.
Он похож на другую функцию — process.nextTick(), не считая того, что функция обратного вызова process.nextTick() активизируется после завершения
текущего цикла событий, но до добавления каких-либо новых событий ввода/
вывода. Как было показано ранее в разделе «Создание асинхронной функции
обратного вызова» на с. 55, эта функция используется исключительно для реализации асинхронной функциональности Node.

<h2>Вложенные обратные вызовы
    и обработка исключений</h2>
В клиентских приложениях JavaScript нередко встречаются конструкции следующего вида:
val1 = callFunctionA();
val2 = callFunctionB(val1);
val3 = callFunctionC(val2);
Функции вызываются поочередно, результат предыдущего вызова передается
следующей функции. Так как все функции синхронны, нам не нужно беспокоиться о возможном нарушении последовательности выполнения — неожиданные результаты исключены.
В листинге 2.8 представлен относительно частый пример последовательного
программирования такого рода. Приложение использует синхронные версии
методов модуля File System Node для открытия файла и получения его данных, модификации данных с заменой всех вхождений «apple» на «orange»
и выводом полученной строки в новый файл.
Последовательное синхронное приложение
var fs = require('fs');
try {
var data = fs.readFileSync('./apples.txt','utf8');
console.log(data);
var adjData = data.replace(/[A|a]pple/g,'orange');
fs.writeFileSync('./oranges.txt', adjData);
} catch(err) {
console.error(err);
}
Так как при выполнении могут возникнуть проблемы и мы не можем быть
уверены, что ошибки будут обработаны во внутренней реализации функций
модуля, все вызовы функций заключаются в блок try для корректной (или
хотя бы более содержательной) обработки ошибок. Ниже показано, как выглядит ошибка, если приложение не может найти файл для чтения:
{ [Error: ENOENT: no such file or directory, open './apples.txt']
errno: -2,
code: 'ENOENT',
syscall: 'open',
path: './apples.txt' }
Преобразование синхронной схемы последовательного приложения в асинхронную реализацию потребует пары изменений. Во-первых, все функции
необходимо заменить их асинхронными аналогами. Также необходимо учесть,
что каждая функция не блокируется при вызове, а это означает, что мы не можем гарантировать правильную последовательность выполнения, если функции будут вызываться независимо друг от друга. Гарантировать, что функции
будут вызываться в правильной последовательности, можно только одним
способом — использованием вложения обратных вызовов.
В листинге 2.9 приведена асинхронная версия приложения из листинга 2.8.
Все вызовы функций файловой системы заменены их асинхронными версиями, а функции вызываются в правильном порядке посредством вложения.
Кроме того, блок try...catch исключен из программы.
Мы не можем использовать try...catch, потому что из-за использования
асинхронных функций блок try...catch будет реально обработан до вызова
асинхронной функции. Таким образом, попытка инициирования ошибки
в функции обратного вызова равносильна инициированию ошибки за пределами процесса, эту ошибку перехватывающего. Вместо этого ошибка обрабатывается напрямую: если она существует, то функция обрабатывает ее и возвращает управление; если же ошибки нет, процесс функции обратного вызова
продолжает выполнение.

Приложение из листинга 2.8, преобразованное с использованием
асинхронных вложенных обратных вызовов
var fs = require('fs');
fs.readFile('./apples.txt','utf8', function(err,data) {
if (err) {
console.error(err);
} else {
var adjData = data.replace(/apple/g,'orange');
fs.writeFile('./oranges.txt', adjData, function(err) {
if (err) console.error(err);
});
}
});
В листинге 2.9 выполняется открытие и чтение входного файла, и только
при завершении обеих операций вызывается функция обратного вызова. Эта
функция проверяет переменную ошибки; если переменной присвоено значение, то объект ошибки выводится на консоль. При отсутствии ошибки происходит обработка данных с вызовом асинхронного метода writeFile(). Его
функция обратного вызова имеет только один аргумент: объект ошибки. Если
он отличен от null, то он также выводится на консоль.
Если вы захотите просмотреть трассировку стека ошибки, выведите свойство
stack объекта ошибки Node:
f (err) {
console.error(err.stack);
}
новый уровень вложения обратных вызовов и может усложнить обработку
ошибок. В листинге 2.10 приложение получает список файлов в каталоге.
В каждом файле обобщенное доменное имя заменяется конкретным доменным
именем с использованием строкового метода replace, а результат записывается
обратно в исходный файл. Информация обо всех измененных файлах записывается в открытый выходной поток.
Получение списка изменяемых файлов
var fs = require('fs');
var writeStream = fs.createWriteStream('./log.txt',
{'flags' : 'a',
'encoding' : 'utf8',
'mode' : 0666});
writeStream.on('open', function() {
// Получение списка файлов
fs.readdir('./data/', function(err, files) {
// Для каждого файла
if (err) {
console.log(err.message);
} else {
files.forEach(function(name) {
// Изменение содержимого
fs.readFile('./data/' + name,'utf8', function(err,data) {
if (err){
console.error(err.message);
} else {
var adjData = data.replace(/somecompany\.com/g,
'burningbird.net');
// Запись в файл
fs.writeFile('./data/' + name, adjData, function(err)
{
if (err) {
console.error(err.message);
} else {
// Вывод информации об изменении файла
writeStream.write('changed ' + name + '\n',
'utf8', function(err) {
if(err) console.error(err.message);
});
}
});
}
});
});
}
});
});
writeStream.on('error', function(err) {
console.error("ERROR:" + err);
});
Прежде всего мы видим нечто новое: применение механизма обработки событий для обработки ошибок при вызове функции fs.createWriteStream. Причина, по которой мы используем обработку событий, заключается в том, что
createWriteStream выполняется асинхронно, поэтому мы не сможем использовать традиционный механизм try...catch. В то же время createWriteStream
не предоставляет функцию обратного вызова, в которой можно было бы
перехватывать ошибки. Вместо этого мы перехватываем событие ошибки и обрабатываем его, выводя сообщение об ошибке. После этого проверяется событие открытия (успешная операция) и выполняются операции
с файлом.
Приложение выводит сообщение об ошибке напрямую.
Хотя все выглядит так, словно приложение обрабатывает каждый файл по отдельности, прежде чем переходить к следующему, запомните, что все методы,
использованные в приложении, являются асинхронными. Если вы запустите
приложение несколько раз и просмотрите файл log.txt, вы увидите, что файлы обрабатываются в разном порядке, который кажется случайным. В моей
системе подкаталог data содержит пять файлов. При троекратном запуске
приложения в файл log.txt были выведены следующие данные (пустые строки
вставлены для наглядности):
changed data1.txt
changed data2.txt
changed data3.txt
changed data4.txt
changed data5.txt
changed data2.txt
changed data4.txt
changed data3.txt
changed data1.txt
changed data5.txt
changed data1.txt
changed data2.txt
changed data5.txt
changed data3.txt
changed data4.txt
Другая проблема возникает, если вы хотите узнать, когда все файлы были
изменены, чтобы что-то сделать. Метод forEach вызывает функции обратного
вызова итератора асинхронно, так что выполнение не блокируется. Если вы
добавите команду после forEach, например такую:

// Вывод информации об изменении файла
writeStream.write('changed ' + name + '\n',
'utf8', function(err) {
if(err) {
console.log(err.message);
} else {
console.log('finished ' + name);
}
});
all finished
finished data3.txt
finished data1.txt
finished data5.txt
finished data2.txt
finished data4.txt
Что же делать? Добавьте счетчик, увеличивающийся с каждым сообщением,
и проверяйте его значение по длине массива файлов для вывода сообщения
«all done»:
// Перед обращением к каталогу
var counter = 0;
...
// Вывод информации об изменении файла
writeStream.write('changed ' + name + '\n',
'utf8', function(err) {
if(err) {
console.log(err.message);
} else {
console.log ('finished ' + name);
counter++;
if (counter >= files.length) {
console.log('all done');
}
}
});
На этот раз вы получаете ожидаемый результат: сообщение «all done» выводится после того, как все файлы были обновлены.
Приложение работает хорошо — если не считать того, что каталог, к которому
мы обращаемся, содержит не только файлы, но и другие подкаталоги. Если
приложение обнаруживает подкаталог, оно выдает следующую ошибку, хотя
и продолжает обработку прочего содержимого:
од в листинге 2.11 предотвращает такие ошибки, используя метод fs.stats
для получения объекта, представляющего данные команды Unix stat. Объект
содержит информацию о заданном элементе каталога, в том числе признак
того, является он файлом или нет. Конечно, метод fs.stats также является
асинхронным и требует дополнительного вложения обратных вызовов.
Добавление проверки каждого элемента каталога на то, что он
является файлом
var fs = require('fs');
var writeStream = fs.createWriteStream('./log.txt',
{flags : 'a',
encoding : 'utf8',
mode : 0666});
writeStream.on('open', function() {
var counter = 0;
// Получение списка файлов
fs.readdir('./data/', function(err, files) {
// Для каждого файла
if (err) {
console.error(err.message);
} else {
files.forEach(function(name) {
fs.stat('./data/' + name, function (err, stats) {
if (err) return err;
if (!stats.isFile()) {
counter++;
return;
}
// Изменение содержимого
fs.readFile('./data/' + name,'utf8', function(err,data) {
if (err){
console.error(err.message);
} else {
var adjData = data.replace(/somecompany\.com/g,
'burningbird.net');
// Запись в файл
fs.writeFile('./data/' + name, adjData,
function(err) {
if (err) {
console.error(err.message);
} else {
// Вывод информации об изменении файла
writeStream.write('changed ' + name + '\n',
function(err) {
if(err) {
console.error(err.message);
} else {
console.log('finished ' + name);
counter++;
if (counter >= files.length) {
console.log('all done');
}
}
});
}
});
}
});
});
});
}
});
});
writeStream.on('error', function(err) {
console.error("ERROR:" + err);
});
Приложение выполняет свою задачу, и выполняет ее хорошо, но как же трудно
читать и сопровождать этот код! Я использую return при обработке ошибок,
чтобы избавиться от одного условного вложения, но нормальное сопровождение такого кода становится почти невозможным. Я слышала, как подобные конструкции с вложенными обратными вызовами называют «спагетти
обратных вызовов», и даже более красочно — «пирамида погибели»… Оба
термина уместны.

Вложенные обратные вызовы неуклонно сдвигаются к правой части документа, отчего разработчику становится еще труднее убедиться в том, что он работает с правильным кодом, относящимся к нужному обратному вызову. Тем не
менее разбить вложение невозможно, потому что очень важно, чтобы методы
вызывались по порядку:
<ol>
    <li>Начать просмотр каталога</li>
    <li>Отфильтровать подкаталоги.</li>
    <li>Прочитать содержимое каждого файла.</li>
    <li>Изменить содержимое.</li>
    <li>Записать данные обратно в исходный файл.</li>
</ol>
Хотелось бы найти способ реализации подобных серий вызовов методов, не
зависящий от вложенных обратных вызовов. Для этого следует воспользоваться модулями независимых разработчиков и другими решениями. В главе 3
я использую модуль Async для разрушения «пирамиды погибели». А в главе 9
мы разберемся, поможет ли в решении этой задачи ES6.

Другой подход заключается в определении именованной функции как
функции обратного вызова для каждого метода. Такое решение «сглаживает» пирамиду и может упростить отладку. Тем не менее оно не
решает других проблем, например определения момента завершения
всех процессов. Для этого вам все равно потребуется модуль управления
асинхронными вызовами.
