<!--<title>Глава 6. Проектирование архитектуры на основе стека MEAN</title>-->
<h1>Глава 6. Проектирование архитектуры на основе стека MEAN</h1>
<h2>Традиционная архитектура стека MEAN</h2>
<p>Распространенный способ проектирования приложения на основе стека MEAN — использование <b>API REST</b> (<i>representational state transfer</i> — передача состояния представления) для поставки данных одностраничному приложению. Этот API обычно создается с помощью MongoDB, Express и Node.js, при построенном на AngularJS SPA. Такой подход особенно популярен у разработчиков, перешедших на стек MEAN с AngularJS и ищущих стек, который предоставляет быстрый адаптивный API. Основы этого подхода и поток данных иллюстрирует рис ниже:</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image67446034dac12f2e.png" alt="image67446034dac12f2e.png" border="0" />
<p><b>REST</b> расшифровывается как «передача состояния представления» (<i>REpresentational State Transfer</i>) и представляет собой скорее архитектурный стиль, чем жесткий протокол. В REST отсутствует сохранение состояния, он ничего не знает о состоянии или истории действий текущего пользователя.</p>
<p><b>API</b> — аббревиатура словосочетания <i>application program interface</i> — интерфейс программирования приложений, который дает возможность приложениям общаться друг с другом.</p>
<p>Таким образом, <b>API REST</b> — интерфейс без сохранения состояния к вашему приложению. В случае применения стека MEAN API REST используется для создания интерфейса без сохранения состояния к БД, предоставляя другим приложениям способ работы с данными.</p>
<p>На рис. выше изображена отличная схема, даже идеальная, если у вас применяется (или вы хотите создать) SPA в качестве пользовательского интерфейса.
AngularJS спроектирован с ориентацией на создание SPA, получение данных из API REST, равно как и отправку их обратно. MongoDB, Express и Node.js также обладают огромными возможностями по созданию API, используя JSON во всем стеке, включая и саму БД.</p>
<p>Подобная архитектура замечательна в случае SPA, но что, если у вас его нет или вы не хотите его использовать? Если это единственная рассматриваемая вами архитектура на основе стека MEAN, то вы можете почувствовать себя в тупике и начать искать решение в других местах. Но стек MEAN чрезвычайно гибок. Все четыре компонента обладают обширными возможностями и могут многое вам предложить.</p>

<h2>Выходим за рамки одностраничных приложений</h2>
<p>Да, создавать SPA на AngularJS замечательно, но иногда это не лучшее решение вашей задачи. Давайте бегло взглянем на кое-что касающееся SPA, что стоит иметь в виду при проектировании решения и выяснении того, подходит полный SPA для вашего проекта или нет. Данный раздел ни в коем случае не направлен против SPA. Одностраничные приложения обычно предоставляют потрясающий пользовательский интерфейс, при этом снижается нагрузка на ваши серверы и, следовательно, расходы на хостинг.</p>
<h3>Сложности со сканированием сайтов</h3>
<p>Приложения JavaScript создают немало сложностей для поисковых систем с точки зрения сканирования и индексации сайтов. Большинство поисковых систем просматривают HTML-содержимое страницы, но не скачивают и не выполняют JavaScript. Те же, которые делают это, фактически сканируют созданный JavaScript контент далеко не так хорошо, как выдаваемый сервером. Если весь ваш контент выдается через JavaScript-приложение, вы не будете знать, какая его часть будет проиндексирована.</p>
<p>Сопутствующий недостаток: автоматически создаваемые превью страниц из социальных сетей, таких как <i>Facebook</i>, <i>LinkedIn</i> и <i>Pinterest</i>, работают не очень
хорошо. Это происходит еще и потому, что они обращаются к HTML-коду соответствующей страницы и пытаются извлечь подходящие изображения и текст. Подобно поисковым системам, они не выполняют имеющийся на странице JavaScript-код, так что выдаваемый JavaScript контент не виден.</p>
<p>Существует пара обходных маневров, позволяющих придать вашему сайту видимость <i>сканируемости</i>. Оба включают создание отдельных HTML-страниц, зеркально отображающих содержимое вашего SPA. Вы можете заставить свой сервер создавать основанную на HTML версию сайта и выдавать ее поисковым агентам, также можно использовать автономный браузер, такой как PhantomJS, для запуска вашего JavaScript-приложения и вывода результирующего HTML</p>
<p>Оба этих подхода требуют немалых усилий и могут вызвать головную боль у службы техподдержки, если ваш сайт крупный и сложный. Имеются здесь и потенциальные подводные камни с точки зрения оптимизации поисковых систем (<i>search engine optimization</i> (<b>SEO</b>)). Если ваш сгенерированный сервером HTML-код покажется поисковому агенту слишком отличным от контента SPA, то ваш сайт может быть оштрафован. Запуск PhantomJS для вывода HTML может замедлить время отклика ваших страниц, а за это поисковые системы, в частности Google, будут ставить вас дальше в списке выдачи.</p>
<p>Имеет это значение или нет, зависит от того, что вы хотите создать. Если основной план развития того, что вы создаете, связан с трафиком поисковых систем или
соцсетями, то вам следует уделить сканируемости немалое внимание. Если же вы создаете что-либо маленькое, которое и должно будет остаться маленьким, то можете воспользоваться вышеупомянутыми обходными путями, которые при больших масштабах потребовали бы значительных усилий.</p>
<p>В то же время если вы создаете приложение, которому не требуется слишком большая SEO, или если вы хотите, чтобы ваш сайт плохо поддавался сканированию, то беспокоиться об этом смысла нет. Это может оказаться даже определенным преимуществом.</p>

<h3> Веб-аналитика и история браузера</h3>
<p>Аналитические инструменты, такие как Google Analytics, в значительной степени зависят от полной загрузки страниц в браузер, инициируемой изменением URL.
SPA подобным образом не работают. Именно поэтому они и называются одностраничными приложениями!</p>
<p>После загрузки первой страницы все загрузки последующих страниц и изменения контента обрабатываются внутри приложения. Так что браузер никогда не начнет загрузку новой страницы, в историю браузера ничего нового не попадет, и ваш аналитический пакет понятия не будет иметь о том, кто что делает на вашем сайте.</p>
<p>Можно добавить события загрузки страниц к SPA с помощью API историй HTML5, это поможет вам интегрировать в сайт аналитические инструменты. Сложность заключается в управлении им и обеспечении правильного отслеживания всего происходящего на сайте, что включает проверку пропущенных отчетов и дублирующихся записей.</p>
<p>Хорошая новость заключается в том, что вам не нужно создавать все с нуля. Существует несколько доступных в Интернете вариантов интеграции аналитических инструментов для AngularJS с открытым исходным кодом. Вам по-прежнему нужно будет внедрить их в приложение и убедиться, что все работает правильно, но не нужно будет делать все с самого начала.</p>
<p>Масштабы данной проблемы зависят от вашей потребности в гарантированно точной аналитике. Если вы хотели бы наблюдать за тенденциями в потоках и действиях посетителей, то интеграция, вероятно, покажется вам несложной. Чем больше подробностей и гарантированной точности вам нужно, тем больше работы придется выполнить при разработке и тестировании. Хотя, вероятно, намного легче просто включить код вашей веб-аналитики в каждую страницу сгенерированного сервером сайта, интеграция аналитики вряд ли окажется единственной причиной, по которой вам захочется выбрать вариант не одностраничного приложения.</p>

<h3>Скорость начальной загрузки</h3>
<p>SPA отличаются более медленной загрузкой первой страницы, чем серверные приложения. Это происходит потому, что при первой загрузке приходится загружать фреймворк и код приложения, прежде чем визуализировать в браузере нужное представление в виде HTML. Серверному приложению нужно всего лишь отправить требуемый HTML-код браузеру, что уменьшает время ожидания и время загрузки.</p>
<p>Существуют определенные способы ускорения начальной загрузки SPA, такие как довольно тяжеловесный подход кеширования и отложенной загрузки модулей по мере их необходимости. Но вы никогда не сможете избежать загрузки фреймворка, а также по крайней мере части кода приложения и, вероятно, необходимости обратиться к API за данными до отображения чего-либо в браузере.</p>
<p>Следует ли вам беспокоиться по поводу скорости начальной загрузки страницы? Опять-таки скажу: «Зависит от обстоятельств». Это зависит от
того, что именно вы создаете и сколько людей будет взаимодействовать с данным продуктом.</p>
<p>Вспомните Gmail. Gmail представляет собой SPA и требует для загрузки немало времени. Правда, это обычно всего лишь пара секунд, но в наше время в Интернете все нетерпеливы и ожидают немедленного отклика. При этом люди не против подождать загрузки Gmail, ведь в процессе работы он ведет себя адаптивно и быстро. А раз уж вы зашли, то часто остаетесь в нем на какое-то время.</p>
<p>Но если речь идет о блоге, извлекающем информацию из поисковых систем и других внешних источников, не хотелось бы несколько секунд ждать загрузки первой страницы. Посетители в таком случае сочтут, что ваш сайт не работает или работает слишком медленно, и нажмут кнопку Назад, прежде чем у вас появится шанс показать им ваш контент. Готов поспорить, вам это знакомо, ведь вы и сами не раз поступали точно так же!</p>

<h3>SPA или не SPA?</h3>
<p>Напомню, что это не была тренировка в критике SPA, мы просто воспользовались случаем, чтобы подумать о вещах, которые часто откладывают в сторону до тех пор, пока не окажется слишком поздно. Три вопроса, касающихся возможности сканирования, интеграции веб-аналитики и скорости загрузки страницы, не были предназначены для формулировки четких рекомендаций относительно того, когда создавать SPA, а когда — делать что-то иное.</p>
<p>Может оказаться, что ни одна из этих вещей не является проблемой для вашего проекта и что SPA определенно подходящий вариант. Но если вы видите, что каждый вопрос заставляет вас задуматься и, похоже, вам понадобится ввести в приложение обходной маневр для каждого из них, то SPA, наверное, не лучший вариант.</p>
<p>Если же ваш случай где-то посередине, то вам нужно определить для себя, что наиболее важно и, следовательно, что окажется наилучшим решением для
проекта. В качестве эмпирического правила: если ваше решение с самого начала содержит множество обходных маневров, то, вероятно, лучше его пересмотреть.</p>
<p>Даже если вы решили, что SPA вам не подходит, это не значит, что вы не можете использовать стек MEAN. Пойдем дальше и посмотрим на другой вариант архитектуры.</p>

<h2>Разработка гибкой
    архитектуры MEAN</h2>
<p>Использование MongoDB, Express и Node.js вместе только для создания API REST подобно использованию Audi RS6 лишь для того, чтобы возить ребенка в школу. Он обладает отличными возможностями и выполнят эту работу очень хорошо, но при этом способен на большее.</p>
<p>Продемонстрируем это на примере блога.</p>

<h3>Требования к движку блога</h3>
<p>Взглянем на уже знакомую нам идею движка блога и посмотрим, как можно наилучшим образом спроектировать стек MEAN для его создания.</p>
<p>Движок блога обычно включает две части.</p>
<ol>
    <li>ориентированная на публику интерфейсная часть, выдающая читателям статьи, которые, хочется надеяться, будут перепродаваться и распространяться по Интернету</li>
    <li>интерфейс администратора, в который владельцы блогов входят для написания новых статей и управления своими блогами</li>
</ol>
<p>Характеристики этих частей демонстрируются на рис. ниже:</p>
<img src="https://ltdfoto.ru/images/2024/07/07/imagef85eaf74b0088f88.png" alt="imagef85eaf74b0088f88.png" border="0" />
<p>Глядя на списки на рис. выше, легко увидеть высокий уровень конфликтования между характеристиками этих двух частей:</p>
<ul>
    <li>Нужна насыщенная контентом и слабоинтерактивная среда для статей блогов. Статьи блога должны быть быстрозагружаемыми — для снижения показателя отказов. Пользователи обычно задерживаются на записи в блоге ненадолго, но могут захотеть поделиться ею с другими</li>
    <li>Нужна богатая возможностями высокоинтерактивная среда для административного интерфейса. Административная область должна быстро реагировать на действия пользователя и вводимые им данные. Административный интерфейс необщедоступен и отдельный пользователь может работать в нем длительное время</li>
</ul>
<p>Принимая во внимание обсуждавшиеся ранее потенциальные проблемы со SPA и глядя на характеристики записей в блоге, вы можете обнаружить немало совпадений. Вполне вероятно, что с учетом этого вы решите не использовать SPA для выдачи своих записей в блоге читателям. </p>
<p>В то же время SPA отлично подходит для административного интерфейса.</p>
<p>Так что же делать? Возможно, самым важным будет удержание читателей блога — если их впечатления от вашего блога были негативными, они просто не вернутся и не будут делиться записями. Если блог не привлекает, то блогер просто прекратит в него писать или перейдет на другую платформу. Опять-таки медленный и плохо реагирующий административный интерфейс станет причиной того, что владельцы блогов начнут «убегать с корабля». Как можно добиться того, чтобы все были довольны, а движок блога был при деле?</p>


<h3>Архитектура движка блога</h3>
<p>Ответ заключается в том, что не надо искать одно решение на все случаи жизни.</p>
<p>Пусть у вас будет два приложения. У вас есть ориентированный на публику контент, который нужно доставлять непосредственно с сервера, и интерактивный необщедоступный административный интерфейс, который вы хотите выполнить в виде SPA. Давайте рассмотрим каждое из этих приложений по отдельности, начав
с административного интерфейса.</p>

<h4>Административный интерфейс: SPA на AngularJS</h4>
<p>Мы уже обсуждали, что для административного интерфейса идеально подходило бы SPA, построенное на основе AngularJS. Так что архитектура этой части движка будет выглядеть очень знакомо: API REST, построенный на MongoDB, Express и Node.js, с одностраничным приложением на AngularJS в интерфейсной части.</p>
<p>Рис. ниже демонстрирует, как это будет выглядеть.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image7d80e8ddf08d336e.png" alt="image7d80e8ddf08d336e.png" border="0" />
<p>Все приложение построено на AngularJS и выполняется в браузере, а между приложением AngularJS и API REST туда и обратно передаются данные JSON.

<h4>Записи в блоге: что делать?</h4>
<p>Если задуматься о записях в блоге, то все оказывается несколько сложнее.</p>
<p>Представьте себе стек MEAN только как одностраничное приложение на AngularJS, обращающееся к API REST, и вы окажетесь в дураках. Вы можете в любом случае создать интерфейсную часть в виде SPA, раз хотите использовать JavaScript и стек MEAN. Но это не лучшее решение. Вы можете счесть, что стек MEAN просто не подходит для данного случая, и выбрать другой стек технологий.</p>
<p>Но вам ведь этого не надо! Вам нужен просто сплошной JavaScript. Так что взглянем на стек MEAN повнимательнее и подумаем обо всех его компонентах. Вы знаете, что Express — фреймворк веб-приложений. Вы знаете, что Express может использовать <b>шаблонизаторы</b> для создания HTML-кода на сервере.
Вы знаете, что Express может использовать маршрутизацию URL и паттерны MVC.</p>
<p>Вам стоит задуматься: а не в Express ли заключается ответ?</p>

<h4>Записи в блоге: используем Express</h4>
<p>В данном сценарии с блогом доставка HTML-кода и контента непосредственно с сервера — именно то, что вам нужно. Express выполняет это особенно хорошо, даже с самого начала обеспечивает выбор шаблонизаторов. HTML-содержимое потребует данные из БД, так что вы снова используете для этого API REST (подробнее мы рассмотрим, почему это наилучший подход, в следующем подразделе).</p>
<p>Основу такой архитектуры демонстрирует рис. ниже.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image0ad93497ad59251e.png" alt="image0ad93497ad59251e.png" border="0" />
<p>Вы получаете подход, при котором можете использовать стек MEAN или по крайней мере его часть для доставки основанного на базе данных контента непосредственно от сервера к браузеру. Но этим дело не ограничивается. Стек MEAN еще более гибок.</p>

<h4>Записи в блоге: используем стек полнее</h4>
<p>Вы видели приложение Express, выдающее контент блога посетителям. Если вам нужно, чтобы посетители могли заходить на сайт, возможно, для добавления комментариев к статьям, вам необходимо отслеживать сеансы пользователей. Для этого можно использовать MongoDB вместе с вашим приложением на Express.</p>
<p>Можно также рядом с вашими сообщениями в блоге динамически отображать какие-либо данные, например связанные сообщения или поисковое поле с автодополнением, опережающим ввод с клавиатуры. Их можно реализовать с помощью AngularJS. Помните: AngularJS предназначен не только для SPA, его можно использовать также для добавления каких-нибудь интерактивных данных на страницу, которая иначе была бы статической. Рис. ниже показывает, как эти необязательные части MEAN добавляются в архитектуру компонента блога.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/imagee1344bcdd3a62fee.png" alt="imagee1344bcdd3a62fee.png" border="0" />
<p>Теперь вы можете организовать взаимодействие приложения, выдающего посетителям контент и основанного на полном стеке MEAN, с вашим API REST.</p>

<h4>Движок блога: гибридная архитектура</h4>
<p>На этой стадии у нас имеется два отдельных приложения, использующих API REST. Если немного спланировать, это может быть общий API REST, применяемый
обеими частями приложения. Целостность архитектуры с одним API REST, взаимодействующим с двумя приложениями клиентской части, демонстрирует рис. ниже.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/imagef73cb62cfec054c3.png" alt="imagef73cb62cfec054c3.png" border="0" />
<p>Это простой пример демонстрации возможности соединения разнообразных частей стека MEAN в различные архитектуры для удовлетворения требований,
которые предъявляет к вам проект. Возможные варианты ограничиваются лишь вашим знанием компонентов и изобретательностью при их сочетании. Не существует какой-то одной правильной архитектуры для стека MEAN.</p>

<h4>Рекомендуемое решение: создание внутреннего API для слоя данных</h4>

<p>Вероятно, вы обратили внимание на то, что каждый вариант архитектуры включает API, создающий прослойку над данными, и предоставляет основному приложению возможность взаимодействовать с БД. Для этого имеются свои причины.</p>
<p>Если вы собирались начать с построения приложения на Node.js и Express, выдавая HTML-содержимое непосредственно с сервера, было бы очень удобно обращаться к БД прямо из кода приложения Node.js. В краткосрочной перспективе такой подход кажется удобным. Но в долгосрочной перспективе он оказывается более сложным, так как тесно сцепляет ваши данные с кодом приложения таким способом, при котором более ничто не может использовать этот код.</p>
<p>Другой вариант: создать собственный API, способный непосредственно обращаться к БД и выводить нужные вам данные. При этом приложение Node.js может
взаимодействовать с этим API, не обращаясь напрямую к БД. Эти два варианта сравниваются на рис. ниже.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/imagec08bb64241bbb6fd.png" alt="imagec08bb64241bbb6fd.png" border="0" />
<p>Глядя на рис. выше, вы можете удивиться: зачем тратить силы на создание API, который будет просто занимать место между вашим приложением и БД? Может, это просто дополнительная работа? На данном этапе — да, это требует дополнительной работы, но мы взглянем чуть дальше. Что если вам захочется потом использовать свои данные в нативном мобильном приложении? Или, например, в клиентской части на AngularJS?</p>
<p>Вряд ли вам захочется оказаться в положении, когда нужно будет создавать для каждого из них отдельные, хотя и похожие интерфейсы. Этого можно избежать, если заранее создать выводящий нужные вам данные API. Если у вас под рукой есть API при интеграции слоя данных в ваше приложение, можно просто сделать так, чтобы приложение ссылалось на этот API. И неважно, основано ли приложение на Node.js, AngularJS или iOS. Причем API не должен быть общедоступным, главное, чтобы к нему могли обращаться вы. Сравнение двух подходов для приложений Node.js, AngularJS или iOS, использующих один и тот же источник данных, демонстрирует рис. ниже.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image0d74ddd28330b42c.png" alt="image0d74ddd28330b42c.png" border="0" />
<p>Как видно из рис. выше, ранее более простой интегрированный подход теперь оказывается фрагментированным и сложным. Приходится контролировать и сопровождать три отдельные интеграции данных, чтобы сохранить согласованность, любые изменения нужно будет выполнять в нескольких местах. Если же у вас один API, то можно не беспокоиться обо всем этом. Так что, приложив поначалу немного больше усилий, можно сделать свою дальнейшую жизнь намного проще.</p>

<h2>Планирование реального приложения</h2>
<p>Далее мы будем создавать работающее приложение <b>Loc8r</b>, основанное на стеке MEAN. Loc8r будет выводить список расположенных поблизости мест с Wi-Fi, куда можно пойти, чтобы поработать.</p>
<p>Пользователи в нем смогут также отправить свои оценки и отзывы.</p>
<p>Для демонстрационного приложения мы сфабрикуем данные таким образом, чтобы можно было легко и удобно его протестировать. </p>
<p>Итак, приступим к планированию.</p>

<h3>Планирование приложения на высоком уровне</h3>
<p>Сначала обдумаем, какие экраны понадобятся в нашем приложении. Сосредоточим внимание на отдельных представлениях страниц на экране и путях пользователей.</p>
<p>Сделаем это на очень общем уровне, не особо заботясь о деталях того, что находится на каждой странице. Хорошей идеей будет зарисовать этот этап на бумаге или доске для визуализации приложения в целом. Это будет полезно также для систематизации экранов по наборам и потокам и послужит хорошим ориентиром, когда наступит время создавать приложение. Поскольку со страницами не связаны никакие данные и за ними нет логики приложения, можно легко и свободно добавлять и удалять составные части, изменять, что и где отображать, и даже менять количество страниц. Вполне вероятно, что с первого раза не получится правильно, главное — начать и повторять процесс, улучшая все до тех пор, пока вы не будете удовлетворены отдельными страницами и общими путями движения пользователей.</p>

<h4>Планирование экранов</h4>
<p>Приступим. Как уже говорилось, наша цель следующая: приложение Loc8r будет выводить список расположенных поблизости мест с Wi-Fi, куда можно пойти, чтобы поработать. Оно также отображает наличие удобств, время начала работы, рейтинг и схему проезда. Пользователи получат возможность отправлять свои оценки и отзывы.</p>
<p>Из этого можно сделать вывод о том, что нам потребуются:</p>
<ul>
    <li>экран со списком близлежащих мест с Wi-Fi;</li>
    <li>экран, выводящий подробности относительно конкретного места;</li>
    <li>экран для добавления отзыва о месте</li>
</ul>
<p>Вероятно, нам понадобится также сообщить посетителям, для чего предназначено Loc8r и откуда оно взялось, так что не помешает добавить в список еще одну форму — экран для информации <i>About</i> (<i>О нас</i>).</p>

<h4>Распределение экранов по наборам</h4>
<p>Далее нам нужно взять список экранов и упорядочить их в соответствии с тем, как они относятся друг к другу. Например, первые три экрана в списке связаны с местом
расположения. Страница <i>About</i> <i>(О нас</i>) ни с чем не связана, так что ее можно отнести к смешанному набору <i>Others</i> (<i>Другие</i>). Зарисовка схемы даст нам что-то вроде рис. ниже.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image34ddba9f646e79d2.png" alt="image34ddba9f646e79d2.png" border="0" />
<p>Подобный быстрый набросок — первый этап планирования, и нам нужно выполнить его, прежде чем начать думать об архитектуре. Этот этап дает нам возможность взглянуть на основные страницы, а заодно обдумать пути движения пользователей. Рисунок выше, например, демонстрирует также основной путь пользователя в наборе <i>Locations</i> (<i>Место расположения</i>): переход со страницы <i>List</i> (<i>Список</i>) на страницу <i>Details</i> (<i>Подробности</i>), а затем в форму для добавления отзыва.</p>

<h4>Проектирование архитектуры приложения</h4>
<p>На первый взгляд Loc8r довольно простое приложение всего с несколькими экранами. Но нам все равно необходимо обдумать его архитектуру, так как мы собираемся передавать данные из БД в браузер, позволять пользователям взаимодействовать с данными и обеспечить возможность обратной отправки данных в БД.</p>

<h5>Начнем с API</h5>
<p>Поскольку приложение собирается использовать БД и передавать данные, разумно начать проектировать архитектуру с той части, которая определенно будет нам необходима. Отправной пункт — API REST, созданный с помощью Express и Node.js для обеспечения возможности взаимодействия с базой данных MongoDB, демонстрирует рис. ниже.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/imagea7681c7ff123a528.png" alt="imagea7681c7ff123a528.png" border="0" />
<p>Как уже обсуждалось в этой главе, создание API для обмена данными предопределено и является основным пунктом архитектуры. Так что обратимся к более интересному и сложному вопросу: каким образом мы будем проектировать архитектуру самого приложения?</p>

<h3>Варианты архитектуры приложения</h3>
<p>На этой стадии нам нужно взглянуть на то, чего конкретно требует наше приложение, и решить, как следует объединять части стека MEAN с целью создания наилучшего решения. Необходимо ли нам что-то специфическое от MongoDB, Express, AngularJS и Node.js, такое, что может существенно повлиять на наши решения?
Хотим ли мы, чтобы HTML-содержимое выдавалось непосредственно с сервера, или SPA будет лучшим вариантом?</p>
<p>Что касается Loc8r, то каких-либо необычных или специальных требований у него нет, а желаемая степень удобства сканирования поисковыми системами зависит от бизнес-плана по развитию. Если цель состоит в привлечении органического трафика от поисковых систем, то да, возможность сканирования необходима. Если же цель заключается в продвижении приложения как такового, то видимость его для поисковых систем менее важна.</p>

<p>Возвращаясь к примеру с блогом, можно сразу же наметить три возможные архитектуры приложения, как показано на рис. ниже.</p>
<ol>
    <li>Приложение на Node.js и Express.</li>
    <li>Приложение на Node.js и Express с дополнениями на AngularJS для интерактивности.</li>
    <li>SPA на AngularJS.</li>
</ol>

<img src="https://ltdfoto.ru/images/2024/07/07/image999dbc03cdae3c9b.png" alt="image999dbc03cdae3c9b.png" border="0" />

<h3>Выбор архитектуры приложения</h3>
<p>Каких-либо особых бизнес-требований, которые заставляли бы нас предпочесть
один из вариантов архитектуры другому, отсутствуют. Впрочем, это несущественно, поскольку мы собираемся реализовать в книге все три варианта.</p> <p>
Построение всех трех архитектур позволит нам изучить работу каждого из подходов и даст возможность взглянуть по очереди на каждую из технологий, создавая приложение
слой за слоем.</p>
<p>Мы будем создавать эти архитектуры в порядке, показанном на рис. выше, начиная с приложения на Node.js и Express. Затем перейдем к добавлению некоторого
количества кода на AngularJS, прежде чем переделать его в SPA на AngularJS. </p>
Хотя при обычных условиях вы не станете разрабатывать сайт подобным образом, это даст вам отличную возможность изучить все тонкости стека MEAN.

<h3>Заключаем все в проект Express</h3>
<p>Схемы архитектуры, которые мы видели до сих пор, подразумевали наличие у нас
отдельных приложений Express для API и логики приложения. Это вполне возможно и хорошо подходит для большого проекта. Если мы ожидаем больших объемов трафика, то даже можем захотеть разместить главное приложение и API на
отдельных серверах. Дополнительная выгода от этого — возможность задавать для
каждого из серверов и приложений особые настройки, лучше приспособленные
для их индивидуальных нужд.</p>
<p>Другой способ более прост, при его реализации все содержится в одном проекте Express. В этом случае нам нужно думать о размещении и развертывании
только одного приложения и управлении лишь одним набором исходного кода.
Именно так мы и поступим с Loc8r, используя один проект Express, содержащий
несколько подприложений. Данный подход проиллюстрирован на рис. ниже.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image6e2eb290aa6bce83.png" alt="image6e2eb290aa6bce83.png" border="0" />
<p>При компоновке приложения таким образом важно хорошо организовать код,
чтобы различные части приложения хранились отдельно от других. Это облегчит
не только сопровождение кода, но и разбиение его в будущем на отдельные проекты, если вы сочтете это необходимым. Такова основная тема, к которой мы будем
возвращаться на протяжении всей книги.</p>


<h3>Разбиваем разработку на этапы</h3>
<p>Мы ставим перед собой две цели:</p>
<ul>
    <li>создать приложение на основе стека MEAN;</li>
    <li>по ходу дела изучить различные слои стека.</li>
</ul>
<p>Мы подходим к проекту так, как я сам сделал бы при ускоренной разработке,
но с несколькими поправками, чтобы вы лучше рассмотрели стек в целом. Начнем
с <b>пяти этапов ускоренной разработки прототипа</b>, а затем посмотрим на использование этого подхода для построения Loc8r слой за слоем, в процессе работы сосредотачиваясь на различных технологиях.</p>

<h3>Этапы ускоренной разработки прототипа</h3>
<p>Давайте разобьем процесс на несколько этапов, концентрируя усилия на одной
части за раз, что увеличит наши шансы на успех. Подобный подход отлично позволяет претворять идеи в жизнь.</p>
<h4>Этап 1. Создание статического сайта</h4>
<p>Первый этап заключается в создании статической версии приложения, по сути
представляющей собой набор HTML-страниц. <b>Цели этого этапа:</b></p>
<ul>
    <li>быстро придумать макет;</li>
    <li>убедиться, что пути движения пользователей логичны.</li>
</ul>
<p>На данном этапе нас не волнуют вопросы базы данных или показуха в пользовательском интерфейсе. Все, что мы хотим, — создать работающий макет основных экранов и путей, которые пользователь будет проходить в приложении.</p>

<h4>Этап 2. Проектирование модели данных и создание БД</h4>
<p>Как только мы получили устраивающий нас работающий статический прототип,
следующей задачей становится поиск в статическом приложении любых жестко
зашитых данных и помещение их в БД. <b>Цели этого этапа:</b></p>
<ul>
    <li>описать модель данных, отражающую требования приложения;</li>
    <li>создать БД для работы с моделью.</li>
</ul>
<p>Автор использует понятие «<i>модель данных</i>» в смысле, приближенном к смыслу выражения «<i>модель базы данных</i>», хотя большинство специалистов сейчас понимают под ней инструмент, а не конечный результат.</p>
<p>Первая цель — описание модели данных. Взглянем еще раз на наш проект
с высоты птичьего полета и попробуем ответить на вопросы: данные о каких объектах нам требуются, как эти объекты взаимосвязаны и какие данные в них содержатся?</p>
<p>Если бы мы реализовывали этот этап до создания статического прототипа,
то имели бы дело с абстрактными понятиями и идеями. Теперь, когда у нас есть
прототип, мы видим, что происходит на различных страницах и где какие данные нужны. Внезапно этот этап значительно упрощается. Сами того не замечая, мы выполнили всю тяжелую часть анализа при создании статического
прототипа.</p>
<h4>Этап 3. Создание API данных</h4>
<p>После выполнения этапов 1 и 2 в нашем распоряжении оказывается, с одной стороны, статический сайт, а с другой — база данных. На этом этапе и следующем за
ним мы выполним очевидные шаги по их связыванию между собой.
Цель этапа 3 — создать API REST, который позволил бы нашему приложению
взаимодействовать с БД.</p>
<h4>Этап 4. Привязка БД к приложению</h4>
<p>При переходе к данному этапу мы имели статическое приложение и API, предоставляющее интерфейс к БД. <b>Цель этапа</b> — сделать так, чтобы приложение взаимодействовало с API.</p>
<p>После завершения этого этапа приложение практически не изменится, но из БД
будут поступать данные, так что наше приложение превратится в приложение,
ориентированное на работу с данными!</p>
<h4>Этап 5. Расширение приложения</h4>
<p>Этот этап всецело посвящен снабжению приложения дополнительной функциональностью. Можно добавить системы аутентификации, проверки данных или
методы отображения сообщений об ошибках пользователю. Он может также
включать добавление дополнительной интерактивности в клиентской части или
усиление бизнес-логики в самом приложении. Итак, фактически <b>цели данного
этапа:</b></p>
<ul>
    <li>добавить заключительные штрихи к нашему приложению;</li>
    <li>довести приложение до готовности к реальному использованию.</li>
</ul>
<p>С обеспечиваемой этими пятью этапами великолепной методологией можно
приступить к созданию нового проекта. Давайте рассмотрим, как именно мы будем
следовать им при построении Loc8r.</p>

<h2>Шаги создания Loc8r</h2>
При построении Loc8r на протяжении этой книги мы преследуем две цели:
<ol>
    <li>Во-первых,
        конечно, мы хотим создать работающее приложение на основе стека MEAN.</li>
    <li>Во-вторых,
        хотим изучить различные технологии, понять, как их использовать и как сочетать
        разными способами.</li>
</ol>
<p>Так что на протяжении этой книги мы будем придерживаться пяти этапов разработки, но с некоторыми отклонениями, чтобы увидеть в действии весь стек.
Прежде чем подробно рассмотреть дальнейшие шаги, вкратце напомню предлагаемую архитектуру (рис. ниже).</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image536a6bbfe8144a5d.png" alt="image536a6bbfe8144a5d.png" border="0" />

<h3>Шаг 1. Создание статического сайта</h3>
<p>Мы начнем с этапа 1 и создадим статический сайт. Я советую делать это для любого приложения или сайта, так как при этом можно многое узнать, затратив сравнительно небольшие усилия. При создании статического сайта уместно будет ориентироваться на будущее и иметь в виду, какой должна быть итоговая архитектура.</p>
<p>Я уже описал архитектуру Loc8r, на основе этой архитектуры создадим статическое приложение на Node и Express, используя его в качестве отправной точки работы со стеком MEAN. Этот шаг в нашем процессе выделен (рис. ниже) как первая часть разработки предлагаемой архитектуры.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/imagec689e55687bf1ff2.png" alt="imagec689e55687bf1ff2.png" border="0" />


<h3>Шаг 2. Проектирование модели данных и создание БД</h3>
<p>Продолжим следовать этапам разработки и перейдем к этапу 2 — создадим БД
и спроектируем модель данных. Опять-таки этот шаг, вероятно, понадобится любому
приложению, но вы извлечете из него гораздо больше, если сначала сделаете шаг 1.</p>
<p>Дополнения, вносимые этим шагом в общую картину построения архитектуры
приложения, иллюстрирует рис. ниже.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image02c5af6f2e3b79b6.png" alt="image02c5af6f2e3b79b6.png" border="0" />
<p>В стеке MEAN на этом шаге будем использовать MongoDB, существенно опираясь при моделировании данных на Mongoose. Сами модели данных будут при этом
описаны в приложении Express.</p>
<h3>Шаг 3. Построение API REST</h3>
<p>После создания БД и описания моделей данных нам понадобится создать API REST
таким образом, чтобы получить возможность взаимодействовать с данными посредством обращений через Интернет. Практически любому ориентированному на
работу с данными приложению будет полезно наличие API, так что и этот шаг вам
нужно будет сделать в большинстве проектов.</p>
<p>На рис. ниже вы можете увидеть, как именно этот шаг вписывается в процесс
построения проекта в целом.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image618acaa6bc4a435c.png" alt="image618acaa6bc4a435c.png" border="0" />
<p>В стеке MEAN этот шаг обычно выполняется с помощью Node.js и Express с изрядной долей помощи со стороны Mongoose. Мы будем чаще использовать Mongoose
для сопряжения с MongoDB, чем работать с MongoDB напрямую.</p>





<h3>Шаг 4. Использование API из приложения</h3>
<p>Этот шаг соответствует этапу 4 процесса разработки. Именно сейчас Loc8r начинает оживать. Статическое приложение из шага 1 будет модернизировано для использования API REST из шага 3 для взаимодействия с БД, созданной на шаге 2 (рис. ниже).</p>
<p>Чтобы изучить все части стека и различные способы их применения, мы воспользуемся Express и Node.js для выполнения обращений к API. Если в реальном сценарии вы планируете создать большую часть приложения на AngularJS, то можно взамен этого привязать вашу БД к AngularJS. </p>
<img src="https://ltdfoto.ru/images/2024/07/07/image68572c56d5d545e8.png" alt="image68572c56d5d545e8.png" border="0" />

<h3>Шаг 5. Украшаем приложение</h3>
<p>Шаг 5 соответствует этапу 5 процесса разработки, на котором мы добавляем к приложению дополнительные штрихи. Воспользуемся этим шагом, чтобы взглянуть
на AngularJS, и увидим, как можно интегрировать компоненты AngularJS в приложение Express.</p>
<p>Это дополнение к архитектуре проекта отмечено на рис. ниже.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/imaged1337f1dc65a8caa.png" alt="imaged1337f1dc65a8caa.png" border="0" />
<p>Этот шаг всецело посвящен знакомству с AngularJS и его использованию.
Для данной цели мы, вероятнее всего, поменяем некоторые из наших настроек
Node.js и Express. </p>
<h3>Шаг 6. Переделываем код в SPA на AngularJS</h3>
<p>На шаге 6 мы собираемся в корне изменить архитектуру путем замены приложения
Express и переноса всей его логики в SPA, использующее AngularJS. В отличие от
всех предыдущих шагов эти действия будут скорее не создавать что-то новое на
основе предыдущих шагов, а замещать старое.</p>
<p>При обычном построении такой шаг — разработать приложение на Express,
а затем переделать его на AngularJS — был бы странным, но для учебного процесса он отлично подходит. Мы сможем при этом сосредоточиться на AngularJS,
так как уже знаем, что должно делать приложение, и у нас имеется готовый API
данных.</p>
<p>Влияние этого изменения на архитектуру в целом демонстрирует рис. ниже.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image601bce29aa83e8cd.png" alt="image601bce29aa83e8cd.png" border="0" />
<h3>Шаг 7. Добавляем аутентификацию</h3>
<p>На шаге 7 мы добавим в приложение функцию аутентификации и предоставим
пользователям возможность зарегистрироваться и войти на сайт, а также посмотрим, как применять данные пользователей во время того, как они работают с приложением. Мы будем основываться на всем, что сделали до сих пор, и добавим
аутентификацию к SPA на AngularJS. В качестве части этого мы сохраним информацию о пользователе в БД и обезопасим некоторые конечные точки, чтобы с ним
могли работать только аутентифицированные пользователи.</p>
<p>Рисунок ниже демонстрирует, с чем мы будем иметь дело с точки зрения архитектуры.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image8e74708beec8705f.png" alt="image8e74708beec8705f.png" border="0" />

<h2>Аппаратное обеспечение для промышленной эксплуатации</h2>
<p>Никакое обсуждение архитектуры не было бы полным без раздела об аппаратном
обеспечении. Вы уже видели, каким образом можно свести воедино все программное обеспечение и компоненты кода, но какое аппаратное обеспечение понадобится для работы всего этого?</p>
<p>Подход к промышленной аппаратной архитектуре не сильно отличается от подхода
к стандартному аппаратному обеспечению для разработки. Основное отличие—промышленное аппаратное обеспечение обычно более мощное и в нем открыт доступ
в Интернет, для того чтобы можно было получать запросы от широкой аудитории.
Вполне допустимо разместить и выполнять все части вашего приложения на одном
и том же сервере. Основная схема приведена на рис. ниже.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/imagec2b250089c3cb6fd.png" alt="imagec2b250089c3cb6fd.png" border="0" />
<p>Такая архитектура подходит для приложений с небольшими объемами трафика, но обычно не рекомендуется при увеличении приложения, чтобы приложению
и БД не приходилось бороться за одни и те же ресурсы.</p>

<h3>Рост приложения: отдельный сервер БД</h3>
<p>Часто БД одной из первых переносится на отдельный сервер. Так что теперь у вас
будет два сервера: один для приложения и второй — для БД. Этот подход проиллюстрирован на рис. ниже.</p>
<p>Это весьма распространенная модель, особенно если вы решили использовать
для своего хостинга провайдера платформы как услуги (PaaS). В книге мы будем
применять этот подход.</p>
<img src="https://ltdfoto.ru/images/2024/07/07/image46ea20d1cec7c68d.png" alt="image46ea20d1cec7c68d.png" border="0" />

<h3>Масштабируемся</h3>
<p>Аналогично тому, что мы говорили по поводу аппаратного обеспечения для разработки, можно выделить отдельные серверы для различных частей: сервер БД,
сервер API и сервер приложения. Это даст возможность обрабатывать большие
объемы трафика за счет распределения нагрузки по трем серверам.</p>

