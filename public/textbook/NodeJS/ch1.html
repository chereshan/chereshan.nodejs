<!--<title>Глава 1. Введение в NodeJS</title>-->
<h1>Глава 1. Введение в NodeJS</h1>

<h2>История Node.js</h2>
<p>В 2009 г., спустя годы после осознания программистами мощи и выразительности JavaScript как языка написания клиентских скриптов, <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D0%BB%D1%8C,_%D0%A0%D0%B0%D0%B9%D0%B0%D0%BD">Райан Даль</a> разглядел потенциал JavaScript как серверного языка и создал Node.js. </p>
<p>Это было плодотворное время для интернет-технологий. <i>Ruby</i> (а также <i>Ruby on Rails)</i> заимствовал немало отличных идей из теории вычислительной техники, объединив их с некоторыми собственными новыми идеями, и продемонстрировал миру более быстрый способ создания сайтов и веб-приложений. </p>
<p>Корпорация Microsoft в героической попытке прийти в соответствие эпохе Интернета сделала с <i>.NET</i> удивительные вещи, учтя ошибки не только Ruby on Rails, но и языка Java.</p>
<p>Сегодня благодаря технологиям транскомпиляции, таким как Babel, веб-разработчики могут свободно использовать самые последние функции языка JavaScript, не боясь оттолкнуть пользователей с более старыми браузерами.
Webpack стал универсальным решением для управления зависимостями в веб-приложениях и обеспечения производительности. Такие фреймворки, как React,
Angular и Vue, меняют подход к веб-разработке, а библиотеки для работы с декларативной объектной моделью документов (DOM) (такие как jQuery) — это уже
вчерашний день.</p>


<h2>Что такое Node?</h2>
<p><b>Node.js</b> — асинхронная управляемая событиями исполнительная платформа
JavaScript с мощной, но компактной стандартной библиотекой. </p>
<p>Среда <b>Node</b> — это JavaScript с привязками к лежащей в основе операционной системе (ОС), что делает возможным написание программ на JavaScript, которые выполняют чтение и запись файлов, запускают дочерние процессы и взаимодействуют через сеть. В результате среда Node пригодна в качестве:</p>
<ul>
    <li>современной альтернативы сценариям командной оболочки, которая не обладает загадочным синтаксисом <span class="code">bash</span> и других оболочек <i>Unix</i>;</li>
    <li>универсального языка программирования для выполнения доверенных программ, не подверженного ограничениям безопасности, которые веб-браузеры налагают на ненадежный код;</li>
    <li>популярной среды для написания эффективных веб-серверов с высокой степенью параллелизма.</li>
</ul>
<p>Определяющей характеристикой среды Node является ее однопоточный основанный на событиях параллелизм, обеспечиваемый по умолчанию асинхронным API-интерфейсом.</p>
<p>Помимо исполняемого файла <span class="code">Node</span> установка Node также включает <span class="code">npm</span> — диспетчер пакетов, который обеспечивает легкий доступ к обширной экосистеме инструментов и библиотек JavaScript. В примерах настоящей главы будут применяться только встроенные пакеты Node, a <span class="code">npm</span> или любые внешние библиотеки не потребуются.</p>
<p>Сопровождением и поддержкой Node занимается <i>Node.js Foundation </i>— отраслевой консорциум с открытой моделью управления. Существует две активно поддерживаемые версии Node: текущая (Current) и пользующаяся долгосрочной поддержкой (LTS, Long Term Support).</p>

<h2>Почему Node?</h2>
<h3>Node проще аналогов</h3>
<p>В некотором смысле у Node много общего с другими популярными веб-серверами,
такими как разработанный Microsoft веб-сервер <i>Internet Information Services</i> (IIS) или <i>Apache</i>. Но интереснее узнать, в чем его отличия. Так что начнем с этого.</p>
<p>Аналогично Express подход Node к веб-серверам чрезвычайно минималистичен.
В отличие от IIS или Apache, для освоения которых могут понадобиться годы,
Node легок в установке и настройке. Это не значит, что настройка серверов Node
на максимальную производительность в условиях промышленной эксплуатации
тривиальна, просто конфигурационные опции проще и яснее.</p>

<h3>Однопоточность</h3>
<!--todo: не разъяснено что такое однопоточность-->
<p>Другое базовое различие между Node и более традиционными веб-серверами —
<b>однопоточность</b> Node. Сначала это может показаться шагом назад, но впоследствии становится ясно, что это гениальная идея. </p>
<p><b>Однопоточность чрезвычайно упрощает задачу написания веб-приложений, а если вам требуется производительность многопоточного приложения, можете просто запустить больше экземпляров Node и, в сущности, получить преимущества многопоточности</b>.</p>
<p>Дальновидный читатель, вероятно, посчитает это каким-то шаманством. В конце концов, разве реализация многопоточности с помощью серверного параллелизма (в противоположность параллелизму приложений) просто не перемещает сложность в другое место вместо ее устранения? Возможно, но опыт говорит о том, что сложность оказывается перемещенной именно туда, где она и должна быть. Более того, с ростом популярности облачных вычислений и рассмотрения серверов как обычных товаров этот подход становится более разумным.</p>
<p>IIS и Apache, конечно, мощные веб-серверы, разработанные для того, чтобы выжимать из современного сильнейшего аппаратного обеспечения производительность до последней капли. Это, однако, имеет свою цену: чтобы добиться такой производительности, для их установки и настройки работникам необходима высокая квалификация.</p>

<h3>Способ написания приложений Node</h3>
<p>Если говорить о способе написания приложений, то <b>приложения Node больше похожи на приложения PHP или Ruby, чем на приложения .NET или Java</b>. Движок JavaScript, используемый Node (V8, разработанный компанией Google), не только компилирует JavaScript во внутренний машинный код (подобно C или C++), но и делает это прозрачным образом (это часто называется компиляцией на лету или <i>JIT-компиляцией</i>), так что с точки зрения пользователя код ведет себя как чистый интерпретируемый язык программирования. Отсутствие отдельного шага компиляции уменьшает сложность обслуживания и развертывания: достаточно просто обновить файл JavaScript, и ваши изменения автоматически станут доступны.</p>

<h3>Независимость от платформы</h3>
<p>Другое захватывающее достоинство приложений Node — невероятная независимость Node от платформы. Это не первая и не единственная платформонезависимая серверная технология, но независимо от платформы важнее предлагаемое разнообразие платформ, чем сам факт ее наличия. </p>
<p>Например, вы можете запустить приложение .NET на сервере под управлением Linux с помощью Mono, но это очень нелегкая задача ввиду разнородности документации и системной несовместимости.</p>
<p>Аналогично можете выполнять PHP-приложения на сервере под управлением Windows, но их настройка обычно не так проста, как на машине с Linux. </p>
<p>В то же время Node элементарно устанавливается на всех основных операционных системах (Windows, OS X и Linux) и облегчает совместную работу. Для команд веб-разработчиков смесь PC и компьютеров Macintosh вполне обычна.</p>
<p>Определенные платформы, такие как .NET, задают непростые задачи разработчикам и дизайнерам клиентской части приложений, часто использующим компьютеры Macintosh, что серьезно сказывается на совместной работе и производительности труда. Сама идея возможности подключения работающего сервера на любой операционной системе за считаные минуты (или даже секунды!) — мечта, ставшая реальностью.</p>

<h3>Событийно-ориентированное программирование</h3>
<p>Базовым принципом Node является <b>событийно-ориентированное программирование</b>. Для вас как программиста это означает необходимость понимать, какие события вам доступны и как на них реагировать. Многие люди знакомятся с событийно-ориентированным программированием в процессе реализации пользовательского интерфейса: пользователь что-то нажимает — и вы обрабатываете событие клика.</p>
<p>Это хороший способ, но очевидно, что программист не контролирует момент, когда пользователь что-то нажимает или собирается нажать, поэтому событийно-ориентированное программирование должно быть интуитивно понятным. Мысленный переход к реагированию на события на сервере может оказаться чуть более сложным, но и здесь принцип прежний.</p>

<h2>Экосистема Node</h2>
<p>В сердцевине стека, конечно, находится Node. Это программное обеспечение, которое позволяет выполнять JavaScript-код на сервере без участия браузера, что, в свою очередь, позволяет использовать фреймворки, написанные на JavaScript, такие как <b>Express</b>. </p>
<p>Другим важным компонентом является база данных. Все веб-приложения, кроме самых простых, потребуют базы данных, и существуют базы данных, которые лучше других подходят экосистеме Node.</p>
<p>Ничего удивительного, что имеются интерфейсы для всех ведущих реляционных баз данных (<i>MySQL</i>, <i>MariaDB</i>, <i>PostgreSQL</i>, <i>Oracle</i>, <i>SQL Server</i>): было бы глупо пренебрегать этими признанными китами. </p>
<p>Однако наступление эпохи разработки под Node дало толчок новому подходу к базам данных — появлению так называемых <b>NoSQL</b>-баз данных. Не всегда полезно давать чему-либо определение через то, чем оно не является, так что я добавлю, что эти NoSQL-базы данных корректнее было бы называть <b>документо-ориентированными базами данных</b> или базами данных
типа «<span class="code">ключ — значение</span>». Они реализуют более простой с понятийной точки зрения подход к хранению данных. </p>
<p>Таких баз данных множество, но <b>MongoDB</b> — одна из лидеров.</p>
<h3>Стеки технологий с Node.js</h3>
<p>Поскольку создание работоспособного сайта зависит сразу от нескольких технологических составляющих, были придуманы акронимы для описания стека, на котором основан сайт. Например, сочетание <span class="code">Linux+Apache+MySQL+PHP</span> именуется стеком <span class="code">LAMP</span>. </p>
<p>Валерий Карпов, программист из MongoDB, изобрел акроним <span class="code">MEAN</span>: <span class="code">Mongo</span>, <span class="code">Express</span>, <span class="code">Angular</span> и <span class="code">Node</span>. Действительно легко запоминающийся, он имеет и свои ограничения: существует столько разных вариантов выбора баз данных и инфраструктуры разработки приложений, что MEAN не охватывает всего разнообразия экосистемы (а также оставляет за скобками то, что я считаю важным компонентом, — <i>механизм рендеринга</i>).</p>
<p>Придумывание включающего в себя все это акронима — интересная задача.</p>
<p>Обязательный компонент, конечно, Node. Хотя есть и другие серверные JavaScript-контейнеры, Node становится преобладающим. Express тоже не единственный доступный фреймворк веб-приложений, хотя он и приближается к Node по распространенности. </p>
<p>Два других компонента, обычно существенных для разработки веб-приложений, — <b>сервер баз данных</b> и <b>механизм рендеринга</b> (это либо <b>шаблонизатор</b> наподобие Handlebars, либо <b>фреймворк одностраничных приложений</b> типа React). Для двух последних компонентов очевидных лидеров нет, так что здесь, я полагаю, было бы неверно налагать какие-то ограничения.</p>


<h2>Установка Node</h2>
<p>Начать установку Node проще всего со страницы <a href="https://nodejs.org/en/download/package-manager">Downloads</a> проекта Node.js.
С этой страницы можно загрузить двоичные файлы (заранее откомпилированные исполняемые файлы) для Windows, OS X, SunOS, Linux и ARM. Страница
также предоставляет доступ к установочным программам для конкретных
архитектур, которые могут очень сильно упростить процесс установки, особенно для Windows. Если ваше окружение подготовлено к сборке, загрузите
исходный код и постройте Node напрямую. Для сервера Ubuntu я предпочитаю использовать именно этот вариант.</p>
<p>Если вы решите компилировать Node прямо на своей машине, вы должны
настроить правильную среду сборки и установить необходимые инструменты
сборки. Например, в Ubuntu (Linux) установка инструментов, необходимых
для Node, выполняется следующей командой:</p>
<pre><code >apt-get install make g++ libssl-dev git</code></pre>

<h2>Простой веб-сервер с помощью Node</h2>
<p>Если вы когда-либо создавали статический сайт или работали с PHP или ASP,
вероятно, вам привычна идея веб-сервера (например, Apache), выдающего статические файлы таким образом, что браузер может видеть их по сети. Например, если вы создаете файл <span class="code">about.html</span> и помещаете его в соответствующий каталог, то можете затем перейти по адресу <span class="code">http://localhost/about.html</span>. В зависимости от настроек веб-сервера вы можете даже опустить <span class="code">.html</span>, но связь между URL и именем файла очевидна: веб-сервер просто знает, где на компьютере находится файл, и выдает его браузеру.</p>
<p>Node предлагает парадигму, отличную от той, что имеет обычный веб-сервер:
создаваемое вами приложение и является веб-сервером. Node просто обеспечивает
вас фреймворком для создания веб-сервера.</p>
<p>Возможно, вы скажете: <i>«Но я же не хочу писать веб-сервер!»</i> Это вполне
естественная реакция: вы хотите писать приложение. Однако Node превращает
написание этого веб-сервера в простейшее действо (иногда всего несколько строк), и контроль над вашим приложением, который вы получаете взамен, более чем стоит того.</p>

<h3>"Hello, world!"</h3>
<p>Начнем с традиционного.</p>
<pre><code >const http = require('http');

http.createServer(function(request, response) {
    response.writeHead(200, {'Content-Type': 'text/plain'});
    response.end('Hello World\n');
}).listen(8124);

console.log('Server running at http://127.0.0.1:8124/');</code></pre>
<p>JavaScript создает веб-сервер, который при обращении к нему из браузера выводит веб-страницу со словами <i>«Hello, World»</i>.</p>
<p>Сначала программа включает необходимый для запуска простого сервера HTTP-модуль с подходящим именем <span class="code">http</span>. Внешняя функциональность Node подключается при помощи модулей, экспортирующих определенные типы функциональности, которая может использоваться в приложении (или другом модуле). Модули очень похожи на библиотеки в других языках программирования.</p>
<p>Модуль импортируется командой Node <span class="code">require</span>, а результат присваивается локальной переменной. После импортирования локальная переменная может использоваться для создания экземпляра веб-сервера функцией <span class="code">http.createServer()</span>. В параметрах функции встречается одна из фундаментальных
конструкций Node: <b>функция обратного вызова</b> (<i>callback</i>). Эта
анонимная функция передает веб-запрос и ответ коду, который обрабатывает
веб-запрос и предоставляет ответ.</p>
<p>Напомним, что JavaScript — <b>однопоточный</b> (<i>single-threaded</i>) язык, и поэтому для имитации асинхронного выполнения в Node используется цикл событий, а функции обратного вызова вызываются при срабатывании определенного события. В примере выше функция обратного вызова вызывается при получении веб-запроса.</p>
<p>Сообщение <span class="code">console.log()</span> выводится на терминал сразу же при вызове создания сервера. Программа не прекращает работу в блокирующем режиме, ожидая веб-запроса.</p>
<p>После того как сервер будет создан и получит запрос, функция обратного
вызова передает браузеру простой текстовый заголовок с кодом статуса 200,
выводит сообщение <span class="code">Hello World</span> и завершает ответ.</p>
<p>Даже лучше присвоить экземпляр сервера константной переменной и переписать наш пример следующим образом: </p>
<pre><code >const http = require('http')
const port = process.env.PORT || 3000
const server = http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/plain' })
    res.end('Hello world!')
})
server.listen(port, () => console.log(`сервер запущен на порте ${port};\n` +`http://localhost:${port}\n`+ 'нажмите Ctrl+C для завершения...'))</code></pre>
<p>В этом примере кода событие неявное: обрабатываемое событие — HTTP-запрос. Метод <span class="code">http.createServer</span> принимает функцию в качестве аргумента, она будет вызываться каждый раз при выполнении HTTP-запроса. Наша простая программа просто устанавливает в качестве типа содержимого неформатированный текст и отправляет строку <span class="code">Hello world!</span>.</p>

<h3>Расширяем "Hello, world!"</h3>
<p>Расширим пример, включив в него обработку входящего запроса. Имя выделяется из строки и используется для определения типа возвращаемого контента. Почти для любого имени будет возвращен персонализированный ответ, но если использовать в запросе параметр <span class="code">name=burningbird</span>, вы получите изображение.</p>
<p>Если строка запроса не используется или в нем не указано имя, переменной
<span class="code">name</span> присваивается значение <span class="code">'world'</span>.</p>

<pre><code>const http = require('http');
const fs = require('fs');
http.createServer(function (req, res) {
    var name = require('url').parse(req.url, true).query.name;
    if (name === undefined) name = 'world';
    if (name == 'burningbird') {
        var file = 'phoenix5a.png';
        fs.stat(file, function (err, stat) {
            if (err) {
            console.error(err);
            res.writeHead(200, {'Content-Type': 'text/plain'});
            res.end("Sorry, Burningbird isn't around right now \n");
        } else {
            var img = fs.readFileSync(file);
            res.contentType = 'image/png';
            res.contentLength = stat.size;
            res.end(img, 'binary');
        }
    });
    } else {
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end('Hello ' + name + '\n');
    }
}).listen(8124);</code></pre>
<p>В начале кода в приложение включается новый модуль с именем <span class="code">fs</span>. Это модуль файловой системы (<i>File System</i>), с которым вы близко познакомитесь в последующих главах. Но при этом в программе импортируется еще один модуль, но не так, как два других:
свойства экспортируемых модулей могут объединяться в цепочки, что позволяет импортировать модуль и использовать его функции в одной строке. Это
часто происходит в модуле <span class="code">url</span>, единственная цель которого — предоставить инструменты для работы с URL-адресами.</p>
<p>Имена параметров ответа (<i>response</i>) и запроса (<i>request</i>) для удобства часто сокращаются до <span class="code">res</span> и <span class="code">req</span> соответственно. После разбора запроса для получения значения <span class="code">name</span> программа сначала проверяет, равен ли параметр <span class="code">undefined</span>.</p>
<p>Если параметр не определен, используется значение по умолчанию <span class="code">world</span>. Если же значение <span class="code">name</span> существует, оно снова проверяется и сравнивается с <span class="code">burningbird</span>. Если значения не совпадают, то приложение возвращает почти такой же ответ, как в исходном приложении, не считая того, что в возвращаемое сообщение подставляется переданное имя.</p>
<p>Но если параметр <span class="code">name</span> содержит строку <span class="code">burningbird</span>, это означает, что вместо текста придется иметь дело с изображением. Метод <span class="code">fs.stat()</span> не только
проверяет, что файл существует, но также возвращает объект с информацией
о файле, включающей его размер. Значение используется для создания заголовка контента.</p>
<p>Если файл не существует, то приложение корректно обрабатывает ситуацию:
оно выводит дружелюбное сообщение об ошибке и информацию на консоль,
для чего на этот раз используется метод <span class="code">console.error()</span>:</p>
<pre><code >{ [Error: ENOENT: no such file or directory, stat 'phoenix5a.png']
errno: -2,
code: 'ENOENT',
syscall: 'stat',
path: 'phoenix5a.png'}</code></pre>
<p>Если файл существует, то изображение загружается в переменную и возвращает его в ответе, изменяя значения в заголовке соответствующим образом.</p>
<p>Метод <span class="code">fs.stat()</span> использует стандартный для Node паттерн функции обратного вызова с передачей значения ошибки в первом параметре. Эта часть кода может просто необычно выглядеть и быть не похожей на другие функции Node, которые встречались ранее. Главное отличие — использование синхронной функции
<span class="code">readFileSync()</span> вместо асинхронной версии <span class="code">readFile()</span>.</p>
<p>Node поддерживает как синхронную, так и асинхронную версию большинства
функций файловой системы. Обычно <b>использование синхронных операций
в веб-запросах в Node считается крайне нежелательным</b>, но такая возможность
существует.</p>



<h3>Маршрутизация</h3>
<p>Как только вы начнете думать, опираясь на термины событийно-ориентированного программирования, вы будете видеть события повсюду. Одним из таких событий является переход пользователя с одной страницы или области приложения на другую. То, как приложение отвечает на этот переход, называется <b>маршрутизацией</b>.</p>
<p>Маршрутизация относится к механизму выдачи клиенту контента, который он запрашивал. Для клиент-серверных веб-приложений клиент определяет желаемый
контент в URL, а именно путь и строку запроса</p>
<p>По сложившейся традиции серверная маршрутизация напрямую зависит от пути
и строки запроса, хотя доступна и другая информация: заголовки, домен, IP-адрес
и т. д. Благодаря этому сервер может учитывать, например, приблизительное
физическое местоположение пользователя или предпочитаемый им язык.</p>
<p>Расширим наш пример с «Hello world!» так, чтобы происходило что-то более
интересное. Создадим минимальный сайт, состоящий из домашней страницы,
страниц <i>О нас</i> и <i>Не найдено</i>. Пока будем придерживаться предыдущего примера и просто начнем выдавать неформатированный текст вместо HTML-кода:</p>
<pre><code >const http = require('http')
const port = process.env.PORT || 3000
const server = http.createServer((req,res) => {
// Приводим URL к единому виду, удаляя
// строку запроса, необязательную косую черту
// в конце строки и переводя в нижний регистр.
    const path = req.url.replace(/\/?(?:\?.*)?$/, '').toLowerCase()
    switch(path) {
        case '':
        res.writeHead(200, { 'Content-Type': 'text/plain' })
        res.end('Homepage')
        break
    case '/about':
        res.writeHead(200, { 'Content-Type': 'text/plain' })
        res.end('About')
        break
    default:
        res.writeHead(404, { 'Content-Type': 'text/plain' })
        res.end('Not Found')
        break
    }
})
server.listen(port, () => console.log(`сервер запущен на порте ${port};\n` +
`http://localhost:${port}\n`+
`http://localhost:${port}/about\n`+
`http://localhost:${port}/404\n`+
'нажмите Ctrl+C для завершения...'))</code></pre>

<h3>Раздача статических ресурсов</h3>
<p>Теперь, когда заработала простейшая маршрутизация, раздадим какой-нибудь
реальный HTML-код и логотип. Они носят название <b>статических ресурсов</b>, поскольку обычно не изменяются (в отличие, например, от тикера: каждый раз, когда вы перезагружаете страницу, биржевые котировки меняются).</p>
<!--todo: tip Раздача статических ресурсов с помощью Node подходит для нужд разработкии небольших проектов. В проектах побольше вы, вероятно, захотите использовать для этих целей прокси-сервер, такой как Nginx или CDN. -->
Если вы работали с Apache или IIS, то, вероятно, просто создавали HTML-файл,
переходили к нему и автоматически открывали в браузере. Node работает иначе:
нам придется выполнить работу по открытию файла, его чтению и отправке его
содержимого браузеру. Так что создадим в нашем проекте каталог <span class="code">public</span> (в следующей главе станет понятно, почему мы не называем его <span class="code">static</span>). В нем создадим
<span class="code">home.html</span>, <span class="code">about.html</span>, <span class="code">404.html</span>, подкаталог с названием <span class="code">img</span> и изображение с именем <span class="code">img/logo.jpg</span>. Выполните эти шаги самостоятельно: раз вы читаете эту книгу,
то, вероятно, знаете, как создать HTML-файл и найти картинку. В ваших HTML-файлах ссылайтесь на логотип следующим образом: <span class="code">&lt;img src="/img/logo.jpg" alt="logo"></span>.
<p>Теперь внесем изменения в файл <span class="code">helloworld.js</span>:</p>
<pre><code >const http = require('http')
const fs = require('fs')
const port = process.env.PORT || 3000
function serveStaticFile(res, path, contentType, responseCode = 200) {
    fs.readFile(__dirname + path, (err, data) => {
    if(err) {
        res.writeHead(500, { 'Content-type': 'text/plain' })
        return res.end('500 — Внутренняя ошибка')
    }
    res.writeHead(responseCode, { 'Content-type': contentType })
        res.end(data)
    })
}
const server = http.createServer((req,res) => {
// Приводим URL к единому виду, удаляя
// строку запроса, необязательную косую черту
// в конце строки и переводя в нижний регистр.
const path = req.url.replace(/\/?(?:\?.*)?$/, '').toLowerCase()
switch(path) {
    case '':
        serveStaticFile(res, '/public/home.html', 'text/html')
        break
    case '/about':
        serveStaticFile(res, '/public/about.html', 'text/html')
        break
    case '/img/logo.png':
        serveStaticFile(res, '/public/img/logo.png', 'image/png')
        break
    default:
        serveStaticFile(res, '/public/404.html', 'text/html', 404)
        break
    }
})
server.listen(port, () => console.log(`сервер запущен на порте ${port}; ` +
'нажмите Ctrl+C для завершения...'))</code></pre>
<p>Обратите внимание, что мы создали функцию-хелпер, <span class="code">serveStaticFile</span>, выполняющую большой объем работы. <span class="code">fs.readFile</span> — асинхронный метод для чтения
файлов. Существует синхронная версия этой функции — <span class="code">fs.readFileSync</span>, но
чем быстрее вы начнете мыслить асинхронно, тем лучше. В функции <span class="code">fs.readFile</span>
используется шаблон под названием «обратный вызов» (<i>callbacks</i>). Вы предоставляете функцию обратного вызова (<i>callback function</i>), и после того, как работа
выполнена, происходит вызов этой функции (так сказать, она «вызывается обратно»). В этом случае <span class="code">fs.readFile</span> читает содержимое указанного файла и выполняет функцию обратного вызова по завершении чтения файла. Если файла
не существует или были проблемы с правами доступа при чтении файла, устанавливается значение переменной err и функция возвращает код состояния HTTP
500, указывающий на ошибку сервера. Если файл был прочитан успешно, он отправляется клиенту с заданным кодом ответа и типом содержимого.</p>
<p>Запись <span class="code">__dirname</span> будет соответствовать каталогу, в котором находится выполняемый скрипт. Если ваш скрипт размещен в <span class="code">/home/sites/app.js</span>, <span class="code">__dirname</span> будет соответствовать <span class="code">/home/sites</span>. Использовать такую удобную глобальную переменную
везде, где возможно, — хорошая идея. Если этого не сделать, можно получить
трудно диагностируемые ошибки при запуске приложения из другого каталога.</p>





<h2>Параметры командной строки Node</h2>
<!--todo tip командная строка=терминал=консоль-->
<p>В последних двух разделах Node запускается в командной строке без параметров командной строки. Я хочу кратко представить некоторые параметры,
прежде чем двигаться дальше. Другие параметры будут описаны в книге там,
где это будет уместно.</p>
<p>Чтобы получить информацию обо всех доступных параметрах, воспользуйтесь
ключом <span class="code">-h</span> или <span class="code">--help</span>.</p>
<p>С этим параметром команда node выводит список всех параметров и синтаксис
запуска приложения Node:</p>
<pre><code >Usage: node [options] [ -e script | script.js ] [arguments]
node debug script.js [arguments]</code></pre>
<p>Для получения версии Node используется следующая команда:</p>
<pre><code >$ node -v или --version</code></pre>
<p>Для проверки синтаксиса приложения Node используется параметр <span class="code">-c</span>. С этим
параметром команда node проверяет синтаксис без запуска приложения:</p>
<pre><code >$ node -c or --check script.js</code></pre>
<p>Чтобы получить информацию о параметрах V8, введите следующую команду:</p>
<pre><code >$ node --v8-options</code></pre>
<p>Мой любимый параметр Node — <span class="code">-p</span> или <span class="code">–print</span> — обрабатывает строку сценария Node и выводит результаты. Данная возможность особенно полезна
при проверке свойств окружения процесса. В следующем примере выводятся все значения свойства
<span class="code">process.env</span>:</p>
<pre><code >$ node -p "process.env</code></pre>

<h3>Обновление Node</h3>
<p>Версию Node можно проверить следующей командой:</p>
<pre><code >node -v</code></pre>
<p>Если вы используете программу установки пакетов, то запуск процедуры обновления пакетов приведет к обновлению Node и всего остального программного обеспечения на сервере (в системе Windows команда sudo не нужна):</p>
<pre><code >sudo apt-get update
sudo apt-get upgrade --show-upgraded</code></pre>
<p>Также для обновления Node можно воспользоваться менеджером пакетов npm.
Последовательность команд обновления выглядит так:</p>
<pre><code >sudo npm cache clean -f
sudo npm install -g
sudo n stable</code></pre>
<p>Программа <span class="code">npm</span> (Node Package Manager) обновляется чаще, чем Node. Чтобы
обновить только npm, выполните следующую команду:</p>
<pre><code >sudo npm install npm -g n</code></pre>
<p>Команда устанавливает новейшую версию нужного приложения. Версия проверяется следующей командой:</p>

<h2>Диспетчер пакетов <span class="code">npm</span></h2>
<p><span class="code">npm</span> — повсеместно распространенная система управления пакетами для Node
(именно таким образом мы получим и установим Express). В отличие от PHP,
GNU, WINE и других, образованных странным способом сокращений, <span class="code">npm</span> —
не акроним (именно поэтому пишется строчными буквами). Это скорее рекурсивная аббревиатура для «<span class="code">npm</span> — не акроним».</p>
<p>В целом двумя основными задачами системы управления пакетами являются
установка пакетов и управление зависимостями. <span class="code">npm</span> — быстрая и эффективная
система управления пакетами, которой, как мне кажется, экосистема Node обязана
своим быстрым ростом и разнообразием.</p>
<p><span class="code">npm</span> устанавливается при инсталляции Node, так что, если вы следовали перечисленным ранее шагам, она у вас уже есть. Так приступим же к работе</p>
<p>Основная команда, которую вы будете использовать с <span class="code">npm</span> (что неудивительно), — <span class="code">install</span>. Например, чтобы установить <span class="code">nodemon</span> (популярную утилиту для
автоматической перезагрузки программы Node после внесения изменений в исходный код), можно выполнить следующую команду в консоли:</p>
<pre><code >npm install -g nodemon</code></pre>
<p>Флаг <span class="code">-g</span> сообщает <span class="code">npm</span> о необходимости глобальной установки пакета, означающей его доступность по всей системе. Это различие будет понятнее, когда мы
рассмотрим файлы <span class="code">package.json</span>. Пока же примем за эмпирическое правило, что
утилиты JavaScript, такие как nodemon, обычно будут устанавливаться глобально,
а специфические для вашего веб-приложения пакеты — нет.</p>






<h2>Среда хостинга Node</h2>
<p>Когда вы будете
готовы предоставить расширенный доступ к своим приложениям, вам придется найти либо среду для запуска приложения Node (например, виртуальную
частную сеть — <b>VPN</b> (<i>Virtual Private Network</i>), которую использую я), либо
хост, специально предоставляющий поддержку приложений Node. Первый
вариант потребует существенного опыта управления сервером, доступным из
Интернета, а второй нередко ограничивает то, что вы можете (или не можете)
делать в своих приложениях Node.</p>

<h3>Хостинг Node на вашем сервере, VPS или управляемом хосте</h3>
<p>Скорее всего, хостинг Node на одном сервере с блогом на базе WordPress приведет в тупик из-за требований Node. Иметь привилегированный или административный доступ для запуска Node не обязательно, но желательно. Кроме
того, компании, предоставляющие услуги хостинга, вряд ли обрадуются, если
вы начнете предоставлять доступ к своему приложению на разных портах,
которые могут породить хаос в их системах.</p>
<p>Хостинг Node на виртуальном частном сервере (<b>VPS</b>, <i>Virtual Private Server</i>) —
как в моей конфигурации с VPN в Linode — простое решение. Вам не потребуется привилегированный доступ к VPS, и вы сможете делать практически
все, что захотите, при условии, что это не создаст опасности для других пользователей, работающих на том же компьютере. Большинство компаний, предоставляющих услуги VPS, принимают меры к тому, чтобы все учетные записи
были изолированы друг от друга и ни одна учетная запись не могла захватить
все доступные ресурсы.</p>
<p>Однако с VPS возникает та же проблема, что и с собственным сервером: вам
придется заниматься сопровождением сервера. В частности, вам придется настроить систему электронной почты и альтернативный веб-сервер (вероятнее
всего, Apache или Nginx) для работы с брандмауэрами и другими средствами
безопасности, электронной почтой и т. д. Все это не просто.</p>
<p>Тем не менее, если вы уверенно чувствуете себя в области управления всеми
аспектами среды, доступной из Интернета, VPS может предоставить бюджетный вариант хостинга приложений Node — по крайней мере до того, как вы будете готовы запустить приложение в эксплуатацию (в этом случае можно
рассмотреть возможность хостинга приложения в облаке).</p>

<h3>Облачный хостинг</h3>
<p>В наши дни приложения размещаются на облачных серверах так же часто, как
и на компьютерах отдельных лиц и групп. Приложения Node хорошо подходят
для реализаций на базе облачных технологий.</p>
<p>Когда вы размещаете приложение Node в облаке, вы фактически строите приложение на вашем собственном сервере или PC, тестируете его, убеждаетесь
в том, что оно работает так, как нужно, и пересылаете приложение на облачный
сервер. Облачный сервер для Node позволяет создать нужное вам приложение
Node с использованием ресурсов баз данных и любых других необходимых
систем, но без прямого управления сервером. Вы можете сосредоточиться
на функциональности приложения Node, не отвлекаясь на серверы FTP или
электронной почты или общее управление сервером.</p>
<p>Почти
все операции с приложениями Node, включая отправку приложений на облачный сервер, выполняются через Git. Когда речь заходит о Git, эта система обычно ассоциируется с GitHub. Сопровождение исходного кода Node.js осуществляется на GitHub, как и код многих (если не всех) существующих модулей Node.</p>
<p>Парадигма хостинга приложений Node в облаке на разных хостах имеет много
общего. Сначала вы создаете приложение Node (локально либо на своем сервере). Когда все будет готово к тестированию среды развертывания, пора переходить к поиску облачного сервера. Для большинства известных мне серверов вы
создаете учетную запись, создаете новый проект и указываете, что приложение
работает на базе Node, если облачный сервер поддерживает хостинг разных
сред. Возможно, вам также придется указать другие необходимые ресурсы
(например, доступ к базе данных).</p>

<h2>Node, V8 и ES6</h2>
<p>В основе Node лежит ядро JavaScript. Для большинства реализаций используется ядро V8. Исходный код V8, изначально созданный компанией Google для Chrome, был переведен в открытый доступ в 2008 году. Ядро JavaScript
V8 было разработано для повышения скорости выполнения JavaScript за счет
включения JIT-компилятора (Just In Time), который преобразует JavaScript
в машинный код вместо того, чтобы его интерпретировать (что считалось нормой для JavaScript в течение многих лет). Ядро V8 написано на C++.</p>

<h2>Дополнения C/C++</h2>
<p>Хотя язык, на котором пишутся приложения Node, базируется на JavaScript,
большая часть Node на самом деле написана на C++. Обычно эта информация
остается скрытой в большинстве приложений, с которыми вы работаете. Но
если вы хорошо знаете C или C++, то cможете расширить функциональность
Node — для этого следует написать на C/C++ дополнение (add-on).</p>

<h2>Типичное веб-приложение Node</h2>
<p>Одна из сильных сторон Node и JavaScript вообще — однопоточная модель программирования. Программные потоки (<span class="code">threads</span>) являются стандартным источником ошибок, и хотя некоторые из недавно появившихся языков программирования, включая Go и Rust, пытаются предоставить безопасные инструменты параллельного программирования, Node работает с моделью, используемой в браузере.</p>
<p>Браузерный код представляет собой последовательность команд, которые выполняются одна за одной; код не выполняется параллельно.</p>
<p>Для пользовательских интерфейсов такая модель не имеет смысла: пользователь не хочет дожидаться завершения медленных операций (например, обращений к данным по сети или к файлам). Для решения этой проблемы в браузерах используются события: когда пользователь щелкает на кнопке, инициируется событие, и выполняется функция, которая была определена ранее, но еще не выполнялась. Тем самым предотвращаются некоторые проблемы, встречающиеся в многопоточном программировании, включая взаимные блокировки (<b>deadlocks</b>) ресурсов и состояния гонки (<b>race conditions</b>).</p>

<h3>Неблокирующий ввод/вывод</h3>
<p>Что это означает в контексте программирования <i>на стороне сервера</i>? Ситуация аналогична: запросы ввода/вывода (например, обращения к диску или сетевым
ресурсам) также выполняются относительно медленно, поэтому исполнительная среда не должна блокировать выполнение бизнес-логики во время чтения файлов
или передачи сообщений по сети. </p>
Для этого в Node используются три концепции:<p>
</p><ol>
    <li>события</li>
    <li>асинхронные API</li>
    <li>неблокирующий ввод/вывод</li>
</ol>
<p><b>Неблокирующий ввод/вывод</b> — низкоуровневый термин с точки зрения программиста Node. Он означает,
что программа может обратиться с запросом к сетевому ресурсу и заняться чем-то другим. А потом, когда сетевая операция будет завершена, выполняется функция
обратного вызова, которая обработает результат.</p>
<p>На <a href="#async_nonblocking_components">рис. ниже</a> изображено типичное веб-приложение Node, использующее библиотеку веб-программирования Express для обработки заказов в магазине. В нем:</p>
<ol>
    <li>Браузеры выдают запросы на приобретение продукта;</li>
    <li>приложение проверяет текущее состояние складских запасов</li>
    <li>создает учетную запись для пользователя</li>
    <li>отправляет квитанцию
        по электронной почте</li>
    <li>возвращает H T T P-ответ в формате JSON</li>
    <b>Одновременно с этим:</b>
    <li>квитанция отправляется по электронной почте</li>
    <li>база данных обновляется информацией от пользователя и данными заказа</li>
</ol>
<p>По сути, перед нами прямолинейный императивный код JavaScript, но исполнительная среда работает параллельно, потому что она использует неблокирующий ввод/вывод.</p>
<img id="async_nonblocking_components" src="/static/textbook/nodejs/images/async_nonblocking_components.png" alt="async nonblocking components">
<p>На <a href="#async_nonblocking_components">рис. выше</a> приложение обращается к базе данных по сети. В Node сетевые операции выполняются без блокировки, потому что Node при помощи библиотеки <span class="code">libuv</span> использует неблокирующие сетевые вызовы операционной системы. Эта функциональность по-разному реализована для Linux, macOS и Windows, но вам придется иметь дело только с удобной библиотекой JavaScript для работы с базами данных. Хотя вы пишете команды типа <span class="code">db.insert(query, err => {})</span>, Node во внутренней реализации выполняет оптимизированные неблокирующие сетевые операции.</p>
<p>Обращения к диску происходят примерно так же, но, как ни странно, полного совпадения нет. Когда приложение генерирует квитанцию, отправляемую по электронной почте, и шаблон сообщения читается с диска, <span class="code">libuv</span> использует пул потоков для создания иллюзии использования неблокирующего вызова. Управление пулом потоков — довольно тяжелое дело, но понять команду <span class="code">email.send('template.ejs', (err, html) => {})</span> определенно намного проще.</p>
<p>Истинное преимущество использования асинхронных API с неблокирующими
операциями ввода/вывода заключается в том, что Node может заниматься другими делами во время выполнения относительно медленных процессов. И хотя выполняться может только однопоточное и однопроцессное веб-приложение Node,
в любой момент времени оно может обрабатывать сразу несколько подключений
от тысяч потенциальных посетителей сайта. Чтобы понять, как это происходит,
необходимо познакомиться с циклом событий.</p>



<h2>Основы программирования в Node</h2>
<h3>Вывод на консоль</h3>
<p>Если вы привыкли к программированию на JavaScript для веб-браузеров, тогда одним из небольших сюрпризов, касающихся Node, будет то, что функция
<span class="code">console.log()</span> предназначена не только для отладки. Она является простейшим способом отображения сообщения пользователю в Node или в более общем плане отправки вывода в поток stdout. Вот как выглядит классическая
программа <span class="code">“Hello World”</span> в Node:</p>
<pre><code >console.log("Hello World!");</code></pre>

<p>В веб-браузерах <span class="code">console.log()</span>, <span class="code">console.warn()</span> и <span class="code">console.error()</span>, как правило, отображают маленькие значки рядом со своим выводом в консоли инструментов разработчика, чтобы обозначать различные журнальные
сообщения.</p>

<h3>Аргументы командной строки и переменные среды</h3>
<p>Если вы ранее писали программы в стиле Unix, предназначенные для вызова из окна терминала или другого интерфейса командной строки, то вам известно, что такие программы обычно получают свой ввод в первую очередь из аргументов командной строки и во вторую очередь из переменных среды.</p>
Среда Node следует таким соглашениям Unix. Программа Node может читать свои аргументы командной строки из массива строк <span class="code">process.argv</span>. Первый элемент этого массива всегда будет путем к исполняемому файлу Node. Второй аргумент — путь к файлу кода JavaScript, который Node выполняет. Оставшиеся элементы в массиве <span class="code">process.argv</span> являются аргументами, отделенными друг от друга пробелами, которые вы передали в командной строке, когда вызывали Node. Например, пусть вы сохранили приведенную ниже очень короткую программу Node в файле <span class="code">argv.js</span>:
<pre><code>console.log(process.argv);</code></pre>
<p><b>Вывод:</b></p>
<pre><code >$ node --trace-uncaught argv.js --arg1 --arg2 filename
[
    '/usr/local/bin/node',
    '/private/tmp/argv.js',
    '--arg1',
    '--arg2',
    'filename'
]</code></pre>
<p>Здесь необходимо отметить два момента:</p>
<ul>
    <li>Первый и второй элементы <span class="code">process.argv</span> будут полными путями в файловой системе к исполняемому файлу Node и запущенному файлу кода JavaScript, даже если вы не вводили их в таком виде.</li>
    <li>Аргументы командной строки, которые предназначены для Node и интерпретируются им, потребляются самим исполняемым файлом Node и не присутствуют в <span class="code">process.argv</span>. (Аргумент командной строки <span class="code">--trace-uncaught</span> в предыдущем примере фактически не делает ничего полезного; он нужен лишь для того, чтобы продемонстрировать его отсутствие в выводе.) Любые аргументы (наподобие <span class="code">--arg1</span> и <span class="code">filename</span>) следующие после имени файла кода JavaScript, будут появляться в <span class="code">process.argv</span>.</li>
</ul>
<p>Программы Node могут также принимать ввод от переменных среды в стиле
Unix. Среда Node делает их доступными через объект <span class="code">process.env</span>. Именами свойств этого объекта будут имена переменных среды, а значениями (всегда строковыми) свойств — значения переменных среды.</p>
<p>Вот неполный список переменных среды в некоторой системе:</p>
<pre><code >$ node -р -е 'process.env'
{
    SHELL: '/bin/bash',
    USER: 'david',
    PATH: '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin',
    PWD: '/tmp',
    LANG: 'en_US.UTF-8',
    HOME: '/Users/david',
}</code></pre>
Вы можете использовать <span class="code">node -h</span> или <span class="code">node -help</span>, чтобы выяснить, для чего предназначены аргументы командной строки <span class="code">-р</span> и <span class="code">-е</span>. Однако имейте в виду, что вы могли бы переписать предыдущую строку следующим образом: <span class="code">node --eval 'process.env' --print</span>.


<h2>НЕ СОРТИРОВАНО</h2>


<h3>Жизненный цикл программы</h3>

<h2>Лицензирование</h2>
При разработке веб-приложений Node вы можете обнаружить, что уделяете лицензированию больше внимания, чем когда-либо раньше (я определенно уделяю).
Одно из преимуществ экосистемы Node — огромный набор доступных пакетов.
Однако у каждого из этих пакетов свои правила лицензирования, хуже того, каждый пакет может зависеть от других пакетов, а значит, условия лицензирования
различных частей написанного вами приложения могут оказаться запутанными.
Однако есть и хорошие новости. Одна из наиболее популярных лицензий для
пакетов Node — лицензия MIT исключительно либеральна и позволяет вам делать
практически все, что хотите, включая использование пакета в программном обеспечении с закрытым исходным кодом. Но не следует просто предполагать, что
каждый используемый вами пакет лицензирован MIT.
Хотя MIT — самая распространенная лицензия, вы можете также увидеть следующие лицензии.
<ul>
    <li>Стандартная общественная лицензия GNU (GNU General Public License, GPL).
        GPL — распространенная лицензия для программного обеспечения с открытым исходным кодом, искусно разработанная для того, чтобы сохранить
        свободу программного обеспечения. Это значит, что, если вы используете
        лицензированный по GPL код в своем проекте, проект тоже обязан быть
        GPL-лицензированным. Естественно, это означает, что проект не может иметь
        закрытый исходный код</li>
    <li>Apache 2.0. Эта лицензия, подобно MIT, позволяет использовать другую лицензию для проекта, в том числе лицензию с закрытым исходным кодом. Вы обязаны, однако, включить уведомление о компонентах, использующих лицензию
        Apache 2.0.</li>
    <li>Лицензия Университета Беркли для ПО (Berkeley Software Distribution, BSD). Подобно Apache, эта лицензия позволяет использовать для проекта какую угодно
        лицензию при условии включения уведомления об использующих лицензию
        BSD компонентах.</li>
</ul>