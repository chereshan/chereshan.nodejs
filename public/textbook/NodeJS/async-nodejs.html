<!--<title>Глава 996. Асинхронное программирование в Node.js</title>-->
Средства асинхронного программирования

В мире Node для управления логикой ответов используются две популярные модели: обратные вызовы и слушатели событий.
Обратные вызовы обычно определяют логику для одноразовых ответов. Например,
при выполнении запроса к базе данных можно назначить функцию обратного вызова, определяющую, что нужно сделать с результатами запроса. Функция обратного вызова может вывести результаты, выполнить с ними некие вычисления или
выполнить другую функцию обратного вызова, использовав результаты запроса
в качестве аргумента.

Слушатели событий представляют собой обратные вызовы, связанные с концептуальной сущностью (событием). Скажем, щелчок кнопкой мыши — это событие,
которое обрабатывается в браузере. А код Node в сервере HTTP генерирует событие
request при выдаче запроса HTTP. Вы можете прослушать событие request и добавить логику ответа. В следующем примере функция handleRequest будет вызываться каждый раз, когда генерируется событие request; для этого вызов метода
EventEmitter.prototype.on связывает слушателя события с сервером:
<pre><code>server.on('request', handleRequest)</code></pre>
Экземпляр сервера HTTP в Node является примером генератора событий — класса
(EventEmitter), который может использоваться при наследовании и который добавляет возможность генерирования и обработки событий. Многие аспекты базовой
функциональности Node наследуются от EventEmitter; вы также можете создать
собственный генератор событий.

<!-- ...... -->
Обработка одноразовых событий
в обратных вызовах
Функция обратного вызова (callback) — функция, которая передается в аргументе
асинхронной функции и описывает, что нужно делать по завершении асинхронной
операции. Функции обратного вызова часто применяются в разработке Node — чаще,
чем генераторы событий, и с ними проще работать.
Чтобы продемонстрировать использование обратных вызовов в приложении, посмотрим, как создать простой сервер HTTP, который:
О асинхронно читает заголовки последних сообщений, хранящиеся в файле JSON;
О асинхронно читает базовый шаблон HTML;
О строит страницу HTM L с заголовками;
О отправляет страницу HTM L пользователю.

Для начала инициализируем проект
<pre><code>mkdir young-async-intro
cd young-async-intro
npm init -y</code></pre>
Создадим файл app.js и titles.json, в последний из которых добавим следующие данные:
<pre><code>{
    [
    "Kazakhstan is a huge country... what goes on there?",
    "This weather is making me craaazy",
    "My neighbor sort of howls at night"
    ]
}
</code></pre>
Создадим файл template.html и добавим в него следующий код:
<!-- обеззаразить html позже -->
<!doctype html>
<html>
<head></head>
<body>
<h1>Latest Posts</h1>
<ul><li>%</li></ul>
</body>
</html>

Создадим файл blog_recent.js и добавим в него следующий код:
<pre><code>const http = require('http');
const fs = require('fs');

// Создаем сервер HTTP и используем обратный вызов для опредления логики ответа
http.createServer((req, res) => {
    if (req.url == '/') {
        //читает файл titles.json и использует обратный вызов для определения того, как поступить с его содержимым
        fs.readFile('./titles.json', (err, data) => {
            //если возникает ошибка, то регистрируем ее и отправляем клиенту Server Error
            if (err) {
                console.error('Error loading titles.json', err);
                err.end('Server Error');
            }
            else {
                //пасринг данных в объект из строки json
                const titles = JSON.parse(data.toString());
                //читаем шшаблон tamplate.html и используем обратный вызов при завершении загрузки
                fs.readFile('./template.html', (err, data) => {
                    if (err) {
                        console.error('Error loading template.html', err);
                        err.end('Server Error');
                    }
                    else {
                        const tpl = data.toString();
                        //собираем страницк
                        const html = tpl.replace('%', titles.join('</li><li>'));
                        res.writeHead(200, { 'Content-Type': 'text/html' });
                        //отправляем страницу пользователю
                        res.end(html);
                    }
                })
            }
        })
    }
}).listen(3010, () => {
    console.log('Server is running on port 3000');
})
</code></pre>

В этом примере используются три уровня вложенности обратных вызовов:
<pre><code></code>http.createServer((req, res) => { ...
fs .re a d F ile ('./title s .js o n ', (err, data) => { ...
fs.readFile('./tem plate.htm l', (err, data) => { ...
</code></pre>


В трехуровневой структуре нет ничего плохого, но чем больше уровней вы используете, тем более громоздко выглядит ваш код и тем больше проблем возникает
с его рефакторингом и тестированием, поэтому глубину вложения желательно
ограничить. Создавая именованные функции для обработки отдельных уровней, вы
можете выражать ту же логику способом, который требует больше строк кода — но
этот код будет проще в сопровождении, тестировании и рефакторинге. Следующий
листинг функционально эквивалентен листингу 2.6.

<pre><code>const http = require('http');
const fs = require('fs');
    http.createServer((req, res) => {
        getTitles(res);
    }).listen(3010, () => {
        console.log('Server is running on port 3010');
        console.log('Visit http://localhost:3010');
    })

    function getTitles(res) {
        fs.readFile('./titles.json', (err, data) => {
            if (err) hasError(err, res);
            const titles = JSON.parse(data.toString());
            getTemplate(res, titles);
        })
    }

    function getTemplate(res, titles) {
        fs.readFile('./template.html', (err, data) => {
            if (err) hasError(err, res);
            const tpl = data.toString();
            formatHtml(titles, tpl, res);
        })
    }

    function formatHtml(titles, tpl, res) {
        const html = tpl.replace('%', titles.join('</li><li>'));
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end(html);
    }

    function hasError(err, res) {
        console.error('Error loading template.html', err);
        err.end('Server Error');
    }
</code></pre>

СОГЛАШЕНИЯ NODE ДЛЯ АСИНХРОННЫХ ОБРАТНЫХ ВЫЗОВОВ
Больш инство встроенных модулей Node использует обратные вызовы
с двумя аргументами: первый аргумент предназначен для ошибки (если
она возникнет), а второй — для результатов. Аргумент ошибки error часто
сокращается до err.
Типичный пример сигнатуры функции:
<pre><code>const fs = re q u ire('fs');
fs .re a d F ile ('./title s .js o n ', (err, data) => {
if (err) throw err;
/ / Если ошибки не было, что-то сделать с данными
});
</code></pre>


Обработка повторяющихся событий
с генераторами событий

Генераторы событий инициируют события и включают возможность обработки
этих событий при их инициировании. Некоторые важные компоненты Node API —
серверы HTTP, серверы TCP и потоки — реализуются как генераторы событий.
Разработчик также может создавать собственные генераторы.

Как упоминалось ранее, события обрабатываются при помощи слушателей. Слушатель (listener) представляет связь события с функцией обратного вызова, которая
выполняется каждый раз при возникновении события. Например, у сокета TCP
в Node имеется событие с именем data, которое инициируется каждый раз при появлении новых данных в сокете:
<pre><code>socket.on('data', handleData);</code></pre>
Посмотрим, как использовать события data для создания эхо-сервера.

2.8.1. Пример генератора событий

Простой пример повторяющихся событий встречается в эхо-сервере. Когда вы отправляете данные эхо-серверу, он просто выводит полученные данные
В листинге 2.9 приведен код, необходимый для реализации эхо-сервера. Каждый
раз при подключении клиента создается сокет. Сокет представляет собой генератор
событий, к которому можно добавить слушателя методом on для реакции на события data. Эти события данных генерируются каждый раз при появлении новых
данных в сокете.

<pre><code>const net = require('net');
const server = net.createServer((socket) => {
    // событие 'data' происходит когда клиент отправляет данные на сервер
    socket.on('data', (data) => {
        // отправляет обратно то, что пришло
        socket.write(data);
    });
});

server.listen(3010);
</code></pre>

После того как эхо-сервер будет запущен, вы можете подключиться к нему следующей командой:
<pre><code></code>telnet 127.0.0.1 3010</code></pre>

2.8.2. Реакция на событие, которое должно происходить
только один раз
Слушатели могут определяться для многократной реакции на события, как в предыдущем примере, или же для однократной реакции. В следующем листинге,
использующем метод once, приведенный ранее пример с эхо-сервером изменяется так, чтобы он воспроизводил только первый фрагмент отправленных ему
данных.

<pre><code>const net = req u ire('n et');
const server = net.createServer(socket => {
socket.once('data', data => { < ------- Событие data будет обработано всего один раз.
socket.write(data);
});
});
server.listen(8888);</code></pre>

2.8.3. Создание генераторов событий:
публикация/подписка

В предыдущем примере использовался встроенный Node API, использующий генераторы событий. Однако встроенный модуль событий Node позволяет создавать
собственные генераторы событий.
Следующий код определяет генератор событий channel с одним слушателем, который реагирует на присоединение пользователя к каналу. Обратите внимание на
использование on (или в более длинной альтернативной форме addL istener) для
добавления слушателя к генератору событий:

<pre><code></code>const EventEmitter = require('events').EventEmitter;
const channel = new EventEmitter();
channel.on('join', () => {
console.log('Welcome!');
});

channel.emit('join');
</code></pre>

ИМЕНА СОБЫТИЙ
События — ключи, с которыми может быть связано любое строковое значение: data,
join и вообще произвольное длинное имя. Только одно событие с именем error играет
особую роль; вскоре мы рассмотрим его.

Давайте посмотрим, как реализовать собственную логику публикации/подписки
с использованием EventEm itter для создания канала передачи информации. З апустив сценарий из листинга 2.11, вы получите простой чат-сервер. Канал чатсервера реализуется как генератор событий, который реагирует на события join,
генерируемые клиентами. Когда клиент присоединяется к каналу, логика слушателя
jo in в свою очередь добавляет дополнительного слушателя для данного клиента
к каналу широковещательного события, который будет записывать все рассылаемые
сообщения в клиентский сокет. Имена типов событий (такие, как jo in и broadcast)
выбираются абсолютно произвольно. При желании вы можете использовать другие
имена для этих типов событий.

const events = require('events');
const net = require('net');
const channel = new events.EventEmitter();

channel.clients = {};
channel.subscriptions = {};
// добавляем для события join слушателя, который сохраняет объект client, чтобы приложение могло отправлять данные обратно пользователю
channel.on('join', function(id, client) {
    this.clients[id] = client;
    this.subscriptions[id] = (senderId, message) => {
        //игнорирует данные, если они отправляются напрямую широковещательной рассылке
        if (id != senderId) {
            this.clients[id].write(message);
        }
    };
    // добавляет слушателя для события broadcast
    this.on('broadcast', this.subscriptions[id]);
});

const server = net.createServer(client => {
    const id = `${client.remoteAddress}:${client.remotePort}`;
    // отправляет событие join при подключении нового пользователяьзователя к серверу, с указанием идентификатора пользователя и объекта client
    channel.emit('join', id, client);
    client.on('data', data => {
        data = data.toString();
        // генерирует событие широковещательной рассылки в канале с указанием идентификатора пользователя и сообщения при отправке данных любым пользователем
        channel.emit('broadcast', id, data);
    })
})
server.listen(3010);


после этого откройте несколько эксземаляров командной строки цштвщцы и введите telnet 127.0.0.1 3010 нажмите ctrl+] и введите строку set localecho. Как мы заметим при вводе строк в 1 терминале, они будут появляться и в других терминалах.
У этого чат-сервера есть серьезная проблема: при закрытии подключений и выходе пользователя из чат-комнаты остается слушатель, который будет пытаться 
записывать данные клиенту, который уже не подключен. Конечно, произойдет
ошибка. Чтобы решить ее, необходимо добавить слушателя в генератор событий
channel (листинг 2.12) и добавить логику в слушателя события close для генерирования события leave канала. Событие leave удаляет слушателя broadcast, который
был изначально добавлен для клиента.

<pre><code> const events = require('events');
const net = require('net');
const channel = new events.EventEmitter();

channel.clients = {};
channel.subscriptions = {};
// добавляем для события join слушателя, который сохраняет объект client, чтобы приложение могло отправлять данные обратно пользователю
channel.on('join', function(id, client) {
    this.clients[id] = client;
    this.subscriptions[id] = (senderId, message) => {
        //игнорирует данные, если они отправляются напрямую широковещательной рассылке
        if (id != senderId) {
            this.clients[id].write(message);
        }
    };
    // добавляет слушателя для события broadcast
    this.on('broadcast', this.subscriptions[id]);
});

channel.on('leave', function(id) {
    channel.removeListener('broadcast', this.subscriptions[id]);
    channel.emit('broadcast', id, `${id} has left the chat.\n`);
});

const server = net.createServer(client => {
    const id = `${client.remoteAddress}:${client.remotePort}`;
    // отправляет событие join при подключении нового пользователяьзователя к серверу, с указанием идентификатора пользователя и объекта client
    channel.emit('join', id, client);
    client.on('data', data => {
        data = data.toString();
        // генерирует событие широковещательной рассылки в канале с указанием идентификатора пользователя и сообщения при отправке данных любым пользователем
        channel.emit('broadcast', id, data);
    })
    client.on('close', () => {
        channel.emit('leave', id);
    });
});
server.listen(3010);
</code></pre>
Если по какой-то причине вы захотите отключить чат без завершения сервера, вы
также можете использовать метод генератора события rem oveA llL isteners для
удаления всех слушателей заданного типа. Следующий код показывает, как эта
возможность реализуется для нашего чат-сервера:

channel.on('shutdown', () => {
    channel.emit('broadcast', ' ' , 'The server has shut down.\n');
    channel.removeAllListeners('broadcast');
    });
    
    Затем можно добавить поддержку команды чата, завершающей общение. Для этого
измените слушателя для события data в следующем коде:
clien t.o n ('d ata', data => {
    data = data.toString();
    if (data === 'shutdown\r\n') {
    channel.emit('shutdown');
    }
    channel.emit('broadcast', id, data);
    });
    
    Теперь при вводе любым участником в чате команды shutdown все участники будут
отключены.

ОБРАБОТКА ОШИБОК

Стандартный прием, часто применяемый при создании генераторов событий, — генерирование события типа error вместо прямого инициирования
ошибки. Это позволяет вам определять специальную логику реакции на
события посредством назначения одного или нескольких слушателей для
данного типа события
Следующий код показывает, как слушатель событий обрабатывает сгенерированную ошибку, выводя информацию на консоль
const events = require^events');
const myEmitter = new events.EventEmitter();
myEmitter.on^error', err => {
console.log('ERROR: S^rr.m essage}');
});
myEmitter.emit^error', new Error^Something is wrong.'));
Если слушатель для этого типа события не определен при генерировании
типа события error, генератор события выводит трассировку стека (список
команд программы, выполнявшихся до точки возникновения ошибки) и прерывает выполнение. В трассировке стека обозначен тип ошибки, заданный
вторым аргументом вызова emit. Это поведение присуще исключительно
событиям типа error; при генерировании других типов событий, не имеющих
слушателей, ничего не происходит.
Если событие типа error генерируется без передачи объекта error во втором
аргументе, в трассировке стека будет указано «неперехваченное неопределенное событие ошибки ‘error’», и приложение аварийно завершается. Существует устаревший механизм, который может применяться для обработки
таких ошибок, — вы можете определить собственную реакцию, определив
глобальный обработчик в следующем коде:
process.on('uncaughtException', err => {
    console.error^rr.stack);
    process.exit(l);
    });
    Если вы захотите предоставить пользователям, подключающимся к чату, счетчик
пользователей, активных в настоящий момент, можно использовать следующий
метод lis te n e r s , который возвращает массив слушателей для заданного типа
события:
<pre><code>
channel.on('join', function(id, client) {
    const welcome = `Welcome!\n` +
        `Guests online: ${this.listeners('broadcast').length}\n` +
        `To leave the chat, type "quit"\n` +
        `To shutdown the server, type "shutdown"\n`;
    client.write(welcome);
    ...

    </code></pre>

    2.8.4. Доработка генератора событий:
отслеживание содержимого файлов
 стр 62
