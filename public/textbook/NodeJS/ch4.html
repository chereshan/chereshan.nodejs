<!--<title>Глава 4. Шаблонизация с помощью Handlebars</title>-->
<h1>Глава 4. Шаблонизация с помощью Handlebars</h1>
<h2>Введение в шаблонизацию</h2>
В этой главе будет рассмотрена <b>шаблонизация</b> — методика проектирования и форматирования контента, отображаемого пользователю. Шаблонизацию можно
рассматривать как эволюционировавшее стандартное письмо:
<pre style="white-space: pre-wrap;">«Уважаемый [Имя Отчество]! C сожалением сообщаем Вам, что [Устаревшая технология] больше никем не используется, но шаблонизация живет и здравствует!»</pre>
<p>Чтобы отправить это письмо нескольким людям, вам нужно лишь изменить <i>[Имя Отчество]</i> и <i>[Устаревшую технологию]</i>.</p>
<p>Хотя такие фреймворки для разработки клиентской части, как <i>React</i>, <i>Angular</i> и <i>Vue</i>, быстро вытеснили шаблонизацию на стороне сервера, последняя все еще применяется, например, для создания сообщений электронной почты в формате HTML. К тому же как Angular, так и Vue используют для написания HTML подход, схожий с шаблонизацией, так что полученные вами знания о шаблонизации на стороне сервера применимы к этим фреймворкам для разработки клиентской части.</p>
<p>Если вы раньше работали с PHP, то можете удивиться, из-за чего весь этот
ажиотаж: PHP — один из первых языков, который можно назвать языком шаблонизации. Практически все основные языки, подходящие для веб-разработки, включают тот или иной вид поддержки шаблонизации. Но в последнее время ситуация
изменилась: <b>шаблонизатор обычно не привязан к языку</b>.</p>
<p>Так как же выглядит шаблонизация? Начнем с того, что шаблонизация замещает, и рассмотрим наиболее прямой и очевидный путь генерации одного языка
из другого (конкретнее, мы будем генерировать HTML с помощью JavaScript):</p>
<pre><code >document.write('&lt;h1>Пожалуйста, не делайте так&lt;/h1>')
document.write('&lt;p>&lt;span class="code">document.write&lt;/span> капризен,\n')
document.write('и его следует избегать в любом случае.&lt;/p>')
document.write('&lt;p>Сегодняшняя дата: ' + new Date() + '.&lt;/p>')</code></pre>
<p>В императивных языках мы привыкли говорить: «Сделай это, затем то, а потом
что-то еще». В некоторых случаях этот подход отлично работает. В нем нет ничего
плохого, если у вас 500 строк JavaScript для выполнения сложного вычисления,
результатом которого является одно число, и каждый шаг зависит от предыдущего.
Но что, если дела обстоят с точностью до наоборот? У вас 500 строк HTML и три
строки JavaScript. Имеет ли смысл писать <span class="code">document.write</span> 500 раз? Отнюдь.</p>
<p>На самом деле все сводится к тому, что переключать контекст проблематично. Если вы пишете много кода JavaScript, вплетать в него HTML неудобно, это
приводит к путанице. Обратный способ не так уж плох: мы привыкли писать
JavaScript в блоках <span class="code">&lt;script></span>, но надеюсь, что вы видите разницу: здесь все-таки
есть переключение контекста и вы или пишете HTML, или в блоке <span class="code">&lt;script></span>
пишете JavaScript. Использование же JavaScript для генерации HTML чревато
проблемами:</p>
<ul>
    <li>Вам придется постоянно думать о том, какие символы необходимо экранировать и как это сделать.</li>
    <li>Использование JavaScript для генерации HTML, который, в свою очередь, сам содержит JavaScript, быстро сведет вас с ума.</li>
    <li>Вы обычно лишаетесь приятной подсветки синтаксиса и прочих удобных возможностей, отражающих специфику языка, которыми обладает ваш редактор.</li>
    <li>Становится гораздо сложнее заметить плохо сформированный HTML.</li>
    <li>Трудно визуально анализировать код.</li>
    <li>Другим людям может быть сложнее понимать ваш код.</li>
</ul>

<p>Шаблонизация решает проблему, позволяя писать на целевом языке и при этом
обеспечивая возможность вставлять динамические данные. Взгляните на предыдущий пример, переписанный в виде шаблона Mustache:</p>
<pre><code >&lt;h1>Намного лучше&lt;/h1>
&lt;p>Никаких &lt;span class="code">document.write&lt;/span> здесь!&lt;/p>
&lt;p>Сегодняшняя дата {{today}}.&lt;/p></code></pre>
<p>Все, что нам осталось сделать, — обеспечить значение для <span class="code">{{today}}</span>. Это и есть
основа языков шаблонизации.</p>

<h3>Не пишем HTML в JavaScript!</h3>
<p>Я не говорю, что вам никогда не следует писать HTML в JavaScript, а только то, что этого следует избегать при любой возможности. В частности, это приемлемо в коде клиентской части, особенно если вы используете надежный фреймворк для ее разработки. Например, следующее вызвало бы с моей стороны немного комментариев:</p>
<pre><code >document.querySelector('#error').innerHTML =
'Случилось что-то &lt;b>очень плохое!&lt;/b>'</code></pre>
<p>Однако я бы намекнул, что настало время применить шаблон, если код постепенно видоизменится до вот такого:</p>
<pre><code >document.querySelector('#error').innerHTML =
'&lt;div class="error">&lt;h3>Error&lt;/h3>' +
    '&lt;p>Случилось что-то &lt;b>&lt;a href="/error-detail/' + errorNumber+'"> очень плохое.&lt;/a>&lt;/b> ' +
        '&lt;a href="/try-again">Попробуйте снова&lt;a>, или ' +
            '&lt;a href="/contact">обратитесь в техподдержку&lt;/a>.&lt;/p>&lt;/div>'</code></pre>
<p>Дело в том, что я посоветовал бы вам очень тщательно подумать, где нужно
провести границу между HTML в строках и использованием шаблонов. Лично я допустил бы перекос в сторону шаблонов и избегал генерации HTML с помощью
JavaScript во всех случаях, за исключением простейших.</p>

<h2>Выбор шаблонизатора</h2>
<p>Во вселенной Node у вас есть выбор из множества шаблонизаторов. Как же подобрать подходящий? Это непростой вопрос, существенно зависящий от того,
что именно вам нужно. Вот некоторые критерии, которые следует принять во
внимание:</p>
<ul>
    <li><b>Производительность</b>. Несомненно, вы хотите, чтобы шаблонизатор работал как можно быстрее. Нельзя, чтобы он замедлял работу вашего сайта.</li>
    <li><b>Клиент, сервер или и то и другое?</b> Большинство шаблонизаторов доступны на стороне как сервера, так и клиента. Если вам необходимо использовать шаблоны и тут и там (и вы будете это делать), рекомендую выбрать шаблонизатор, производительность которого одинакова в обоих случаях.</li>
    <li><b>Абстракция</b>. Вам хочется чего-то знакомого (вроде обычного HTML с добавлением фигурных скобок) или вы тайно ненавидите HTML и предпочли бы что-то без всех этих угловых скобок? Шаблонизация (особенно на стороне сервера) дает вам возможность выбора.</li>
</ul>
<p>Express позволяет использовать любой шаблонизатор, какой пожелаете, так что,
если Handlebars вас не устраивает, вы без проблем сможете его заменить.</p>
<p>Прежде чем перейти к обсуждению Handlebars, взглянем на исключительно
абстрактный шаблонизатор.</p>

<h2>Pug: абстрактный подход</h2>
<p>В то время как большинство шаблонизаторов используют подход с сильной ориентацией на HTML, Pug выделяется тем, что абстрагирует вас от его подробностей. Стоит также отметить, что Pug — детище Ти Джея Головайчука, того самого, кто подарил нам Express. Неудивительно, что Pug отлично интегрируется с Express.</p>
Подход, используемый Pug, весьма благороден: в его основе лежит утверждение,
что HTML — слишком перегруженный деталями и трудоемкий для написания
вручную язык. Посмотрим, как выглядит шаблон Pug вместе с результирующим
HTML:
<pre><code >doctype html
html(lang="ru")
    head
        title= pageTitle
        script.
        if (foo) {
            bar(1 + 5)
        }
    body

        h1 Pug
        #container
            if youAreUsingJadePug
                p Браво!
            else
                p Просто сделайте это!
            p.
                Pug — сжатый и простой язык
                шаблонизации с сильным
                акцентом на производительности
                и многочисленных возможностях.</code></pre>
<p>Результат:</p>
<pre><code >&lt;!DOCTYPE html>
&lt;html lang="ru">
&lt;head>
    &lt;title>Демонстрация Pug&lt;/title>
    &lt;script>
        if (foo) {
            bar(1 + 5)
        }
    &lt;/script>
&lt;body>
&lt;h1>Pug&lt;/h1>
&lt;div id="container">
    &lt;p>Браво!&lt;/p>
    &lt;p>
        Pug — сжатый и простой язык
        шаблонизации с сильным
        акцентом на производительности
        и многочисленных возможностях.
    &lt;/p>
&lt;/body>
&lt;/html></code></pre>
<p>Pug, безусловно, сводит к минимуму набор на клавиатуре (больше никаких
угловых скобок и закрывающих тегов). Вместо этого он опирается на структурированное расположение текста и определенные общепринятые правила, облегчая
выражение идей. У Pug есть еще одно достоинство: теоретически, когда меняется
сам язык HTML, вы можете просто перенастроить Pug на новую версию HTML,
что обеспечит вашему контенту <i>«защиту от будущего»</i>.</p>
<p>Как бы я ни восхищался философией Pug и изяществом его выполнения, я обнаружил, что не хочу абстрагироваться от подробностей HTML. Этот язык лежит
в основе всего, что я как веб-разработчик делаю, и, если цена этого — износ клавиш
с угловыми скобками на клавиатуре, так тому и быть. Множество разработчиков
клиентской части, с которыми я обсуждал этот вопрос, думают аналогично, так что
мир, возможно, пока еще просто не готов к Pug</p>

<h2>Основы Handlebars</h2>
<p><b>Handlebars</b> — расширение Mustache, еще одного распространенного шаблонизатора. Я рекомендую Handlebars из-за его удобной интеграции с JavaScript (как
в клиентской, так и в серверной части) и знакомого синтаксиса. На мой взгляд, он
обеспечивает все правильные компромиссы, и именно на нем мы сосредоточимся в данной книге. Стоит заметить, что концепции, которые будут обсуждаться,
легко применимы и к другим шаблонизаторам, так что вы будете вполне готовы
к тому, чтобы попробовать другие шаблонизаторы, если Handlebars не придется
по душе.</p>
<p>Ключ к пониманию шаблонизации — понимание концепции <b>контекста</b>. Когда вы отображаете шаблон, вы передаете шаблонизатору объект, называемый <b>объектом
контекста</b>, что и обеспечивает работу подстановок.</p>
<p>Например, если мой объект контекста:</p>
<pre><code >{ name: 'Лютик' }</code></pre>
<p>а шаблон:</p>
<pre><code >&lt;p>Добро пожаловать, {{name}}!&lt;/p></code></pre>
то <span class="code">{{name}}</span> будет заменено на Лютик. Что же произойдет, если вы хотите передать
HTML-код шаблону? Например, если вместо этого наш контекст будет:
<pre><code >{ name: '&lt;b>Лютик&lt;/b>' }</code></pre>
использование предыдущего шаблона приведет к выдаче
<pre><code >&l&#8203;t;p>Добро пожаловать,&l&#8203;t;b&g&#8203;t;Лютик&l&#8203;t;b&g&#8203;t;&l&#8203;t;/p></code></pre>, что, вероятно, совсем не то, чего вы хотели. Для решения этой проблемы просто используйте три фигурные скобки вместо двух:
<span class="code">{{{name}}}</span>.
На <a href="#handlebars-rendering">рис. ниже</a> мы видим, как механизм Handlebars использует контекст (представленный овалом) в сочетании с шаблоном для рендеринга HTML-кода.
<img id="handlebars-rendering" src="images/handlebars-rendering.png" alt="">

<h3>Комментарии в Handlebars</h3>
<p>Комментарии в Handlebars выглядят вот так: <span class="code">{{! Здесь находится комментарий }}</span>.
Важно понимать различие между комментариями в Handlebars и комментариями
HTML. Рассмотрим следующий шаблон:</p>
<pre><code >{{! Очень секретный комментарий }}
&lt;!-- Не очень секретный комментарий --></code></pre>
<p>Если это серверный шаблон, очень секретный комментарий никогда не будет
отправлен браузеру, в то время как не очень секретный комментарий будет виден,
если пользователь заглянет в исходный код HTML. Вам следует предпочесть комментарии Handlebars всем остальным, раскрывающим подробности реализации
или что-то еще, что вам не хотелось бы выставлять напоказ.</p>

<h3>Блоки</h3>
<p>Все усложняется, когда мы начинаем рассматривать блоки. Блоки обеспечивают
управление последовательностью выполнения, условное выполнение и расширяемость. Рассмотрим следующий контекстный объект:</p>
<pre><code >{
    currency: {
    name: 'Доллары США',
    abbrev: 'USD',
},
    tours: [
        { name: 'Худ-Ривер', price: '$99.95' },
        { name: 'Орегон Коуст', price: '$159.95' },
],
specialsUrl: '/january-specials',
currencies: [ 'USD', 'GBP', 'BTC' ],
}</code></pre>
<p>Теперь взглянем на шаблон, которому мы можем этот контекст передать:</p>
<pre><code >&lt;ul>
    {{#each tours}}
    {{! Я в новом блоке... и контекст изменился }}
    &lt;li>
        {{name}} - {{price}}
        {{#if ../currencies}}
        ({{../../currency.abbrev}})
        {{/if}}
    &lt;/li>
    {{/each}}
&lt;/ul>
{{#unless currencies}}
&lt;p>Все цены в {{currency.name}}.&lt;/p>
{{/unless}}
{{#if specialsUrl}}
{{! Я в новом блоке... но контекст вроде бы не изменился }}
&lt;p>Проверьте наши &lt;a href="{{specialsUrl}}">специальные предложения!&lt;/p>
{{else}}
&lt;p>Просьба чаще пересматривать наши специальные предложения.&lt;/p>
{{/if}}
&lt;p>
    {{#each currencies}}
    &lt;a href="#" class="currency">{{.}}&lt;/a>
    {{else}}
    К сожалению, в настоящее время мы принимаем только {{currency.name}}.
    {{/each}}
&lt;/p></code></pre>
<p>В этом шаблоне происходит многое, так что разобьем его на составные части.</p>
<p>Он начинается со вспомогательного элемента <span class="code">each</span>, обеспечивающего итерацию
по массиву. Важно понимать, что между <span class="code">{{#each tours}}</span> и <span class="code">{{/each tours}}</span>
меняется контекст. На первом проходе он меняется на <span class="code">{ name: 'Худ-Ривер', price: '$99.95' }</span>, а на втором проходе — на <span class="code">{name: 'Орегон Коуст', price, '$159.95' }</span>. Таким образом, внутри этого блока мы можем ссылаться на <span class="code">{{name}}</span>
и <span class="code">{{price}}</span>. </p>

<p>Однако если мы хотим обратиться к объекту <span class="code">currency</span>, нам придется использовать <span class="code">../</span>, чтобы получить доступ к родительскому контексту.</p>
<p>Если свойство контекста само по себе является объектом, мы можем обратиться
к его свойствам как обычно, через точку, например: <span class="code">{{currency.name}}</span>.</p>
<p>Как у <span class="code">if</span>, так и у <span class="code">each</span> может быть (необязательный) блок <span class="code">else</span> (в случае <span class="code">each</span>
блок <span class="code">else</span> будет выполняться при отсутствии элементов в массиве).</p>

<p>Мы также использовали вспомогательный элемент <span class="code">unless</span>, являющийся, по существу, противоположностью вспомогательного элемента <span class="code">if</span>: он выполняется только в том случае, когда аргумент ложен.</p>
<p>Последняя вещь, которую хотелось бы отметить относительно этого шаблона:
использование <span class="code">{{.}}</span> в блоке <span class="code">{{#each currencies}}</span>. <span class="code">{{.}}</span> ссылается на текущий
контекст; в данном случае текущий контекст — просто строка в массиве, которую
мы хотим вывести на экран.</p>
<p>Обращение к текущему контексту через одиночную точку имеет и другое применение: оно позволяет различать вспомогательные функции (<i>хелперы</i>) (которые
мы вскоре изучим) и <i>свойства текущего контекста</i>. Например, если у вас есть
хелпер <span class="code">foo</span> и свойство <span class="code">foo</span> в текущем контексте, <span class="code">{{foo}}</span> ссылается на хелпер,
а <span class="code">{{./foo}}</span> — на свойство.</p>


<h3>Серверные шаблоны</h3>
<p>Серверные шаблоны дают возможность отобразить HTML-код до его отправки
клиенту. В отличие от шаблонизации на стороне клиента, где шаблоны доступны
любопытному пользователю, знающему, как смотреть исходный код HTML, ваши
пользователи никогда не увидят серверные шаблоны или объекты контекста, используемые для генерации окончательного HTML-кода.</p>
<p>Помимо скрытия подробностей реализации, серверные шаблоны поддерживают
кэширование шаблонов, играющее важную роль в обеспечении производительности. Шаблонизатор кэширует скомпилированные шаблоны (перекомпилирует
и кэширует заново только в случае изменения самого шаблона), что повышает производительность шаблонизированных представлений. По умолчанию кэширование
представлений отключено в режиме разработки и активно в эксплуатационном режиме. Явным образом активировать кэширование представлений, если захотите,
можно следующим образом:</p>
<pre><code >app.set('view cache', true)</code></pre>
<p>Непосредственно «из коробки» Express поддерживает Pug, EJS и JSHTML.
Мы уже обсуждали Pug, и я не стану рекомендовать использовать EJS или JSHTML
(на мой взгляд, они оба недостаточно развиты в плане синтаксиса). Итак, нужно
добавить пакет Node, который обеспечит поддержку Handlebars для Express:</p>
<pre><code >npm install express-handlebars</code></pre>
<p>Затем привяжем его к Express:</p>
<pre><code >const expressHandlebars = require('express-handlebars')
app.engine('handlebars', expressHandlebars.engine({
    defaultLayout: 'main',
}))
app.set('view engine', 'handlebars')</code></pre>
Пакет <span class="code">express-handlebars</span> предполагает, что расширение шаблонов Handlebars будет <span class="code">.handlebars</span>. Я уже привык к нему, но, если это расширение слишком длинное
для вас, можете изменить его на распространенное <span class="code">.hbs</span> при создании экземпляра <span class="code">express-handlebars</span>:
<pre><code >app.engine('handlebars','.hbs' }))</code></pre>

<h3>Представления и макеты</h3>
<p>Представление обычно означает отдельную страницу вашего сайта (хотя оно может означать и загружаемую с помощью Ajax часть страницы, электронное письмо
или что-то еще в том же роде). </p>
По умолчанию Express ищет представления в подкаталоге <span class="code">views</span>. <b>Макет</b> — особая разновидность представления, по сути, шаблон для шаблонов. Макеты важны, поскольку у большинства (если не у всех) страниц вашего сайта будут практически одинаковые макеты. Например, у них должны быть элементы <span class="code">&lt;html></span> и <span class="code">&lt;title></span>, они обычно загружают одни и те же файлы CSS
и т. д. Вряд ли вы захотите дублировать этот код на каждой странице, вот тут-то
и пригодятся макеты. Взглянем на основу макета:
<pre><code >&lt;!doctype>
&lt;html>
&lt;head>
    &lt;title>Meadowlark Travel&lt;/title>
    &lt;link rel="stylesheet" href="/css/main.css">
&lt;/head>
&lt;body>
    {{{body}}}
&lt;/body>
&lt;/html></code></pre>
<p>Обратите внимание на текст внутри тега <span class="code">&lt;body>: {{{body}}}</span>. Благодаря ему шаблонизатор знает, где отобразить содержимое вашего представления. Важно
использовать три фигурные скобки вместо двух, поскольку представление почти наверняка будет содержать HTML и мы не хотим, чтобы Handlebars пытался
его экранировать. </p>

Замечу, что нет ограничений относительно размещения поля <span class="code">{{{body}}}</span>. Например, если вы создаете адаптивный макет в Bootstrap, то, вероятно, поместите представление внутри контейнера <span class="code">&lt;div></span>. Многие стандартные элементы страницы, такие как шапка (<span class="code">header</span>) и подвал (<span class="code">footer</span>), также чаще всего находятся в макетах, а не в представлениях. Вот пример:
<pre><code >&lt;!-- ... -->
&lt;body>
&lt;div class="container">
    &lt;header>
        &lt;div class="container">
            &lt;h1>Meadowlark Travel&lt;/h1>
            &lt;img src="/img/logo.png" alt="Логотип Meadowlark Travel">
        &lt;/div>
    &lt;/header>
    &lt;div class="container">
        {{{body}}}
    &lt;/div>
    &lt;footer>&copy; 2019 Meadowlark Travel&lt;/footer>
&lt;/div>
&lt;/body></code></pre>
<p>На <a href="#template-rendering">рис. ниже</a> мы увидим, как шаблонизатор объединяет представление, макет и контекст. Самая важная вещь, которую проясняет эта схема, — порядок выполнения действий.</p>
<p>Сначала, до макета, отображается представление. На первый
взгляд это может показаться нелогичным: раз представление отображаться внутри
макета, не должен ли макет отображается первым? Несмотря на то что технически
это вполне возможно выполнить, есть определенные преимущества в обратном порядке действий. В частности, это позволяет самому представлению адаптировать
макет, что вполне может пригодиться, в чем мы убедимся при обсуждении секций.</p>
<p>Благодаря определенному порядку выполнения действий вы можете передать
в представление свойство <span class="code">body</span>, и оно будет правильно отображаться в представлении. Однако при рендеринге макета значение <span class="code">body</span> будет перезаписано
отображаемым представлением.</p>
<img src="images/template-rendering.png" id="template-rendering" alt="">

<h4>Использование (или неиспользование) макетов в Express</h4>
<p>По всей вероятности, большинство ваших страниц (если не все) станут использовать один и тот же макет, так что нет смысла указывать макет каждый раз при
визуализации страницы. Как вы видели, при создании шаблонизатора мы задали
имя макета по умолчанию:</p>
<pre><code >app.engine('handlebars', expressHandlebars({
    defaultLayout: 'main',
})</code></pre>
<p>По умолчанию Express ищет представления в подкаталоге <span class="code">views</span>, а макеты —
в подкаталоге <span class="code">layouts</span>. Так что, если у вас есть представление <span class="code">views/foo.handlebars</span>,
можете его визуализировать следующим образом:</p>
<pre><code >app.get('/foo', (req, res) => res.render('foo'))</code></pre>
<p>В качестве макета при этом будет использоваться <span class="code">views/layouts/main.handlebars</span>. Если вообще не хотите использовать макет (а значит, вам придется держать
весь шаблонный код в представлении), можете указать в контекстном объекте
<span class="code">layout: null</span>:</p>
<pre><code >app.get('/foo', (req, res) => res.render('foo', { layout: null }))</code></pre>
<p>А если хотите использовать другой шаблон, можете указать имя шаблона:</p>
<pre><code >app.get('/foo', (req, res) => res.render('foo', { layout: 'microsite' }))</code></pre>
<p>При этом будет визуализироваться представление с макетом <span class="code">views/layouts/
microsite.handlebars</span>.</p>
<p>Помните, что чем больше у вас шаблонов, тем проще должен быть ваш макет
HTML. В то же время это может оправдаться при наличии у вас страниц, сформированных по иному макету. В этом вопросе вам придется найти правильное соотношение для своих проектов.</p>

<h3>Секции</h3>
<p>В основе одного метода, который я позаимствовал у замечательного шаблонизатора
Razor, созданного компанией Microsoft, лежит идея секций. Макеты отлично работают, если каждое из представлений спокойно помещается в отдельный элемент
макета, но что произойдет, если представлению понадобится внедриться в другие
части макета? Распространенный пример — представление, которому требуется добавить что-либо в элемент <span class="code">&lt;head></span> или вставить <span class="code">&lt;script></span>, который из соображений
производительности иногда оказывается последним элементом макета.</p>
Ни у Handlebars, ни у <span class="code">express-handlebars</span> нет встроенного способа сделать это.
К счастью, хелперы Handlebars сильно облегчают эту задачу. При создании объекта
Handlebars мы добавим хелпер <span class="code">section</span>:
<pre><code >app.engine('handlebars', expressHandlebars({
    defaultLayout: 'main',
    helpers: {
        section: function(name, options) {
            if(!this._sections) this._sections = {}
            this._sections[name] = options.fn(this)
            return null
        },
    },
}))</code></pre>
Теперь мы можем использовать в представлении хелпер <span class="code">section</span>. Добавим
представление (<span class="code">views/jquery-test.handlebars</span>) для включения чего-либо в <span class="code">&lt;head></span> и скрипт:
<pre><code >{{#section 'head'}}
    &lt;!-- Мы хотим, чтобы Google игнорировал эту страницу -->
    &lt;meta name="robots" content="noindex">
{{/section}}
&lt;h1>Тестовая страница&lt;/h1>
&lt;p>Тестируем что-нибудь связанное со скриптом.&lt;/p>

{{#section 'scripts'}}
    &lt;script>
    document.querySelector('body')
        .insertAdjacentHTML('beforeEnd', '&lt;small>(scripting works!)&lt;/small>')
    &lt;/script>
{{/section}}</code></pre>


<p>А теперь можем разместить в нашем макете секции так же, как размещаем  <span class="code">{{{body}}}</span>:</p>
<pre><code >{{#section 'head'}}
    &lt;!-- Мы хотим, чтобы Google игнорировал эту страницу -->
    &lt;meta name="robots" content="noindex">
{{/section}}
&lt;h1>Тестовая страница&lt;/h1>
&lt;p>Тестируем что-нибудь связанное со скриптом.&lt;/p>
{{#section 'scripts'}}
&lt;script>
    const div = document.createElement('div')
    div.appendChild(document.createTextNode('(scripting works!)'))
    document.querySelector('body').appendChild(div)
&lt;/script>
{{/section}}</code></pre>


<h3>Частичные шаблоны</h3>
<p>Очень часто вам будут встречаться компоненты, которые вы захотите повторно
использовать на различных страницах (в кругах разработчиков клиентской части
их иногда называют виджетами). </p>
<p>Один из способов добиться этого с помощью
шаблонов — использовать частичные шаблоны (они не отображают целое представление или целую страницу, отсюда и название). Допустим, нам нужен компонент <span class="code">Current Weather</span>, отображающий текущие погодные условия в Портленде, Бенде
и Манзаните. Мы хотим сделать этот компонент пригодным для повторного использования, чтобы иметь возможность поместить его на любую нужную нам
страницу. Поэтому будем использовать частичный шаблон. Сначала создадим файл
частичного шаблона <span class="code">views/partials/weather.handlebars</span>:</p>
<pre><code >&lt;div class="weatherWidget">
    {{#each partials.weatherContext}}
    &lt;div class="location">
        &lt;h3>{{location.name}}&lt;/h3>
        &lt;a href="{{location.forecastUrl}}">
            &lt;img src="{{iconUrl}}" alt="{{weather}}">
            {{weather}}, {{temp}}
        &lt;/a>
    &lt;/div>
    {{/each}}
    &lt;small>Источник:
        &lt;a href="https://www.weather.gov/documentation/services-web-api">
            National Weather Service&lt;/a>&lt;/small>
&lt;/div></code></pre>
<p>Обратите внимание, что имя области видимости контекста начинается с <span class="code">partials.weatherContext</span>. Поскольку нам нужна возможность использовать частичный шаблон на любой странице, передавать контекст для каждого представления неудобно, так что вместо этого мы используем объект <span class="code">res.locals</span>, доступный для
каждого представления. Но, поскольку нам не хотелось бы пересекаться с контекстом, задаваемым отдельными представлениями, мы поместили весь частичный
контекст в объект <span class="code">partials</span>.</p>
<p><span class="code">express-handlebars</span> позволяет передавать частичные шаблоны как часть контекста.</p>
<p>Например, если вы добавите p<span class="code">artials.foo = "Шаблон!"</span> в ваш контекст, вы сможете
визуализировать этот частичный шаблон с помощью <span class="code">{{> foo}}</span>. При таком использовании любые файлы представлений <span class="code">.handlebars</span> будут переопределены, и именно
поэтому выше мы использовали <span class="code">partials.weatherContext</span> вместо <span class="code">partials.weather</span>,
которое переопределило бы <span class="code">views/partials/weather.handlebars</span>.</p>
<p>Далее мы увидим, как можно извлечь информацию о текущей погоде из
общедоступного <i>API National Weather Service</i>. Пока же просто будем использовать фиктивные данные, возвращаемые функцией, которую назовем <span class="code">getWeatherData</span>.</p>
<p>Мы хотим, чтобы в этом примере данные о погоде были доступны любому представлению, и наилучший механизм в этом случае — промежуточное ПО. Промежуточное ПО будет передавать данные
о погоде в объект <span class="code">res.locals.partials</span>, благодаря которому они будут доступны для частичных шаблонов.</p>
<p>Мы поместим промежуточное ПО в отдельный файл <span class="code">lib/middleware/weather.js</span>  для упрощения
его тестирования.</p>
<pre><code >const getWeatherData = () => Promise.resolve([
    {
        location: {
        name: 'Портленд',
        coordinates: { lat: 45.5154586, lng: -122.6793461 },
    },
    forecastUrl: 'https://api.weather.gov/gridpoints/PQR/112,103/forecast',
    iconUrl: 'https://api.weather.gov/icons/land/day/tsra,40?size=medium',
    weather: 'Вероятны грозы и ливни',
    temp: '59 F',
    },
    {
        location: {
            name: 'Бенд',
            coordinates: { lat: 44.0581728, lng: -121.3153096 },
    },
    forecastUrl: 'https://api.weather.gov/gridpoints/PDT/34,40/forecast',
    iconUrl: 'https://api.weather.gov/icons/land/day/tsra_sct,50?size=medium',
    weather: 'Местами грозы и ливни',
    temp: '51 F',
},
{
    location: {
        name: 'Манзанита',
        coordinates: { lat: 45.7184398, lng: -123.9351354 },
    },
    forecastUrl: 'https://api.weather.gov/gridpoints/PQR/73,120/forecast',
    iconUrl: 'https://api.weather.gov/icons/land/day/tsra,90?size=medium',
    weather: 'Грозы и ливни',
    temp: '55 F',
    },
])

const weatherMiddleware = async (req, res, next) => {
    if(!res.locals.partials) res.locals.partials = {}
    res.locals.partials.weatherContext = await getWeatherData()
    next()
}
module.exports = weatherMiddleware</code></pre>
<p>Теперь, когда все настроено, нам осталось сделать лишь одно — использовать
частичный шаблон в представлении. Например, чтобы поместить наш виджет на
домашнюю страницу, отредактируем <span class="code">views/home.handlebars</span>:</p>
<pre><code >&lt;h2>Домашняя страница&lt;/h2>
{{> weather}}</code></pre>
<p>Синтаксис вида <span class="code">{{> partial_name}}</span> описывает то, как вы включаете частичный шаблон в представление: <span class="code">express-handlebars</span> будет знать, что нужно искать представление <span class="code">partial_name.handlebars</span> (или <span class="code">weather.handlebars</span> в нашем примере)
в <span class="code">views/partials</span>.</p>
<span class="code">express-handlebars</span> поддерживает подкаталоги, так что, если у вас много частичных шаблонов, можете их упорядочить. Например, если у вас есть частичные шаблоны социальных медиа, можете разместить их в каталоге <span class="code">views/partials/social</span>
и включить с помощью <span class="code">{{> social/facebook}}</span>, <span class="code">{{> social/twitter}}</span> и т. д

<h3>Совершенствование шаблонов</h3>
<p>В основе вашего сайта лежат шаблоны. Хорошая структура шаблонов сократит
время разработки, повысит единообразие сайта и уменьшит число мест, в которых могут скрываться различные странности макетов. Но, чтобы получить этот
эффект, вам придется провести некоторое время за тщательным проектированием
шаблонов. Определить, сколько требуется шаблонов, — настоящее искусство;
в общем случае чем меньше, тем лучше, однако существует точка снижения эффективности, зависящая от однородности страниц. Шаблоны также являются
первой линией защиты от проблем межбраузерной совместимости и правильности
HTML. Они должны быть спроектированы с любовью и сопровождаться кем-то, кто
хорошо разбирается в разработке клиентской части. Отличное место для начала этой деятельности, особенно если вы новичок, HTML5 Boilerplate.</p>
<p>В предыдущих примерах мы использовали минимальный шаблон HTML5, чтобы
соответствовать книжному формату, но для нашего настоящего проекта будем
применять HTML5 Boilerplate.</p>
<p>Использование тем сторонних разработчиков начинается
с переименования основного файла (обычно <span class="code">index.html</span>) в <span class="code">main.handlebars</span> (или
дайте файлу макета другое название) и помещения всех ресурсов (CSS, JavaScript,
изображений) в используемый вами для статических файлов каталог public. Затем
нужно отредактировать файл шаблона и решить, куда вы хотите вставить выражение <span class="code">{{{body}}}</span>.</p>
<p>В зависимости от элементов шаблона вы можете захотеть переместить некоторые из них в частичные шаблоны. Отличный пример этого — «герой» (большой
баннер, разработанный специально для привлечения внимания пользователя).
Если «герой» должен отображаться на каждой странице (вероятно, не лучший
вариант), вы, наверное, оставите его в файле шаблона. Если он показывается
только на одной странице (обычно домашней), то его лучше поместить только
в это представление. Если он показывается на нескольких (но не на всех) страницах, то можно рассмотреть возможность его помещения в частичный шаблон.
Выбор за вами, и в этом состоит искусство создания оригинального привлекательного сайта.</p>