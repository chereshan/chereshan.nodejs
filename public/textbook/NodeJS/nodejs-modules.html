<!--<title>Глава 2. Модули NodeJS</title>-->
<h1>Глава 2. Модули NodeJS</h1>
<h2>Структурирование и повторное использование функциональности Node</h2>
<p>При создании приложения, с использованием Node или без, часто наступает момент, когда хранить весь код в одном файле становится слишком неудобно. В традиционном решении этой проблемы, представленном на <a href="#traditional-structure">рис. ниже</a>, разработчик брал файл с большим объемом кода и разбивал его на отдельные файлы.</p>
<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/XY3BYkt8/image.png' border='0' alt='image'/></a>
<p>В реализациях некоторых языков (таких как PHP и Ruby) внедрение логики из другого файла (включаемого) означает, что вся логика, выполняемая в файле, влияет на глобальную область видимости. Все создаваемые переменные и все функции, объявленные во включаемом файле, заменяют переменные и функции, созданные и объявленные приложением.</p>
<p>Предположим, вы программируете на PHP, и ваше приложение содержит следующую логику:</p>
<pre><code >function uppercase_trim($text) {
    return trim(strtoupper($text));
}
include('string_handlers.php');</code></pre>
<p>Если файл <span class="code">string_handlers.php</span> также попытается определить функцию <span class="code">uppercase_trim</span>, вы получите сообщение об ошибке:</p>
<div class="code-example-output-title"><span>Вывод:</span>
<div class="code-example-output">
<pre style="color:red;">
Fatal error: Cannot redeclare uppercase_trim()
</pre>
</div>
</div>
<p>В PHP эта проблема решается за счет использования пространств имен; аналогичную функциональность Ruby предлагает в виде модулей. Однако Node в принципе избегает эту потенциальную проблему, не предоставляя простых возможностей для случайного загрязнения глобального пространства имен.</p>
<p><b>Модули Node упаковывают код для повторного использования, но при этом не изменяют глобальную область видимости.</b></p>
<p>Предположим, вы разрабатываете <span data-tippy-content='<ul>Основные функции CMS:<li>предоставление инструментов для создания содержимого, организация совместной работы над содержимым;</li><li>управление содержимым: хранение, контроль версий, соблюдение режима доступа, управление потоком документов;</li><li>публикация содержимого;</li><li>представление информации в виде, удобном для навигации, поиска.</li></ul>'>систему управления контентом</span> (CMS) с открытым кодом на языке PHP и хотите использовать стороннюю библиотеку API, которая не использует пространства имен. Библиотека может содержать класс с таким же именем, как у вашего приложения, и этот класс нарушит работу вашего приложения, если только вы не переименуете свой класс в приложении или библиотеке. Однако изменение имени класса в приложении может создать проблемы у других разработчиков, которые пользуются вашей CMS-системой в своих проектах. После переименования класса в библиотеке вам придется помнить о необходимости повторять этот трюк каждый раз, когда вы обновляете библиотеку в дереве исходного кода вашего приложения. Конфликты имен — проблема, которую лучше избегать.</p>
<p>Имена модулей позволяют выбрать, какие функции и переменные из включенного файла будут доступны для приложения. <ul>
    <li>Если модуль возвращает более одной функции или переменной, модуль может указать их заданием свойств объекта с
        именем <span class="code">exports</span>.</li>
    <li>Если модуль возвращает одну функцию или переменную, вместо этого можно задать свойство <span class="code">module.exports</span>.</li>
</ul>
На <a href="#module-export-scheme">рис. ниже</a> показано, как работает эта схема.</p>
<a id="module-export-scheme" href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/XJw0qdRf/image.png' border='0' alt='image'/></a>
<p>Избегая загрязнения глобальной области видимости, система модулей Node предотвращает конфликты имен или упрощает повторное использование кода. После этого модули могут быть опубликованы в реестре <span class="code">npm</span>, сетевой подборке готовых модулей Node, и распространяться в сообществе Node. При этом пользователям модулей не нужно беспокоиться о том, что модуль случайно заменит переменные и функции другого модуля.</p>

<h2>Создание модулей</h2>
<p>Модуль может представлять собой как отдельный файл, так и каталог с одним или несколькими файлами - <span class="code">my_module.js</span>.</p>

<p>Если модуль оформлен в виде каталога, основному файлу в этом каталоге, который будет обрабатываться, обычно присваивается имя <span class="code">index.js</span>, а путь к этому файлу будет иметь вид <span class="code">my_module/index.js</span>.</p>
<p>Чтобы создать типичный модуль, создайте файл, определяющий свойства объекта <span class="code">exports</span> с любыми данными (строками, объектами, функциями и т. д.).</p>
<p>Чтобы продемонстрировать, как создаются базовые модули, мы добавим простейшую функциональность перерасчета валют в файл <span class="code">currency.js</span>. Этот файл, представленный в следующем листинге, содержит две функции для пересчета канадских долларов в американские, и наоборот.</p>
<pre><code >const canadianDollar = 0.91;
function roundTwo(amount) {
    return Math.round(amount * 100) / 100;
}
exports.canadianToUS = canadian => roundTwo(canadian * canadianDollar);
//Функция canadianToUS определяется в exports,
//чтобы она могла использоваться
//в коде, требующем этот модуль.
exports.USToCanadian = us => roundTwo(us/canadianDollar);</code></pre>
<p>Обратите внимание: задаются только два свойства объекта <span class="code">exports</span>. Таким образом, для приложения, включающего модуль, будут доступны только две функции: <span class="code">canadianToUS</span> и <span class="code">USToCanadian</span>. Переменная <span class="code">canadianDollar</span> закрыта от внешнего доступа: она влияет на логику работы <span class="code">canadianToUS</span> и <span class="code">USToCanadian</span>, но приложение не сможет обратиться к ней напрямую.</p>
<p>Чтобы использовать новый модуль в программе, воспользуйтесь функцией Node <span class="code">require</span> и передайте путь к нужному модулю в аргументе. Node выполняет синхронный поиск модуля и загружает его содержимое. Сначала Node ищет файлы среди базовых модулей, затем в текущем каталоге, и наконец, в каталоге <span class="code">node_modules</span>.</p>
<p><span class="code">require</span> — одна из немногих синхронных операций ввода/вывода в Node. Так как модули часто используются и обычно включаются в начале файла, синхронность <span class="code">require</span> помогает сохранить чистоту, упорядоченность и удобочитаемость кода.</p>
<p>Старайтесь избегать использования <span class="code">require</span> в частях вашего приложения, выполняющих интенсивный ввод/вывод. Любой синхронный вызов блокирует работу, не позволяя Node делать что-либо до завершения вызова. Например, если вы запустили HTTP-сервер, выполнение <span class="code">require</span> для каждого входного запроса снизит быстродействие приложения. Как правило, именно по этой причине <span class="code">require</span> и другие синхронные операции используются только при начальной загрузке приложения.</p>
<pre><code >const currency = require('./currency');
//./ в пути означает, что модуль находится
// в 1 каталоге со скриптом приложения
console.log('50 Canadian dollars equals this amount of US dollars:');
console.log(currency.canadianToUS(50));
console.log('30 US dollars equals this amount of Canadian dollars:');
console.log(currency.USToCanadian(30));</code></pre>
<p>Включение модуля с путем, начинающимся с <span class="code">./</span>, означает, что если вы создаете свой сценарий приложения с именем <span class="code">test-currency.js</span> в каталоге <span class="code">currency_app</span>, то файл модуля <span class="code">currency.js</span> также должен существовать в каталоге <span class="code">currency_app</span>. При необходимости расширение <span class="code">.js</span> подставляется по умолчанию, так что при желании его можно опустить.</p>
<p>Если расширение <span class="code">.js</span> не указано, Node также проверит файл <span class="code">.json</span> с заданным именем. Файлы <i>JSON</i> загружаются как объекты JavaScript. Если аргумент <span class="code">require</span> начинается с <span class="code">./</span>, Node проверяет тот каталог, в котором находится выполняемый файл.</p>
<p>После того как Node найдет и обработает ваш модуль, функция require возвращает содержимое объекта <span class="code">exports</span>, определенного в модуле. После этого вы сможете использовать две функции, возвращаемые модулем, для пересчета сумм в другую валюту.</p>
<p>Если вы захотите определить структуру модулей, разместите модули в подкаталогах, например, вы хотите хранить модуль currency в папке <span class="code">lib/</span>, то приведите строку <span class="code">require</span> к следующему виду:</p>
<pre><code >const currency = require('./lib/currency');</code></pre>
<h2>Настройка создания модуля с использованием <span class="code">module.exports</span></h2>
<p>Хотя заполнение объекта <span class="code">exports</span> функциями и переменными хорошо подходит для большинства случаев, время от времени требуется создать модуль с отклонением от этой модели.</p>
<p>Например, модуль пересчета валют из предыдущего раздела можно переписать таким образом, чтобы он возвращал одну функцию-конструктор <span class="code">Currency</span> вместо объекта, содержащего функции. Объектно-ориентированная реализация может выглядеть примерно так:</p>
<pre><code >const Currency = require('./currency');
const canadianDollar = 0.91;
const currency = new Currency(canadianDollar);
console.log(currency.canadianToUS(50));</code></pre>
<p>Возвращение функции из <span class="code">require</span> (вместо объекта) сделает ваш код более элегантным — если это единственное, что требуется от модуля.</p>
<p>Казалось бы, чтобы создать модуль, возвращающий одну переменную или функцию, нужно присвоить <span class="code">exports</span> то, что вы хотите вернуть. Однако такое решение не сработает, потому что Node не ожидает, что <span class="code">exports</span> будет присваиваться любой другой объект, функция или переменная. Код модуля в следующем листинге пытается присвоить <span class="code">exports</span> функцию. Модуль ниже не будет работать:</p>
<pre><code >class Currency {
    constructor(canadianDollar) {
    this.canadianDollar = canadianDollar;
}
    roundTwoDecimals(amount) {
        return Math.round(amount * 100) / 100;
    }
    canadianToUS(canadian) {
        return this.roundTwoDecimals(canadian * this.canadianDollar)
    }
    USToCanadian(us) {
        return this.roundTwoDecimals(us / this.canadianDollar);
    }
}
exports = Currency;
//Ошибка; Node не позволяет переписывать exports.
</code></pre>
<p>Чтобы приведенный код модуля работал так, как ожидается, нужно заменить <span class="code">exports</span> на <span class="code">module.exports</span>. Механизм <span class="code">module.exports</span> позволяет экспортировать одну переменную, функцию или объект.</p>
<p><b>Если вы создаете модуль, который заполняет как <span class="code">exports</span>, так и <span class="code">module.exports</span>, то возвращается <span class="code">module.exports</span>, а <span class="code">exports</span> игнорируется.</b></p>
<p>В конечном итоге в вашем приложении экспортируется <span class="code">module.exports</span>. <span class="code">exports</span> задается как глобальная ссылка на <span class="code">module.exports</span> — изначально это пустой объект, к которому можно добавлять свойства. <span class="code">exports.myFunc</span> — сокращенная запись для <span class="code">module.exports.myFunc</span>.</p>
<p>В результате присваивание <span class="code">exports</span> другой ссылки разрывает связь между <span class="code">module.exports</span> и <span class="code">exports</span>. Так как экспортируется <span class="code">module.exports</span>, <span class="code">exports</span> работает не так, как ожидается, — он уже не ссылается на <span class="code">module.exports</span>. </p>
<p>Чтобы сохранить эту связь, снова включите в <span class="code">module.exports</span> ссылку на <span class="code">exports</span>:</p>
<pre><code >module.exports = exports = Currency;</code></pre>
<p>Использовав <span class="code">exports</span> или <span class="code">module.exports</span> в зависимости от ваших потребностей, вы сможете распределить функциональность по модулям и избежать проблем с постоянно растущими сценариями приложения.</p>

<h2>Повторное использование модулей с папкой <span class="code">node_modules</span></h2>
<p>Включение модулей с указанием их местонахождения в файловой системе относительно приложения полезно для организации кода, специфического для данного приложения. Иначе дело обстоит с кодом, предназначенным для использования в нескольких приложениях или распространения среди других разработчиков. Node имеет уникальный механизм повторного использования кода, который позволяет включать модули без точной информации об их местонахождении в файловой системе. Этот механизм основан на использовании каталогов <span class="code">node_modules</span>.</p>
<p>В приведенном ранее примере включался модуль <span class="code">./currency</span> . Если убрать <span class="code">./</span> и включить просто <span class="code">currency</span>, Node начинает искать этот модуль по схеме, представленной на <a href="#module-search-hierarchy">рис. ниже</a>.</p>
<a id="module-search-hierarchy" href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/rw0x9gCc/image.png' border='0' alt='image'/></a>
<p>Переменная окружения <span class="code">NODE_PATH</span> позволяет выбрать альтернативные каталоги для хранения модулей Node. Если переменная <span class="code">NODE_PATH</span> используется, ей должен быть присвоен список каталогов, разделенных символом точки с запятой (<span class="code">;</span>) в Windows или двоеточием (<span class="code">:</span>) в других операционных системах.</p>

<h2>Потенциальные проблемы</h2>
<p>Хотя система модулей Node устроена достаточно прямолинейно, вы должны учитывать два обстоятельства.</p>
<p>Во-первых, если модуль представляет собой каталог, файл в каталоге модуля, который будет обработан, должен называться <span class="code">index.js</span>, если только обратное не указано в файле package.json в каталоге модуля. Чтобы задать другой файл вместо <span class="code">index.js</span>, файл <span class="code">package.json</span> должен содержать данные JSON, определяющие объект с ключом <span class="code">main</span> и значением, которое определяет путь к основному файлу в каталоге модуля. Эти правила обобщены в блок-схеме на <a href="#nodejs-package-json">рис. ниже</a>.</p>
<a id="nodejs-package-json" href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/rFzr8gHW/image.png' border='0' alt='image'/></a>
<p>Пример файла <span class="code">package.json</span>, который назначает основным файлом <span class="code">currency.js</span>:</p>
<pre><code >{
"main": "currency.js"
}</code></pre>
<p>Другое обстоятельство, о котором следует помнить, — это способность Node кэшировать модули как объекты. Если два файла в приложении включают один и тот же модуль, то данные, возвращенные для первого вызова <span class="code">require</span>, будут сохранены в памяти, поэтому второму вызову <span class="code">require</span> не нужно будет проверять исходные файлы модуля. А это означает, что загрузка модуля с вызовом <span class="code">require</span> в том же процессе вернет тот же объект.</p>
<p>Представьте, что вы создаете веб-приложение MVC, у которого имеется основной объект приложения. Вы можете настроить этот объект, экспортировать его, а затем включить в любой точке проекта вызовом <span class="code">require</span>. Если в объект приложения были добавлены полезные данные конфигурации, вы сможете обратиться к ним из других файлов — при условии, что проект имеет следующую структуру каталогов:</p>
<pre><code >проект
    app.j s
    models
        post.js</code></pre>
<a href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/bdXpfzMm/image.png' border='0' alt='image'/></a>



