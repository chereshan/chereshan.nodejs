<!--<title>Глава 999. Не сортировано</title>-->
<h1>Глава 999. Не сортировано</h1>
<h2>Неблокирующий ввод/вывод</h2>
<p>Что это означает в контексте программирования <i>"на стороне сервера"</i>? Запросы ввода/вывода (например, обращения к диску или сетевым ресурсам) выполняются относительно медленно, поэтому исполнительная среда не должна блокировать выполнение бизнес-логики во время чтения файлов или передачи сообщений по сети. </p>
<p>Для этого в Node используются три концепции:
<b>события</b>, <b>асинхронные API</b>, <b>неблокирующий ввод/вывод</b>.</p>
<p><b>Неблокирующий ввод/вывод</b> — низкоуровневый термин с точки зрения программиста Node. Он означает, что программа может обратиться с запросом к сетевому ресурсу и заняться чем-то другим. А потом, когда сетевая операция будет завершена, выполняется функция обратного вызова, которая обработает результат.</p>
<p>На <a href="#async_nonblocking_components">рис. ниже</a> изображено типичное веб-приложение Node, использующее библиотеку веб-программирования Express для обработки заказов в магазине. В нем:</p>
<ol>
    <li>Браузер выдает запрос на приобретение продукта;</li>
    <li>приложение проверяет текущее состояние складских запасов</li>
    <li>создает учетную запись для пользователя</li>
    <li>отправляет квитанцию по электронной почте</li>
    <li>возвращает HTTP-ответ в формате JSON</li>
    <b>Одновременно с этим:</b>
    <li>квитанция отправляется по электронной почте</li>
    <li>база данных обновляется информацией от пользователя и данными заказа</li>
</ol>
<p>По сути, перед нами прямолинейный императивный код JavaScript, но исполнительная среда работает параллельно, потому что она использует неблокирующий ввод/вывод.</p>
<a id="async_nonblocking_components" href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/qMCJhnpt/image.png' border='0' alt='image'/></a>
<p>На <a href="#async_nonblocking_components">рис. выше</a> приложение обращается к базе данных по сети. В Node сетевые операции выполняются без блокировки, потому что Node при помощи библиотеки <span class="code">libuv</span> использует неблокирующие сетевые вызовы операционной системы. Эта функциональность по-разному реализована для Linux, macOS и Windows, но вам придется иметь дело только с удобной библиотекой JavaScript для работы с базами данных. Хотя вы пишете команды типа <span class="code">db.insert(query, err => {})</span>, Node во внутренней реализации выполняет оптимизированные неблокирующие сетевые операции.</p>
<p>Обращения к диску происходят примерно так же, но, как ни странно, полного совпадения нет. Когда приложение генерирует квитанцию, отправляемую по электронной почте, и шаблон сообщения читается с диска, <span class="code">libuv</span> использует пул потоков для создания иллюзии использования неблокирующего вызова. Управление пулом потоков — довольно тяжелое дело, но понять команду <span class="code">email.send('template.ejs', (err, html) => {})</span> определенно намного проще.</p>
<p>Истинное преимущество использования асинхронных API с неблокирующими операциями ввода/вывода заключается в том, что Node может заниматься другими делами во время выполнения относительно медленных процессов. И хотя выполняться может только однопоточное и однопроцессное веб-приложение Node, в любой момент времени оно может обрабатывать сразу несколько подключений от тысяч потенциальных посетителей сайта. Чтобы понять, как это происходит, необходимо познакомиться с циклом событий.</p>
<h2>Цикл событий</h2>
<p>Cосредоточимся на одном конкретном аспекте: <b>обработке запросов браузера</b>. <a href="#async_nonblocking_components">В примере выше</a> базовый модуль с именем <span class="code">http.Server</span> обрабатывает запрос с использованием потоков, событий и парсера HTTP-запросов Node, который содержит платформенный код. При этом инициируется выполнение функции обратного вызова в вашем приложении, которая была добавлена средствами библиотеки веб-приложений Express. Выполняемая функция обратного вызова выдает запрос к базе данных, и в конечном итоге приложение отвечает данными JSON с использованием HTTP. Весь процесс использует как минимум три неблокируемых сетевых вызова: один для запроса, один для базы данных и один для ответа. Как Node планирует все эти неблокирующие сетевые операции? Ответ: при помощи <b>цикла событий</b>. На <a href="#event-cycle">рис. ниже</a> показано, как цикл событий используется для этих трех сетевых операций</p>
<a id="event-cycle" href='https://postimages.org/' target='_blank'><img src='https://i.postimg.cc/02YZZWf7/image.png' border='0' alt='image'/></a>
<p>Цикл событий работает в одном направлении (он реализуется очередью <span data-tippy-content='"first-in-first-out"="первым пришел, первым вышел"'>FIFO</span> и проходит через несколько фаз. На <a href="#event-cycle">рис. выше</a> показана упрощенная последовательность важнейших фаз, выполняемых при каждой итерации цикла:</p>
<ol>
    <li>Сначала выполняются таймеры, выполнение которых запланировано функциями JavaScript <span class="code">setTimeout</span> и <span class="code">setInterval</span>.</li>
    <li>Затем выполняются обратные вызовы ввода/вывода, поэтому если один из неблокирующих сетевых вызовов вернул какой-либо ввод/вывод, в этот момент будет инициирован ваш обратный вызов.</li>
    <li>В фазе опроса читаются новые события ввода/вывода</li>
    <li>в конце инициируются обратные вызовы, запланированные функцией <span class="code">setImmediate</span>. Это особый случай, потому что он позволяет запланировать немедленное выполнение обратных вызовов после текущих обратных вызовов ввода/вывода, уже находящихся в очереди.</li>
</ol>


<h2>Основы программирования в Node</h2>
<h3>Вывод на консоль</h3>
<p>Если вы привыкли к программированию на JavaScript для веб-браузеров, тогда одним из небольших сюрпризов, касающихся Node, будет то, что функция
    <span class="code">console.log()</span> предназначена не только для отладки. Она является простейшим способом отображения сообщения пользователю в Node или в более общем плане отправки вывода в поток stdout. Вот как выглядит классическая
    программа <span class="code">“Hello World”</span> в Node:</p>
<pre><code >console.log("Hello World!");</code></pre>

<p>В веб-браузерах <span class="code">console.log()</span>, <span class="code">console.warn()</span> и <span class="code">console.error()</span>, как правило, отображают маленькие значки рядом со своим выводом в консоли инструментов разработчика, чтобы обозначать различные журнальные
    сообщения.</p>

<h3>Аргументы командной строки и переменные среды</h3>
<p>Если вы ранее писали программы в стиле Unix, предназначенные для вызова из окна терминала или другого интерфейса командной строки, то вам известно, что такие программы обычно получают свой ввод в первую очередь из аргументов командной строки и во вторую очередь из переменных среды.</p>
<p>Среда Node следует таким соглашениям Unix. Программа Node может читать свои аргументы командной строки из массива строк <span class="code">process.argv</span>. Первый элемент этого массива всегда будет путем к исполняемому файлу Node. Второй аргумент — путь к файлу кода JavaScript, который Node выполняет. Оставшиеся элементы в массиве <span class="code">process.argv</span> являются аргументами, отделенными друг от друга пробелами, которые вы передали в командной строке, когда вызывали Node. Например, пусть вы сохранили приведенную ниже очень короткую программу Node в файле <span class="code">argv.js</span>:</p>
<pre><code>console.log(process.argv);</code></pre>
<p><b>Вывод:</b></p>
<pre><code >$ node --trace-uncaught argv.js --arg1 --arg2 filename
[
    '/usr/local/bin/node',
    '/private/tmp/argv.js',
    '--arg1',
    '--arg2',
    'filename'
]</code></pre>
<p>Здесь необходимо отметить два момента:</p>
<ul>
    <li>Первый и второй элементы <span class="code">process.argv</span> будут полными путями в файловой системе к исполняемому файлу Node и запущенному файлу кода JavaScript, даже если вы не вводили их в таком виде.</li>
    <li>Аргументы командной строки, которые предназначены для Node и интерпретируются им, потребляются самим исполняемым файлом Node и не присутствуют в <span class="code">process.argv</span>. (Аргумент командной строки <span class="code">--trace-uncaught</span> в предыдущем примере фактически не делает ничего полезного; он нужен лишь для того, чтобы продемонстрировать его отсутствие в выводе.) Любые аргументы (наподобие <span class="code">--arg1</span> и <span class="code">filename</span>) следующие после имени файла кода JavaScript, будут появляться в <span class="code">process.argv</span>.</li>
</ul>
<p>Программы Node могут также принимать ввод от переменных среды в стиле
    Unix. Среда Node делает их доступными через объект <span class="code">process.env</span>. Именами свойств этого объекта будут имена переменных среды, а значениями (всегда строковыми) свойств — значения переменных среды.</p>
<p>Вот неполный список переменных среды в некоторой системе:</p>
<pre><code >$ node -р -е 'process.env'
{
    SHELL: '/bin/bash',
    USER: 'david',
    PATH: '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin',
    PWD: '/tmp',
    LANG: 'en_US.UTF-8',
    HOME: '/Users/david',
}</code></pre>
<p>Вы можете использовать <span class="code">node -h</span> или <span class="code">node -help</span>, чтобы выяснить, для чего предназначены аргументы командной строки <span class="code">-р</span> и <span class="code">-е</span>. Однако имейте в виду, что вы могли бы переписать предыдущую строку следующим образом: <span class="code">node --eval 'process.env' --print</span>.</p>


