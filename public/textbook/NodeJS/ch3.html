<!--<title>Глава 3. Express</title>-->
<h1>Глава 3. Express</h1>

<h2>Введение в Express</h2>
<p>Сайт Express характеризует Express как «<i>минималистичный и гибкий фреймворк для веб-приложений Node.js, обеспечивающий набор возможностей для построения веб- и мобильных приложений</i>». Что же это такое на самом деле? Разобьем описание на составные части:</p>
<ul>
    <li><b>Минималистичный</b>. Философия Express заключается в обеспечении минимальной прослойки между вами и сервером. Это не говорит о слабой надежности фреймворка или недостаточном количестве его полезных возможностей. Просто он в меньшей степени становится у вас на пути, позволяя более полно выражать свои идеи. Express предоставляет вам минималистичный фреймворк, а вы можете добавлять необходимый функционал в разных его частях, заменяя то, что вам никогда не понадобится. Зачастую первой задачей становится отсечение ненужного функционала или замена того, который не соответствует требованиям. Express практикует другой подход, позволяя вам добавлять то, что нужно, там, где нужно.</li>
    <li><b>Гибкий</b>. Механизм действия Express очень прост: он принимает HTTP-запрос от клиента и возвращает HTTP-ответ. Этот базовый шаблон описывает практически все, связанное с Интернетом, что делает приложения Express чрезвычайно гибкими.</li>
    <li><b>Фреймворк для веб-приложений</b>. Более точным описанием будет <i>«серверная часть фреймворка для веб-приложений»</i>. На сегодня под «фреймворками для веб-приложений» обычно имеются в виду фреймворки одностраничных приложений, такие как <i>React</i>, <i>Angular</i> или <i>Vue</i>. Тем не менее за исключением небольшой группы отдельных приложений, большинство веб-приложений должно обмениваться данными и взаимодействовать с другими сервисами. Обычно это происходит через веб-API, который можно рассматривать как серверный компонент фреймворка веб-приложений. Обратите внимание, что построение всего приложения с рендерингом только на стороне сервера по-прежнему возможно (а иногда и желательно). В этом случае Express вполне может быть фреймворком всего веб-приложения!</li>
    <li><b>Быстрый</b>. Express, став одним из лучших фреймворков для платформы Node.js, привлек много внимания со стороны больших компаний с высокопроизводительными и сильно нагруженными веб-сайтами. Это вынудило команду по разработке Express сконцентрироваться на производительности, и теперь Express — лидер в этом сегменте.</li>
    <li><b>Некатегоричный</b>. Одними из отличительных особенностей экосистемы JavaScript являются ее размер и разнообразие. Ввиду того что Express зачастую занимает центральную позицию в разработке веб-приложений в Node.js, существуют сотни (если не тысячи) страниц сообщества, где подробно рассматриваются приложения Express. Разработчики Express, в свою очередь, предоставили чрезвычайно гибкую систему разработки промежуточного ПО, которая упрощает использование выбранных вами компонентов при создании приложения. В процессе разработки можно заметить, что Express отключает встроенные компоненты в пользу настраиваемого промежуточного ПО. </li>
</ul>

<h2>Приложения на стороне сервера и на стороне клиента</h2>
<p>В <i>приложении на стороне сервера</i> рендеринг страниц (включая HTML, CSS, изображения и другие мультимедийные объекты и JavaScript) происходит на сервере, и затем они отправляются клиенту.</p>
<p>В <i>приложении на стороне клиента</i>, напротив, большая часть пользовательского интерфейса отображается из исходного кода приложения, отправка которого происходит однократно. То есть после получения начального (обычно очень минимального) HTML-кода браузер динамически преобразует DOM с помощью JavaScript. Отображение новых страниц не зависит от сервера, хотя необработанные данные по-прежнему поступают с него.</p>
<p>Приложения на стороне сервера часто называются <b>приложениями с рендерингом
на стороне сервера</b> (<i>server-side rendered</i>, <i>SSR</i>), а приложения на стороне клиента — <b>одностраничными приложениями</b> (<i>SPA</i>).</p>
<p>Приложения на стороне клиента полностью реализуются в таких средах, как React, Angular и Vue. «Одностраничные приложения» — не совсем точное название, ведь с точки зрения пользователя они могут состоять из множества страниц. Единственное отличие состоит в том, что страницы загружаются с сервера или динамически отображаются на стороне клиента.</p>
<p>На самом деле грань между приложениями на стороне сервера и на стороне клиента размыта. В большинстве приложений на стороне клиента есть 2–3 HTML-пакета, которые могут быть отправлены клиенту (например, открытый интерфейс авторизации или обычный интерфейс и интерфейс администратора).</p>
<p>Кроме того, для увеличения производительности загрузки первой страницы и для
поисковой оптимизации (<i>search engine optimization</i>, <i>SEO</i>) одностраничные приложения зачастую комбинируются с рендерингом на стороне сервера.</p>
<p>Как правило, если с сервера отправляется небольшое количество HTML-файлов
(обычно от одного до трех), а интерфейс пользователя многофункциональный,
с большим количеством страниц и основан на динамическом управлении объектной моделью документов, то применяется рендеринг на стороне клиента. Большая
часть данных (обычно в формате JSON) и мультимедийных ресурсов для различных представлений по-прежнему загружается из сети.</p>
<p>Для Express не имеет значения, создаете вы приложение на стороне сервера
или на стороне клиента: он хорош в обоих случаях. Для него безразлично, какое
количество HTML-пакетов вы предоставляете: один или сотню.</p>


<h2>Краткая история Express</h2>
<p>Создатель Express Ти Джей Головайчук описывает Express как веб-фреймворк, вдохновленный основанным на Ruby веб-фреймворком Sinatra. Ничего удивительного, что Express заимствует идеи у фреймворка, написанного на Ruby: последний, будучи нацеленным на большую эффективность веб-разработки, ее ускорение и упрощение ее сопровождения, стал источником множества замечательных подходов к веб-разработке.</p>
<p>Хотя Express был вдохновлен фреймворком Sinatra, он тесно переплетен с <span class="code">Connect</span> — подключаемой библиотекой для Node. <span class="code">Connect</span> использует термин «промежуточное ПО» (<i>middleware</i>) для описания подключаемых модулей Node, которые
могут в различной степени обрабатывать веб-запросы. В 2014 г. в версии 4.0 Express была удалена зависимость от Connect, но этот фреймворк по-прежнему включает позаимствованную из <span class="code">Connect</span> концепцию промежуточного ПО.</p>

<h2>Скаффолдинг</h2>
<p><b>Скаффолдинг</b> - идея не новая и многие люди впервые знакомятся с этой концепцией благодаря Ruby. Идея проста: большинству проектов требуется определенное количество так называемого <i>шаблонного</i>, или стандартного, кода. Простой способ решения проблемы — создать черновой каркас проекта и всякий раз, когда необходимо, просто копировать этот каркас, иначе говоря, шаблон.</p>
<p><i>Ruby on Rails</i> развивает эту концепцию, обеспечивая программу, автоматически генерирующую скаффолдинг. Преимущество данного подхода в том, что этим способом можно сгенерировать более совершенный фреймворк, чем тот, что получается при обычном выборе из набора шаблонов.</p>
<p>Express следует примеру Ruby on Rails и предоставляет вспомогательную программу для генерации начального скаффолдинга для вашего проекта Express.</p>

<h2>Создание сайта с помощью Express</h2>
<h3>Первые шаги</h3>
<p>Начнем с создания корневого каталога проекта. В данной книге везде, где речь
о каталоге проекта, каталоге приложения или корневом каталоге, имеется в виду
этот каталог.</p>
<p><span class="code">npm</span> хранит описание зависимостей проекта — как и относящиеся к проекту
метаданные — в файле <span class="code">package.json</span>. Простейший способ создать этот файл —
выполнить команду <span class="code">npm init</span>: программа задаст вам ряд вопросов и сгенерирует
<span class="code">package.json</span> для начала работы (на вопрос относительно точки входа (<i>entry point</i>)
введите <span class="code">meadowlark.js</span> или используйте название своего проекта).</p>
<p>Первым шагом будет установка Express. Выполните следующую команду <span class="code">npm</span>:</p>
<pre><code >npm install express</code></pre>
Выполнение <span class="code">npm install</span> установит указанный(е) пакет(ы) в каталог <span class="code">node_modules</span> и обновит файл <span class="code">package.json</span>. Поскольку каталог <span class="code">node_modules</span> в любой момент может быть восстановлен с помощью <span class="code">npm</span>, мы не станем сохранять его в нашем репозитории. Чтобы убедиться, что мы не добавили его случайно в репозиторий, создадим файл с именем <span class="code">.gitignore</span>:
<pre><code ># Игнорировать установленные npm пакеты
node_modules
# Поместите сюда любые другие файлы, которые
# не хотите вносить, такие как .DS_Store (OSX), *.bak и т. д.</code></pre>
<pre><code >const express = require('express')
const app = express()
const port = process.env.PORT || 3000
// Пользовательская страница 404
app.use((req, res) => {
    res.type('text/plain')
    res.status(404)
    res.send('404 — Не найдено')
})
// Пользовательская страница 500
app.use((err, req, res, next) => {
    console.error(err.message)
    res.type('text/plain')
    res.status(500)
    res.send('500 — Ошибка сервера')
})
app.listen(port, () => console.log(
`Express запущен на http://localhost:${port}; ` +
`нажмите Ctrl+C для завершения.` ))</code></pre>
<p>Многие руководства, равно как и генератор скаффолдинга Express, призывают вас
называть основной файл <span class="code">app.js</span> (иногда <span class="code">index.js</span> или <span class="code">server.js</span>). Если вы не пользуетесь хостингом или системой развертывания, требующей определенного имени
главного файла приложения, то основной файл лучше назвать по наименованию
проекта. Каждый, кто когда-либо вглядывался в кучу закладок редактора, поголовно называвшихся <span class="code">index.html</span>, сразу же оценит мудрость такого решения.
<span class="code">npm init</span> по умолчанию даст имя <span class="code">index.js</span>. Если вам нужно другое имя, не забудьте
изменить свойство <span class="code">main</span> в файле <span class="code">package.json</span>.</p>
<p>Теперь у вас есть минимальный сервер Express. Можете запустить его (<span class="code">node meadowlark.js</span>) и перейти на <span class="code">http://localhost:3000</span>. Результат будет неутешительным:
вы не предоставили Express никаких маршрутов, поэтому он просто выдаст вам
обобщенную страницу 404, указывающую, что запрошенной страницы не существует.</p>
<p>Обратите внимание, как мы выбрали порт, на котором хотим запустить наше приложение: <span class="code">const port = process.env.PORT || 3000</span>. Это позволяет переопределить порт путем установки переменной среды перед запуском сервера. Если ваше приложение не запускается на порте 3000 при запуске этого примера, проверьте, установлена ли переменная среды <span class="code">PORT</span>.</p>
<p>Добавим маршруты для домашней страницы и страницы <i>"О нас"</i>. Перед обработчиком ошибки 404 добавляем два новых маршрута:</p>
<pre><code >app.get('/', (req, res) => {
    res.type('text/plain')
    res.send('Meadowlark Travel');
})
app.get('/about', (req, res) => {
    res.type('text/plain')
    res.send('О Meadowlark Travel')
})
// Пользовательская страница 404
app.use((req, res) => {
    res.type('text/plain')
    res.status(404)
    res.send('404 — Не найдено'))
})</code></pre>
<p><span class="code">app.get</span> — метод, с помощью которого мы добавляем маршруты. В документации Express вы увидите <span class="code">app.METHOD</span>. Не стоит думать, что существует метод
с буквальным названием <span class="code">METHOD</span>. Это просто заполнитель для ваших (набранных
в нижнем регистре) HTTP-методов (наиболее распространенные — <span class="code">GET</span> и <span class="code">POST</span>).
Этот метод принимает два параметра: <i>путь</i> и <i>функцию</i>.</p>
<p><i>Путь</i> — то, что определяет маршрут. Заметьте, <span class="code">app.METHOD</span> выполняет за вас тяжелую работу: по умолчанию он игнорирует регистр и косую черту в конце строки, а также не берет во внимание строку запроса при выполнении сравнения. Так что маршрут для страницы <i>"О нас"</i> будет работать для <span class="code">/about</span>, <span class="code">/About</span>, <span class="code">/about/</span>,
<span class="code">/about?foo=bar</span>, <span class="code">/about/?foo=bar</span> и т. п.</p>
<p>Созданная вами функция будет вызываться при совпадении маршрута. Передаваемые этой функции параметры — объекты запроса и ответа. Просто возвращаем неформатированный текст с кодом состояния 200 (в Express код состояния по умолчанию равен 200 — необходимости указывать его явным образом нет).</p>
<p>Вместо низкоуровневого метода Node <span class="code">res.end</span> мы будем использовать расширения от Express <span class="code">res.send</span>. Помимо этого, заменим метод Node <span class="code">res.writeHead</span> методами <span class="code">res.set</span> и <span class="code">res.status</span>. Express также предоставляет нам для удобства метод <span class="code">res.type</span>, устанавливающий заголовок <span class="code">Content-Type</span>. Несмотря на то, что по-прежнему можно
использовать методы <span class="code">res.writeHead</span> и <span class="code">res.end</span>, делать это не рекомендуется.</p>
<p>Обратите внимание, что наши пользовательские страницы 404 и 500 должны
обрабатываться несколько иначе. Вместо использования <span class="code">app.get</span> применяется <span class="code">app.use</span>.</p>
<p><span class="code">app.use</span> — метод, с помощью которого Express добавляет промежуточное ПО. Вы можете думать о промежуточном ПО как об обобщенном обработчике всего, для чего не находится совпадающего маршрута.</p>

<p>Это натолкнет нас на очень важный вывод: <b>в Express порядок
добавления маршрутов и промежуточного ПО имеет значение</b>. Если мы вставим
обработчик ошибки 404 перед маршрутами, домашняя страница и страница О нас
перестанут функционировать. Их URL будут приводить к странице 404. Пока что
наши маршруты довольно просты, но они также поддерживают метасимволы, что
может вызвать проблемы с определением порядка следования. Например, если мы
хотим добавить к странице О нас такие подстраницы, как <span class="code">/about/contact</span> и <span class="code">/about/directions</span>, следующий код не будет работать ожидаемым образом:</p>
<pre><code >app.get('/about*', (req,res) => {
// Отправляем контент...
})
app.get('/about/contact', (req,res) => {
// Отправляем контент...
})
app.get('/about/directions', (req,res) => {
// Отправляем контент...
})</code></pre>
В этом примере обработчики <span class="code">/about/contact</span> и <span class="code">/about/directions</span> никогда
не будут достигнуты, поскольку первый обработчик содержит метасимвол в своем
пути: <span class="code">/about*</span>.
<p>Express может различить обработчики ошибок 404 и 500 по количеству аргументов, принимаемых их функциями обратного вызова.</p>
<p>До сих пор мы не делали ничего, что нельзя было бы так же легко выполнить
без Express, но Express уже предоставил нам некоторую не совсем тривиальную
функциональность. С чистым Node.js приходилось приводить <span class="code">req.url</span> к единому виду, чтобы определить, какой ресурс был запрошен. Нужно было вручную убрать строку запроса и косую черту в конце строки, а также преобразовать к нижнему регистру. Маршрутизатор Express теперь обрабатывает эти нюансы автоматически. И хотя сейчас это может показаться не такой уж и важной вещью, это лишь малая часть того, на что способен Express.</p>

<h3>Представления и макеты</h3>
<p>Если вы хорошо знакомы с парадигмой <i>«Модель — представление — контроллер»</i>, то концепция представления для вас не нова. По сути, <b>представление</b> — то, что выдается пользователю. В случае с сайтом это, как правило, HTML-код, хотя вы также можете выдавать PNG, PDF или что-то другое, что может быть отображено клиентом. В нашем случае будем полагать, что представление — это HTML-код.</p>
<p>Отличие представления от статического ресурса, такого как изображение или
файл CSS, в том, что представление не обязано быть статическим: HTML-код может быть создан на лету для формирования персонализированной страницы для
каждого запроса.</p>
<p>Express поддерживает множество разных механизмов представлений, обеспечивающих различные уровни абстракции. В какой-то степени он отдает предпочтение механизму представления <b>Pug</b> (что неудивительно, ведь это тоже детище Ти Джея Головайчука). Используемый Pug подход весьма минималистичен: то, то вы пишете, вообще не похоже на страницу HTML — количество набираемого текста уменьшилось, нет никаких угловых скобок и закрывающих тегов. Движок Pug получает это на входе и преобразует в HTML-код.</p>
<p>Pug привлекателен, однако подобный уровень абстракции имеет свою цену.
Если вы разработчик клиентской части, вам нужно хорошо понимать HTML-код
даже в том случае, когда вы фактически пишете свои представления в Pug. Большинство моих знакомых разработчиков клиентской части ощущают дискомфорт при одной лишь мысли об абстрагировании их основного языка разметки. Поэтому
я рекомендую использовать другой, менее абстрактный, фреймворк шаблонизации — <b>Handlebars</b>.</p>

<!--todo: возможно всю инфу о шаблонизаторах стоит перенести в отдельную главу-->
<h4>Шаблонизатор Handlebars</h4>
<p>Handlebars, основанный на популярном, независимом от языка программирования языке шаблонизации <i>Mustache</i>, не пытается абстрагировать HTML: вы пишете HTML-код с помощью специальных тегов, позволяющих Handlebars внедрять
контент.</p>
<p>Чтобы обеспечить поддержку Handlebars, будем использовать пакет <span class="code">express-handlebars</span>, созданный Эриком Феррайоло. Выполните следующее в вашем каталоге проекта:</p>
<pre><code >npm install express-handlebars</code></pre>
<p>Затем модифицируйте несколько первых строк в <span class="code">meadowlark.js</span>:</p>
<pre><code >const express = require('express')
const expressHandlebars = require('express-handlebars')
const app = express()
// Настройка механизма представлений Handlebars.
app.engine('handlebars', expressHandlebars({
    defaultLayout: 'main',
}))
app.set('view engine', 'handlebars')</code></pre>
<p>Это создает механизм представления и настраивает Express для использования
по умолчанию. Теперь создадим каталог <span class="code">views</span> с подкаталогом <span class="code">layouts</span>. Если вы
опытный веб-разработчик, то, вероятно, хорошо знакомы с понятием <i>макетов</i>
(иногда их называют <i>шаблонами страниц</i>). Когда вы создаете сайт, одни и те же (или почти одни и те же) определенные фрагменты HTML-кода повторяются на
каждой странице. Переписывать весь этот дублирующийся код не только утомительно, но и рискованно: если вы захотите изменить что-то на каждой странице, вам придется изменять все файлы. Макеты освобождают вас от этой необходимости, обеспечивая общий фреймворк для всех страниц вашего сайта.</p>

<p>Итак, создадим шаблон для нашего сайта. Создайте файл <span class="code">views/layouts/main.handlebars</span>:</p>
<pre><code >&lt;!doctype html>
&lt;html>
    &lt;head>
        &lt;title>Meadowlark Travel&lt;/title>
    &lt;/head>
&lt;body>
    {{{body}}}
&lt;/body>
&lt;/html></code></pre>
<p>Единственное, чего вы, вероятно, до сих пор не видели, — это <span class="code">{{{body}}}</span>. Данное выражение будет замещено HTML-кодом для каждого представления. Обратите внимание, что при создании экземпляра Handlebars мы указываем макет по умолчанию (<span class="code">defaultLayout:'main'</span>). Это значит, что, если вы не укажете иное, для любого представления будет использоваться именно этот макет.
Теперь создадим страницы представления для нашей домашней страницы,
<span class="code">views/home.handlebars</span>:</p>
<pre><code >&lt;h1>Добро пожаловать в Meadowlark Travel&lt;/h1></code></pre>
<p>Затем для страницы <i>"О нас"</i>, <span class="code">views/about.handlebars</span>:</p>
<pre><code >&lt;h1>О Meadowlark Travel&lt;/h1></code></pre>
<p>Затем для страницы Не найдено, <span class="code">views/404.handlebars</span>:</p>
<pre><code >&lt;h1>404 — Не найдено&lt;/h1></code></pre>
<p>И наконец, для страницы Ошибка сервера, <span class="code">views/500.handlebars</span>:</p>
<pre><code >&lt;h1>500 — Ошибка сервера&lt;/h1></code></pre>
<p>Теперь, когда мы задали представления, необходимо заменить старые маршруты
новыми, использующими эти представления:</p>
<pre><code >app.get('/', (req, res) => res.render('home'))
app.get('/about', (req, res) => res.render('about'))
// Пользовательская страница 404
app.use((req, res) => {
    res.status(404)
    res.render('404')
})
// Пользовательская страница 500
app.use((err, req, res, next) => {
    console.error(err.message)
    res.status(500)
    res.render('500')
})</code></pre>
<p>Замечу, что нам больше не нужно указывать тип контента или код состояния:
механизм представления по умолчанию будет возвращать тип контента <span class="code">text/html</span>
и код состояния 200. В обобщенном обработчике, отвечающем за пользовательскую
страницу 404, и обработчике ошибки 500 нам приходится устанавливать код состояния явным образом.</p>
<p>Если вы запустите свой сервер и проверите домашнюю страницу или страницу "О нас", то увидите, что представления были отображены. Если посмотрите на
исходный код, обнаружите, что там есть шаблонный HTML из <span class="code">views/layouts/
main.handlebars</span>.</p>
<p>Эти пути рассматриваются как динамический контент, даже если при каждом
посещении домашней страницы вы получаете один и тот же HTML, так как мы
можем принимать разные решения для каждого запроса. В то же время контент, который действительно
никогда не меняется, то есть статический, важен и широко используется, поэтому
мы рассмотрим его ниже.</p>

<h3>Статические файлы и представления</h3>
<p>При обработке статических файлов и представлений Express полагается на промежуточное ПО. Пока достаточно знать, что промежуточное ПО обеспечивает разбиение на модули, упрощая обработку запросов.</p>
<p>Промежуточное ПО <span class="code">static</span> позволяет объявлять один из каталогов как содержащий статические ресурсы, которые довольно просты для того, чтобы их можно было предоставлять пользователю без какой-либо особой обработки.</p>
<p>Именно сюда вы можете поместить картинки, файлы CSS и клиентские файлы
на JavaScript.</p>
<p>В своем каталоге проекта создайте подкаталог с именем <span class="code">public</span> (мы назвали его
так, поскольку все в нем будет раздаваться без каких-либо дополнительных вопросов). Затем перед объявлением маршрутов добавьте промежуточное ПО <span class="code">static</span> :</p>
<pre><code >app.use(express.static(__dirname + '/public'))</code></pre>
<p>Промежуточное ПО <span class="code">static</span> приводит к тому же результату, что и создание для каждого статического файла, который вы хотите выдать, маршрута, отображающего файл и возвращающего его клиенту. Так что создадим подкаталог <span class="code">img</span> внутри каталога <span class="code">public</span> и поместим туда наш файл <span class="code">logo.png</span>.</p>
<p>Теперь мы просто можем сослаться на <span class="code">/img/logo.png</span> (обратите внимание: мы не указываем <span class="code">public</span> — этот каталог невидим для клиента), и промежуточное ПО <span class="code">static</span> выдаст этот файл, установив соответствующий тип контента. Сейчас исправим наш макет так, чтобы логотип появлялся на каждой странице:</p>
<pre><code >&lt;body>
&lt;header>
    &lt;img src="/img/logo.png" alt="Логотип Meadowlark Travel">
&lt;/header>
{{{body}}}
&lt;/body></code></pre>
<p>Помните, что промежуточное ПО обрабатывается в определенном порядке,
и промежуточное ПО <span class="code">static</span>, которое обычно объявляется первым или очень рано, переопределит другие маршруты. Например, если вы поместите файл <span class="code">index.html</span> в каталог <span class="code">public</span>, то обнаружите, что вместо настроенного вами маршрута будет выдано содержимое этого файла! Таким образом, если вы получили неправильный результат, проверьте ваши статические файлы и убедитесь, что маршрут не совпадает с чем-то неожиданным.</p>

<h3>Динамический контент в представлениях</h3>
<p>Представления — не просто усложненный способ выдачи статического HTML
(хотя они, конечно, могут делать и это). Настоящая сила представлений в том, что они могут содержать динамическую информацию.</p>
Допустим, мы хотим на странице "О нас" выдавать виртуальное печенье с предсказаниями. Определим в файле <span class="code">meadowlark.js</span> массив печенья с предсказаниями:
<pre><code >const fortunes = [
"Победи свои страхи, или они победят тебя.",
"Рекам нужны истоки.",
"Не бойся неведомого.",
"Тебя ждет приятный сюрприз.",
"Будь проще везде, где только можно.",
]</code></pre>
<p>Измените представление (<span class="code">/views/about.handlebars</span>) для отображения предсказаний:</p>
<pre><code >&lt;h1>О Meadowlark Travel&lt;/h1>
{{#if fortune}}
&lt;p>Твое предсказание на сегодня:&lt;/p>
&lt;blockquote>{{fortune}}&lt;/blockquote>
{{/if}}</code></pre>
<p>Теперь поменяем маршрут <span class="code">/about</span> для выдачи случайного печенья с предсказанием:</p>
<pre><code >app.get('/about', (req, res) => {
const randomFortune = fortunes[Math.floor(Math.random()*fortunes.length)]
res.render('about', { fortune: randomFortune })
})</code></pre>
<p>Сейчас, если вы перезапустите сервер и загрузите страницу <span class="code">/about</span>, то увидите случайное предсказание и будете получать новое при каждой перезагрузке страницы.</p>
