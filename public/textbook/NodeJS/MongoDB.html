<!--<title>Глава 9. MongoDB</title>-->
<h1>Глава 9. MongoDB</h1>
В главе 4 мы закончили на перемещении данных из представления назад (вниз)
по пути MVC в контроллер. В конце концов, контроллеры будут передавать данные
представлениям, но они не должны эти данные хранить. Рисунок 5.1 напоминает,
как выглядит поток данных в паттерне MVC.
Для хранения данных нам понадобится БД, а именно MongoDB. Итак, следующий шаг в процессе — создание БД и модели данных.
. В паттерне MVC данные содержатся в модели, обрабатываются контроллером
и затем визуализируются представлением
<img src="https://ltdfoto.ru/images/2024/08/09/imagea313ab4137b978de.png" alt="imagea313ab4137b978de.png" border="0" />
Подключим приложение к БД, прежде чем воспользоваться Mongoose для описания схем имоделей. Когда структура будет нас удовлетворять, можно будет добавить
какие-то тестовые данные прямо в базу данных MongoDB. Последним шагом будет
проверка работы всего этого после отправки на Heroku. Последовательность действий, выполняемых на этих четырех шагах, демонстрирует рис. 5.2
<img src="https://ltdfoto.ru/images/2024/08/09/imagef71f4f895e1f3612.png" alt="imagef71f4f895e1f3612.png" border="0" />
Для тех, кто волнуется, что пропустил раздел или два: не волнуйтесь, мы пока
еще не создали БД. И не должны будем создавать. В других стеках технологий это
может быть проблемой и источником ошибок. Но при работе с MongoDB не нужно
создавать БД до подключения к ней. MongoDB создаст базу данных тогда, когда
мы впервые попытаемся ее использовать.
На рис. 5.3 показано, на чем мы сосредоточим внимание в данной главе, говоря
языком общей архитектуры.
<img src="https://ltdfoto.ru/images/2024/08/09/image094ab787d9103de0.png" alt="image094ab787d9103de0.png" border="0" />
Мы, конечно, будем работать с базой данных MongoDB, но бо' льшая часть работы будет выполнена в Express и Node. В главе 2 мы обсуждали преимущества
расщепления данных путем создания API перед тесной интеграцией их в основное
приложение Express. Так что, хотя мы будем работать в Express и Node, причем
по-прежнему внутри того же инкапсулирующего приложения, фактически мы
начнем закладывать основы слоя API.

Подключение приложения Express
к MongoDB с помощью Mongoose
Мы можем напрямую подключить наше приложение к MongoDB и заставить их
взаимодействовать друг с другом посредством нативного драйвера. Хотя нативный
драйвер MongoDB обладает широкими возможностями, работать с ним нелегко.
К тому же у него нет встроенного способа описания и сопровождения структур
данных. Mongoose предоставляет большую часть функциональности нативного
драйвера, но более удобным способом, спроектированным в расчете на включение
в технологические процессы разработки приложений.
В чем Mongoose действительно силен, так это в предоставляемых возможностях
описания структур данных и моделей, их сопровождения и использования для
взаимодействия с БД. И все это осуществляется непосредственно из кода приложения. Как часть подобного подхода, Mongoose включает способность добавлять
проверки к описаниям данных, а значит, нам не нужно будет писать код валидации
в каждом месте нашего приложения, где данные отправляются в БД.
Таким образом, Mongoose находит свое место в стеке внутри приложения Express
в качестве транспортного соединения между приложением и БД (рис. 5.4).
<img src="https://ltdfoto.ru/images/2024/08/09/image7ab023d864aa26c1.png" alt="image7ab023d864aa26c1.png" border="0" />

MongoDB обменивается данными только с Mongoose, а Mongoose, в свою очередь, — с Node и Express. AngularJS не будет непосредственно обмениваться данными с MongoDB или Mongoose, а только с приложением Express.
У вас на машине уже должна быть установлена MongoDB (рассматривается
в приложении A), но не M�ong��oos�e. M�ong��oos�e не устанавливается глобально, а добавляется непосредственно в приложение. Сейчас мы это и сделаем.
Добавление Mongoose
в приложение
MongoDB доступен в виде модуля npm. Как вы могли видеть в главе 3, самый быстрый и удобный способ установки модуля npm — через командную строку. Установить Mongoose и добавить его в список зависимостей в package.json можно
с помощью одной команды.
Так что перейдите в терминал и убедитесь, что приглашение командной строки
находится в корневом каталоге приложения, там же, где файл package.json, после
чего выполните следующую команду:
$ npm install --save mongoose
Флаг --save сообщает npm о необходимости добавить Mongoose в список зависимостей в package.json. После выполнения этой команды вы увидите новый
подкаталог mongoose в каталоге node_modules приложения, а раздел зависимостей
файла package.json будет выглядеть следующим образом

Добавление в приложение
соединения с Mongoose
На данном этапе подключим наше приложение к БД. Базу данных мы пока что
не создали, но это не имеет значения, поскольку MongoDB создаст БД, когда мы
впервые попытаемся ее использовать. Это может показаться немного странным, но
представляет собой немалое преимущество при сборке приложения воедино: нам
не приходится бросать код приложения и углубляться в другую среду.

Соединение MongoDB и Mongoose
При подключении к базе данных MongoDB Mongoose открывает пул из пяти пригодных для многократного использования соединений. Этот пул соединений совместно используется всеми запросами. Пять — просто количество по умолчанию,
которое можно при необходимости увеличить или уменьшить в настройках соединений.
Открытие и закрытие соединений с БД может занять некоторое время, особенно если
БД расположена на отдельном сервере или сервисе. Так что эти операции лучше выполнять только в случае необходимости. Рекомендуемое решение: открывать соединение с БД при запуске приложения и оставлять его открытым вплоть до перезапуска или
остановки приложения. Именно этот подход мы и собираемся использовать.

Настройка файла соединений
Когда мы впервые занимались файловой структурой приложения, то создали в каталоге app_server три подкаталога: models, views и controllers. Работать с данными
имоделями мы будем, основываясь в большей степени на каталоге app_server/models.
Настройка файла соединений представляет собой двухшаговый процесс: создание файла и запрос его в приложении, что позволит его использовать.
ервый шаг: создаем файл под названием db.js в app_server/models и сохраняем его. Теперь мы просто запрашиваем (require) Mongoose в этом файле с помощью следующей однострочной команды:

<pre><code >var mongoose = require( 'mongoose' );</code></pre>
Второй шаг: внедряем этот файл в приложение путем его запроса в app.js.
Поскольку создание соединения между приложением и БД может занять довольно
продолжительное время, лучше сделать это пораньше в настройках. Отредактируйте верхнюю часть app.js таким образом, чтобы она выглядела так, как показано
в следующем фрагменте кода (изменения выделены полужирным шрифтом):
<pre><code >var express = require('express');
var path = require('path');
var favicon = require('serve-favicon');
var logger = require('morgan');
var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');
require('./app_server/models/db');</code></pre>

Мы не собираемся экспортировать какие-либо функции из db.js, так что не требуется присваивать его переменной при выполнении его require. Он понадобится
нам в приложении, но вряд ли нужно будет обращаться к каким-либо его методам
из app.js

Если вы перезапустите приложение, оно должно работать как и раньше, но теперь с Mongoose. Если вы получите ошибку, убедитесь, что путь в операторе require
соответствует пути к новому файлу, что package.json включает зависимость
Mongoose и что вы выполнили команду npm install из терминала, находясь в корневом каталоге приложения


Создание соединения
Mongoose

Создание соединения Mongoose представляет собой просто объявление URI для
вашей БД и передачу его методу connect Mongoose. URI базы данных представляет собой строку следующей конструкции:
<img src="https://ltdfoto.ru/images/2024/08/09/image40ef0c3153fa4193.png" alt="image40ef0c3153fa4193.png" border="0" />
Имя пользователя, пароль и порт не являются обязательными. Так что на
локальной машине URI базы данных окажется довольно простым. Пока что,
если предположить, что MongoDB установлена на вашей локальной машине, все,
что нужно для создания соединения, — добавить следующий фрагмент кода
в файл db.js:
mongodb://localhost:27017/

<pre><code >var dbURI = 'mongodb://localhost/Loc8r';
mongoose.connect(dbURI);</code></pre>
Если запустить приложение с этим кодом, добавленным в db.js, оно запустится и будет работать точно так же, как и раньше. Как же вам удостовериться, что соединение работает правильно? Ответ: с помощью событий соединений.

Мониторинг событий
соединения с Mongoose
MongoDB публикует события на основе статуса соединения, и к ним можно очень
легко подсоединиться, чтобы увидеть, что происходит. Мы будем использовать
события, чтобы видеть, когда установлено соединение, когда возникают ошибки
и когда происходит разрыв соединения. Следующий фрагмент демонстрирует необходимый для этого код:
<pre><code >// мониторинг успешного соединения mongoose
mongoose.connection.on('connected', function(){
console.log('Mongoose: Mongoose connected to '+dbURI)
})
// проверка на ошибку соединения
mongoose.connection.on('error', function(err){
console.log('Mongoose: Connection error '+err)
})
// проверка на разрыв соединения
mongoose.connection.on('disconnected', function(){
console.log('Mongoose: Disconnected')
})</code></pre>

Если вы еще раз перезапустите приложение, то можете заметить отсутствие
каких-либо сообщений о разрыве соединения. Это происходит потому, что соединения Windows не закрываются автоматически при остановке или перезапуске
приложений. Для этого нам понадобится прослушивать изменения в процессах
Node.

Закрытие соединения Mongoose

Закрытие соединения Mongoose при остановке приложения — почти столь же рекомендуемая практика, как и открытие соединения при его запуске. В силу двусторонности соединения (один его конец находится в вашем приложении, а второй —
в MongoDB) MongoDB необходимо знать, когда вы хотите закрыть соединение,
чтобы не держать открытыми лишние соединения
Для контроля остановки приложения нам придется прослушивать процесс
Node.js на предмет наступления события SIGINT.

SIGINT — сигнал уровня операционной системы, возбуждаемый в Unix-подобных операционных системах, таких как Linux и Mac OS X. Он возбуждается также в части
последних версий Windows. Если вы работаете в Windows и события разрыва соединения не возбуждаются, можно их эмулировать. Чтобы эмулировать такое поведение
в Windows, необходимо сначала добавить в приложение новый пакет npm — readline

После этого установите его в приложение посредством выполнения npm install из командной строки в том же каталоге, где находится файл package.json.
В файле db.js перед кодом прослушивателя событий добавьте следующее:
<pre><code >var readLine=require('readline')
if (process.platform==='win32'){
var rl = readLine.createInterface({
input: process.stdin,
output: process.stdout
})
rl.on('SIGINT', function (){
process.emit('SIGINT')
console.log('SIGINT')
});
rl.on('SIGUSR2', function (){
process.emit('SIGUSR2')
console.log('SIGUSR2')
})
}</code></pre>
Это сгенерирует сигнал SIGINT на машинах под управлением Windows, позволяя вам
перехватить его и мягко закончить все, что нужно, до завершения процесса.
Если вы используете nodemon для автоматического перезапуска приложения,
то вам придется прослушивать процесс Node на предмет еще одного события,
а именно SIGUSR2. Heroku использует также событие SIGTERM, так что нужно будет
слушать на предмет и его появления

Перехват событий
завершения процесса
При перехвате любого из этих событий мы мешаем нормальному ходу выполнения,
так что необходимо гарантировать возобновление требуемого поведения вручную.
После закрытия соединения Mongoose, конечно.

Для всего этого нам будут нужны три прослушивателя событий и одна функция
для закрытия соединения с БД. Закрытие БД — асинхронная операция, так что
понадобится передавать любую необходимую для перезапуска или завершения
процесса Node функцию в качестве обратного вызова. Во время этого можно вывести в консоль сообщение, подтверждающее закрытие соединения и объясняющее
его причину. Можно обернуть все это в функцию gracefulShutdown (мягкий останов) в db.js, как показано в следующем фрагменте кода:

<pre><code >var greacefulShutdown = function(msg, callback){
    // определяем функцию для приема сообщений и функции обратного вызова
    mongoose.connection.close(function(){
        //закрываем соединение, передавая анонимную функцию, которая будет выполнена при закрытии
        console.log('Mongoose disconnectedd through' + msg)
        //выводим сообщение и выполняем колбэк после закрытия соединения
        callback()
    })
}</code></pre>
Теперь необходимо вызывать эту функцию при завершении приложения или
когда его перезапускает nodemon. Чтобы это происходило, нужно добавить в db.js
два прослушивателя событий, как показано в следующем фрагменте кода:

<pre><code >process.once('SIGUSR2', function(){
    //прослушиваем на предмет используемого nodemon SIGUSR2
    gracefullShutdown('nodemon restart', function(){
        //отправляем сообщение функции gracefulShutdown и коллбэк для уничтожения процесса, снова генерируя SIGUSR2
        process.kill(process.pid, 'SIGUSR2');
    })
})
process.on('SIGINT', function(){
    //прослушиваем а предмет SIGINT, генерируемого при заершении приложения
    gracefulShutdown('app termination', function(){
        process.exit(0)
    })
})
process.on('SIGTERM', function(){
    gracefulShutdown('Heroku app shutdown', function(){
        process.exit(0)
    })
})</code></pre>

Теперь при завершении приложения оно мягко закрывает соединение Mongoose
до его фактического завершения. Аналогично, когда nodemon выполняет перезапуск приложения по причине изменений в исходных файлах, приложение
сначала закрывает текущее соединение Mongoose. Прослушиватель nodemon использует process.once, а не process.on, так как нам требуется выполнить прослушивание на предмет SIGUSR2 однократно. Nodemon также слушает на предмет
того же события, и нам не нужно перехватывать его каждый раз, мешая nodemon
работать.

Очень важно в каждом создаваемом вами приложении правильно управлять открытием
и закрытием соединений с БД. Если в используемой вами среде сигналы завершения
процессов другие, обязательно убедитесь, что прослушиваете на предмет их всех.

Законченный файл соединений
Мы многое добавили в файл db.js, так что воспользуемся моментом, чтобы подвести итоги. Ранее мы:
	описали строку cоединения с БД;
	открыли соединение Mongoose при запуске приложения;
	выполнили мониторинг событий соединения Mongoose;
	выполнили мониторинг некоторых событий процессов Node, чтобы можно было
закрыть соединение Mongoose при завершении приложения.
Целиком файл db.js будет выглядеть так, как показано в листинге 5.1. Обратите внимание на то, что он не включает дополнительного кода, необходимого Win-
dows для генерации события SIGINT.
<pre><code >const mongoose = require('mongoose');
const readLine = require('readline');

let dbURL = 'mongodb://localhost:27017';
if (process.env.NODE_ENV === 'production') {
    dbURL = process.env.DB_HOST || process.env.MONGODB_URI;
}

const connect = () => {
    setTimeout(() => mongoose.connect(dbURL, {}), 1000);
}

mongoose.connection.on('connected', () => {
    console.log('Mongoose: Mongoose connected to '+dbURL);
});

mongoose.connection.on('error', err => {
    console.log('Mongoose: error: ' + err);
    return connect();
});

mongoose.connection.on('disconnected', () => {
    console.log('Mongoose: disconnected');
});

if (process.platform === 'win32') {
    const rl = readLine.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    rl.on ('SIGINT', () => {
        process.emit("SIGINT");
    });
    rl.on('SIGUSR2', function (){
        process.emit('SIGUSR2')
    })
}

const gracefulShutdown = (msg, callback) => {
    mongoose.connection.close().then(function(){
        console.log(`Mongoose disconnected through ${msg}`);
        callback();}
    )
};

process.once('SIGUSR2', () => {
    gracefulShutdown('nodemon restart', () => {
        process.kill(process.pid, 'SIGUSR2');
    });
});
process.on('SIGINT', () => {
    gracefulShutdown('app termination', () => {
        process.exit(0);
    });
});
process.on('SIGTERM', () => {
    gracefulShutdown('Heroku app shutdown', () => {
        process.exit(0);
    });
});

connect();
</code></pre>
Как только вы сделали подобный файл, можете его копировать из приложения
в приложение, ведь события, на предмет которых вы слушаете, всегда одни и те же.
Все, что вам нужно будет сделать каждый раз, — поменять строку соединения с БД.
Не забывайте, что мы также запросили этот файл в app.js, где он находится недалеко от верха, так что соединение открывается в самом начале существования
приложения.

То, что вы видели до сих пор, носит название соединения по умолчанию и хорошо подходит для одиночного соединения, открытого на протяжении всего времени работы приложения. Но если необходимо подключиться ко второй БД, например, для журналирования или управления сеансами пользователей, то можно использовать именованное
соединение. При этом вместо метода mongoose.connect придется использовать другой
метод, mongoose.createConnection, присвоив его переменной. Вы можете увидеть это
в следующем фрагменте кода:
var dbURIlog = 'mongodb://localhost/Loc8rLog';
var logDB = mongoose.createConnection(dbURIlog);

тот код создает объект для нового соединения Mongoose с именем logDB. Взаимодействовать с ним можно теми же способами, что и с mongoose.connection для соединения
по умолчанию. Вот несколько примеров:
стр 174
Зачем нужно моделировать данные
В главе 1 мы говорили, что MongoDB скорее хранилище документов, а не традиционная табличная БД со строками и столбцами. Это дает MongoDB колоссальную
свободу и гибкость, но иногда нам желательна, то есть необходима, структура для
данных.
Возьмем, например, домашнюю страницу Loc8r. Раздел перечня, показанный на
рис. 5.5, содержит определенный набор данных, общий для всех местоположений.

Эти элементы данных нужны странице для всех мест, и у записей данных для
каждого места должна быть согласованная структура именования. Без этого приложение не сможет найти данные и использовать их. На текущем этапе разработки
данные хранятся в контроллере и передаются представлению. В терминах архитектуры MVC мы начинаем работу с данными в представлении, а затем передаем их
на шаг назад, в контроллер. Теперь нам осталось только переместить их еще на один
шаг назад, туда, где они должны находиться, — в модель. Текущее положение, подчеркивая конечную цель, иллюстрирует рис. 5.6.

<img src="https://ltdfoto.ru/images/2024/08/10/image0e6f12f64373f281.png" alt="image0e6f12f64373f281.png" border="0" />
Поток данных в паттерне MVC: из модели через контроллер в представление.
На текущем этапе данные в прототипе находятся в контроллере, так что мы хотим
переместить их на шаг назад, в модель
Одно из следствий перемещения данных назад по потоку выполнения MVC,
шаг за шагом, как мы делали до сих пор, заключается в том, что благодаря этому
выкристаллизовываются требования к структуре данных. Это гарантирует точное
отражение структурой данных нужд нашего приложения. Если вы попытаетесь
сначала описать модель, то закончите гаданием о том, как будет выглядеть приложение и как оно будет работать.



Так что, говоря о моделировании данных, мы на самом деле описываем свои
пожелания относительно их структуры. В приложении мы можем или создать
описания и управлять ими вручную и делать всю тяжелую работу самостоятельно,
или использовать Mongoose, позволив ему делать тяжелую работу за нас.

Что такое Mongoose
и как он работает
Mongoose был специально создан в качестве объектно-документного средства
моделирования (Object-Document Modeler (ODM)) MongoDB для приложений
Node. Один из ключевых принципов — возможность управления моделью данных
изнутри вашего приложения. Не нужно возиться непосредственно с базами данных,
внешними фреймворками или реляционными подпрограммами отображения —
можно просто описать модель данных, находясь в комфортных условиях своего
приложения.
Прежде всего договоримся относительно названий.
	В MongoDB каждая запись в БД называется документом.
	В MongoDB набор документов называется коллекцией (можете думать о ней как
о таблице, если вам привычнее реляционные БД).
	В Mongoose описание документа называется схемой.
	Каждая отдельная сущность данных в схеме называется путем.
Эти соглашения о названиях и связь их друг с другом на примере стопки визитных карточек иллюстрирует рис. 5.7.
<img src="https://ltdfoto.ru/images/2024/08/10/imageefca22fafcd06d1f.png" alt="imageefca22fafcd06d1f.png" border="0" />
Еще одно, последнее определение, для моделей. Модель — скомпилированная
версия схемы. Все взаимодействия данных с помощью Mongoose проходят через
модель. Мы поработаем с моделями в главе 6, а пока что сосредоточимся на их
создании


Как Mongoose моделирует данные
Если мы будем описывать наши данные в приложении, то каким образом? Конечно, на JavaScript! В объектах JavaScript, если быть точным. Мы уже взглянули на
это краешком глаза на рис. 5.7, но давайте на примере простого документа MongoDB
посмотрим, как может выглядеть схема Mongoose. В следующем фрагменте кода
показан документ MongoDB, за которым следует схема Mongoose:

<img src="https://ltdfoto.ru/images/2024/08/10/image66c3c5d7e7f04857.png" alt="image66c3c5d7e7f04857.png" border="0" />

Как вы видите, схема очень напоминает сами данные. Она описывает имя для
каждого пути данных и содержащийся в нем тип данных. В данном примере мы
просто объявляем пути firstname и surname как строковые значения
Вы могли обратить внимание на то, что мы не объявляли путь ID в схеме. ID — это уникальный идентификатор, первичный ключ, если такое название вам больше нравится,
для каждого документа. MongoDB автоматически генерирует этот путь при создании
каждого документа и присваивает ему уникальное значение ObjectId. Значение спроектировано с расчетом на то, чтобы оставаться уникальным при любых условиях посредством сочетания времени, прошедшего с момента начала отсчета времени Unix, с идентификаторами машины и процесса, а также счетчиком.
Можете использовать собственный уникальный ключ, если вам так удобнее, например,
если у вас уже имеется БД. В нашей книге и в приложении Loc8r будем придерживаться
варианта по умолчанию, ObjectId.

Анализ пути схемы
Базовая структура описания отдельного пути представляет собой название пути
со следующим за ним объектом свойств. В коде выше вы видели фактически сокращенное написание для случая, когда нужно всего лишь описать тип данных для
конкретного пути. Итак, путь схемы составляется из двух частей — названия пути
и объекта свойств — следующим образом:
<img src="https://ltdfoto.ru/images/2024/08/10/image.png" alt="image.png" border="0" />

РАЗРЕШЕННЫЕ ТИПЫ СХЕМ
Тип схемы — свойство, задающее тип данных для данного пути. Оно необходимо для
всех путей. Если тип — единственное свойство пути, то можно использовать сокращенное описание. Существует восемь типов схем, которые вы можете использовать:
	String — любая строка в кодировке UTF-8;
	Number — Mongoose не поддерживает длинные числа или числа с двойной точностью,
но допускает расширение для их поддержки спомощью плагинов Mongoose. Поддерживаемого по умолчанию типа достаточно в большинстве случаев;
	Date — обычно возвращается из MongoDB в виде объекта ISODate;
	Boolean — true или false;
	Buffer — для двоичной информации, например изображений;
	Mixed — любой тип данных;
	Array — может быть или массивом данных соответствующего типа, или массивом
вложенных поддокументов;
	ObjectId — для уникального ID в пути, отличном от _id. Обычно используется для
ссылок на пути _id в других документах.
При необходимости использовать другой тип схемы можете описать собственные типы схем
или применять существующий плагин Mongoose из http://plugins.mongoosejs.com/

Имя пути соответствует соглашениям и требованиям к описанию объектов
JavaScript. Так что в нем не место пробелам или спецсимволам, и лучше стараться
избегать зарезервированных слов. Лично я применяю для имен путей так называемый верблюжий регистр1
. Если вы используете существующую БД, то берите те
имена путей, которые уже есть в документах. Если же создаете новую, учтите, что
имена путей будут использоваться в документах, так что тщательно их продумывайте.

Объект свойств — объект JavaScript совершенно другого плана. Он задает характеристики хранящихся в пути данных. Как минимум он содержит тип данных,
но может включать также характеристики для проверки, граничные условия, значения по умолчанию и т. д. Мы изучим и используем некоторые из этих возможностей в следующих нескольких главах в процессе превращения Loc8r в приложение, ориентированное на работу с данными.
А сейчас приступим к работе и начнем описывать схемы, которые понадобятся
в приложении.

Описание простых
схем Mongoose


Мы только что упоминали, что схема Mongoose, по существу, объект JavaScript,
описываемый нами из приложения. Начнем с настройки и включения файлов,
чтобы разделаться с этим и иметь возможность сосредоточиться на схеме.
Как вы, наверное, и подозревали, мы будем описывать схему в каталоге модели,
рядом с db.js. По сути, мы собираемся запрашивать ее в db.js, чтобы сделать доступной для приложения. Итак, в каталоге моделей в app_server создайте новый
пустой файл locations.js. Вам, естественно, понадобится Mongoose для описания
схемы Mongoose, так что введите в locations.js следующую строку:
var mongoose = require( 'mongoose' );
Мы хотим внедрить этот файл в приложение путем запроса его в db.js, так что
добавьте в самом конце db.js следующую строку:
require('./locations');
После этого настройка завершена и все готово к работе.

Основы настройки схемы
Mongoose предоставляет функцию-конструктор для описания новых схем, которую
обычно присваивают переменной, чтобы можно было позднее к ней обратиться.
Это выглядит так:
var locationSchema = new mongoose.Schema({ });
Фактически это именно та конструкция, которую мы собираемся использовать,
так что добавьте эту строку в модель locations.js, конечно, ниже запрашивающей
Mongoose строки. Пустой объект внутри скобок mongoose.Schema({ }) — то место,
где мы будем описывать схему.

Описание схемы на основе данных контроллера
Одно из следствий перемещения данных обратно из представления в контроллер — то, что контроллер в конечном счете дает хорошее представление о необходимой структуре данных. Начнем с простого и взглянем на контроллер homelist
в app_server/controllers/locations.js. Контроллер homelist передает в представление данные для показа на домашней странице. То, как одно из мест будет
выглядеть на домашней странице, демонстрирует рис. 5.8.

<pre><code >var locationSchema = new mongoose.Schema({
name: String,
address: String,
rating: Number,
facilities: [String]
});</code></pre>

Присвоение значений по умолчанию
В некоторых случаях удобно задавать значение по умолчанию при создании на
основе схемы нового документа MongoDB. Хорошая кандидатура для этого —
путь rating в схеме locationSchema. При добавлении в БД нового местоположения у него не будет никаких отзывов, а значит, и оценки. Но наше представление
предполагает оценку от нуля до пяти звезд, которую должен будет передавать
контроллер.

Поэтому хотелось бы задать для каждого нового документа значение оценки по
умолчанию, равное 0. Mongoose позволяет делать это изнутри схемы. Помните, что
запись rating:Number — сокращение для rating: {type: Number}? Так вот, можно
задать и другие необязательные элементы в объекте определения, включая и значение по умолчанию. Это значит, что можно изменить путь для оценки в схеме
следующим образом:
rating: {type: Number, "default": 0}
Слово default не обязательно брать в кавычки, но это зарезервированное слово
в JavaScript, так что стоит сделать это.

Добавление возможности базовой проверки данных:
обязательные поля
С помощью Mongoose можно быстро добавить возможность определенной базовой проверки правильности данных на уровне схемы. Это помогает поддерживать целостность данных и защищать БД от проблем с отсутствующими и деформированными данными. Вспомогательные методы Mongoose сильно облегчают
эту задачу, а значит, вам не нужно будет всякий раз писать или импортировать
код.
Первый пример подобных проверок гарантирует, что указанные поля не пусты,
перед сохранением документа в БД. Вместо того чтобы писать в коде команды для
проверки каждого поля, можно просто добавить флаг required: true к тем объектам
определений каждого из путей, которые должны, по вашему мнению, быть обязательными. В схеме locationSchema необходимо, чтобы у каждого пути было название, так что можно поменять название пути следующим образом:
name: {type: String, required: true}
Если вы теперь попытаетесь сохранить местоположение без названия, Mongoose
вернет ошибку проверки, которую можно будет сразу же перехватить в коде, не обращаясь к БД.

Добавление возможности базовой проверки данных:
граничные условия для числовых значений
Можно использовать схожий метод для задания максимального и минимального
значений числового пути. Эти валидаторы называются max и min. Каждому местоположению присваивается оценка, для которой мы только что задали значение по
умолчанию, равное 0. Значение не должно быть меньше 0 или больше 5, так что
можно поменять путь rating следующим образом:
rating: {type: Number, "default": 0, min: 0, max: 5}
С этим изменением Mongoose не позволит вам сохранить значение оценки
меньше 0 или больше 5. Он вернет ошибку проверки, которую вы сможете обработать в своем коде. Замечательное свойство этого подхода — то, что приложению
не нужно будет обращаться к БД для проверки граничных условий. Еще один плюс:
не нужно писать код проверки во всех местах приложения, где может понадобиться добавить, обновить или вычислить значение оценки.

Использование географических данных
в MongoDB и Mongoose
Когда мы только приступили к отображению данных приложения из контроллера
на схему Mongoose, мы оставили вопрос о расстоянии на потом. Теперь пришло
время обсудить, как мы будем обрабатывать географическую информацию.
MongoDB может хранить географические данные в виде координат долготы
и широты и даже создавать на их основе индексы и управлять ими. Эта способность
дает пользователям возможность выполнять быстрый поиск мест, расположенных
близко друг от друга или поблизости от конкретных долготы и широты. Безусловно, это очень полезно для создания приложения, основанного на учете местоположения!
Индексы в любой системе баз данных позволяют выполнять более быстрые и эффективные запросы, и MongoDB не исключение. Если путь проиндексирован, MongoDB может
использовать индекс, чтобы быстро отобрать подмножества данных, не просматривая
все документы в коллекции.
Рассмотрим систему хранения документов, которая могла бы использоваться у вас дома.
Представьте, что вам нужно найти конкретную выписку по счету банковской карты.
Допустим, вы храните все бумаги в одном ящике шкафа. Если они помещены туда случайным образом, вам придется просмотреть все виды не относящихся к делу документов,
прежде чем найдете искомое. Если же вы «проиндексировали» свои бумаги — разложили по папкам, то сможете быстро найти папку, относящуюся к банковской карте. Как
только вытащите ее, вам нужно будет просмотреть один-единственный набор документов, что значительно повысит эффективность поиска.
Это очень похоже на то, как работает индексация в БД. Однако в БД у вас может быть
несколько индексов для каждого документа, что делает возможным эффективный поиск
по различным запросам.
Индексы, однако, требуют расхода ресурсов БД на сопровождение точно так же, как
корректное распределение ваших бумаг по папкам требует времени. Так что для улучшения общей производительности старайтесь ограничивать индексы БД теми путями, которые действительно требуют индексации и используются в большинстве запросов.

Данные для отдельных географических местоположений хранятся в соответствии со спецификациями формата GeoJSON, который мы вскоре увидим в действии. Поддержка Mongoose этого типа данных позволяет вам описывать в схеме
геопространственные пути. Mongoose, будучи слоем абстракции поверх MongoDB,
старается упростить эти действия. Для добавления пути GeoJSON в вашу схему
нужно всего лишь:
	описать путь в виде массива данных типа Number;
	описать путь как такой, у которого имеется индекс 2dsphere.
Чтобы осуществить это, можете добавить путь coords в свою схему для местоположений. Если вы выполнили два названных шага, ваша схема должна выглядеть
так, как показано в следующем фрагменте кода:
coords: {type: [Number], index: '2dsphere'}
Главное здесь — 2dsphere, так как именно это значение дает MongoDB возможность проводить правильные вычисления при выполнении запросов и возвращении
результатов. Мы ближе познакомимся с этим процессом в главе 6, когда будем
создавать API и начнем взаимодействие с данными.
Для соответствия спецификациям GeoJSON пара координат должна вводиться в массив
в правильном порядке: сначала долгота, потом широта.
еперь мы рассмотрели все основы, и в нашей схеме для Loc8r уже есть все необходимое для удовлетворения выдвигаемых домашней страницей требований.
Пришло время взглянуть на страницу Details (Подробности). Требования к данным
у этой страницы более сложные, так что посмотрим, как удовлетворить их с помощью схем Mongoose.
Создание более сложных схем
с поддокументами

Данные, которые мы применяли до сих пор, были более или менее простыми, их
можно было хранить в довольно плоской схеме. Мы использовали пару массивов для предоставляемых услуг и координат местоположений, но опять же эти
массивы были простыми и содержали всего по одному типу данных каждый.

Теперь мы посмотрим, что происходит в процессе работы с несколько более сложным набором данных.
Начнем с повторного знакомства со страницей Details (Подробности) и выводимыми на ней данными. Рисунок 5.9 демонстрирует скриншот этой страницы
и показывает все различные области информации.
Наименование, оценка и адрес находятся в самом верху страницы, чуть ниже
описываются предоставляемые услуги. Справа находится карта, основанная на
географических координатах. Все это мы уже охватили в базовой схеме. Две области, для которых у нас все еще ничего нет: часы работы и отзывы клиентов.
Данные, которыми снабжается это представление, в настоящий момент хранятся в контроллере locationInfo в app_server/controllers/locations.js. Листинг 5.2
показывает соответствующую часть данных в этом контроллере.


Таким образом, здесь имеются массивы объектов для часов работы и отзывов.
В реляционной БД их можно было бы создать в виде отдельных таблиц, а затем
выполнить их соединение (join) в запросе, когда понадобится хранящаяся в них
информация. Но документоориентированные БД, включая MongoDB, работают
иначе. В документоориентированной БД все относящееся к родительскому документу должно содержаться внутри этого документа. Концептуальные различия
между этими двумя подходами демонстрирует рис. 5.10.
MongoDB вводит понятие поддокументов, предназначенных для хранения этих
повторяющихся вложенных данных. Поддокументы очень похожи на документы:
у них есть собственная схема и при создании MongoDB присваивает каждому из
них уникальный _id. Но поддокументы должны быть вложены в документ, и доступ
к ним возможен только по пути через этот родительский документ.
<img src="https://ltdfoto.ru/images/2024/08/10/image91995d89aa5afdd8.png" alt="image91995d89aa5afdd8.png" border="0" />
Вложенные схемы в Mongoose для описания поддокументов
Поддокументы описываются в Mongoose с помощью вложенных схем. Это значит,
что одна схема вложена внутрь другой. Давайте создадим такую схему, чтобы увидеть, как это работает в коде. Первый шаг — описание новой схемы для поддокумента. Начнем с часов работы и создадим следующую схему. Обратите внимание на то,
что это должно находиться в том же файле, что и описание схемы locationSchema,
причем, что существенно, перед этим описанием:
var openingTimeSchema = new mongoose.Schema({
days: {type: String, required: true},
opening: String,
closing: String,
closed: {type: Boolean, required: true}
});

В схеме для часов работы мы сталкиваемся с интересной ситуацией: нам необходимо
хранить информацию о времени, например, 7:30 a.m., но без связанной с ней даты.
Мы используем тут тип String, как не требующий никакой обработки перед помещением
в БД или после извлечения из нее. При этом каждая запись легко понятна. Недостаток
его — в сложности выполнения с ним каких-либо вычислений.
<img src="https://ltdfoto.ru/images/2024/08/10/image2f1cb6ee73d6cef5.png" alt="image2f1cb6ee73d6cef5.png" border="0" />
Один из вариантов — создать объект даты с произвольными данными и вручную задать
часы и минуты, вот так:
С помощью такого метода мы легко можем отделить время от даты. Недостаток его —
хранение ненужных данных и формальная некорректность.
Второй вариант: хранение количества минут после полуночи. Так, 7:30 a.m. равно
(7 ∙ 60) + 30 = 450. Эти вычисления достаточно просты для того, чтобы можно было выполнять их при помещении данных в БД и при их извлечении из нее. Но на первый
взгляд эти данные выглядят бессмысленно.
Чтобы сделать даты интеллектуальными, лично я предпочел бы второй вариант. Если
вы хотите попробовать что-то новое, это будет неплохим упражнением. Но в целях удобочитаемости и чтобы не отвлекаться, мы продолжим использовать в данной книге метод, связанный со String.

Описание схемы по-прежнему довольно простое и устанавливает соответствие
для данных из контроллера. У нас есть два обязательных поля, булев флаг closed
и days, на которые ссылается каждый поддокумент.
Вложение этой схемы в схему местоположений — еще одна несложная задача.
Необходимо только добавить новый путь в родительскую схему и описать его как
массив схем поддокументов. Следующий фрагмент кода демонстрирует, как можно вложить openingTimeSchema в locationSchema:

var locationSchema = new mongoose.Schema({
name: {type: String, required: true},
address: String,
rating: {type: Number, "default": 0, min: 0, max: 5},
facilities: [String],
coords: {type: [Number], index: '2dsphere'},
openingTimes: [openingTimeSchema]
});

Сделав это, мы можем теперь добавлять к данному месту нужное количество
поддокументов о часах работы, которые будут храниться в соответствующем этому
месту документе. В следующем фрагменте кода приведен пример документа из
MongoDB, основанного на этой схеме (поддокументы для часов работы выделены
полужирным шрифтом):


Добавление второго набора поддокументов
Ни MongoDB, ни Mongoose не ограничивают количество путей поддокументов
в документе. А значит, мы можем использовать сделанное для часов работы, продублировав процесс для отзывов.
Шаг первый: изучаем данные, использованные в отзыве, показанном в следующем фрагменте кода:
Шаг второй: описываемсоответствующуюновую схему reviewSchema в app_server/
models/location.js:

const mongoose = require('mongoose');

var reviewSchema = new mongoose.Schema({
author: String,
rating: {type: Number, required: true, min: 0, max: 5},
reviewText: String,
createdOn: {type: Date, "default": Date.now}
});

var openingTimeSchema = new mongoose.Schema({
days: {type: String, required: true},
opening: String,
closing: String,
closed: {type: Boolean, required: true}
});

var locationSchema = new mongoose.Schema({
name: {type: String, required: true},
address: String,
rating: {type: Number, "default": 0, min: 0, max: 5},
facilities: [String],
coords: {type: [Number], index: '2dsphere'},
openingTimes: [openingTimeSchema],
reviews: [reviewSchema]
});

Компиляция схем MongoDB в модели
Во время работы с данными приложение не взаимодействует непосредственно со
схемой — взаимодействие происходит через модели.
Модель вa Mongoose — это скомпилированная версия схемы. Однократно скомпилированный, отдельный экземпляр модели отображается непосредственно на
отдельный документ в БД. Именно благодаря этому взаимно однозначному соответствию модель может создавать, читать, сохранять и удалять данные. Рисунок 5.11
иллюстрирует эту схему

<img src="https://ltdfoto.ru/images/2024/08/10/image916917beaea11a6a.png" alt="image916917beaea11a6a.png" border="0" />

Приложение и БД взаимодействуют друг с другом посредством моделей.
Отдельный экземпляр модели взаимно однозначно (1:1) соответствует отдельному
документу в БД. Благодаря этому соответствию происходит управление созданием,
чтением, обновлением и удалением данных

Компиляция модели из схемы
Все, что содержит в названии слово «компиляция», кажется несколько запутанным. На самом деле компиляция модели Mongoose из схемы — чрезвычайно
простая задача, на одну строчку. Нужно только убедиться, что схема закончена,
прежде чем вызывать команду model. Структура команды model выглядит следующим образом:
<img src="https://ltdfoto.ru/images/2024/08/10/imaged083a32a75518e03.png" alt="imaged083a32a75518e03.png" border="0" />
Название коллекции MongoDB — необязательный элемент. Если вы его не укажете,
MongoDB использует название модели в нижнем регистре в форме множественного числа. Например, если модель называется Location и вы не зададите иное имя, коллекция
будет называться locations.

скольку мы создаем БД и не обращаемся к существующему источнику данных, то можем использовать название коллекции по умолчанию, так что нам нет
необходимости включать этот параметр в команду model. Таким образом, для создания модели схемы мест мы можем добавить к коду следующую строку, поставив
ее сразу после описания схемы locationSchema:
mongoose.model('Location', locationSchema);
Готово! Мы рассмотрели схему данных для мест и скомпилировали эту схему
в модель, которую сможем использовать в приложении. Теперь нам нужно добавить
какие-нибудь данные.

Использование командной оболочки
MongoDB для создания базы данных
MongoDB и добавления данных
Для построения приложения Loc8r мы создадим новую БД и вручную добавим
какие-нибудь тестовые данные. Это значит, что у вас есть возможность создать
собственную версию Loc8r для тестирования и в то же время непосредственно поэкспериментировать с MongoDB.

Основы командной оболочки MongoDB
Командная оболочка MongoDB — утилита командной строки, устанавливаемая
вместе с MongoDB и предоставляющая возможность взаимодействия с любыми
базами данных MongoDB в вашей системе. Она обладает большими возможностями и может выполнять многие вещи — мы углубимся в основы лишь до той степени, которая необходима, чтобы начать работу.
Запуск командной оболочки MongoDB
Войдите в командную оболочку, выполнив в терминале следующую строку:
$ mongo
При этом в терминале должна появиться примерно следующая пара строк, сообщающая версию командной оболочки и подтверждающая подключение к тестовой БД:
MongoDB shell version: 2.4.6
connecting to: test
СОВЕТ __________________________________________________________________________
Новые строки в командной оболочке начинаются с >, чтобы можно было отличить их от
стандартной точки входа командной строки. Приведенные в данном разделе команды
командной оболочки будут начинаться с > вместо $, чтобы сделать очевидным использование нами командной оболочки, но вводить символ >, как и $, не нужно.
Список локальных баз данных
Следующая простая команда предназначена для вывода списка всех локальных баз
данных MongoDB. Введите в командной оболочке строку:
> show dbs
Эта команда вернет список названий и размеров локальных баз данных
MongoDB. Если вы пока что не создали никаких БД, то все равно увидите две БД
по умолчанию, что-то вроде такого:
local 0.078125GB
test (empty)
Использование конкретной базы данных
При запуске командная оболочка MongoDB автоматически подключается к пустой
тестовой БД. Если вы хотите переключиться на другую базу данных, например на БД
по умолчанию под названием local, можете воспользоваться следующей командой:
> use local

В ответ на эту команду командная оболочка выведет сообщение:
switched to db local
Это сообщение подтверждает название БД, к которой подключилась командная
оболочка.

Получение списка коллекций в базе данных
Как только вы подключитесь к конкретной БД, можете без труда вывести список
коллекций с помощью следующей команды:
> show collections
Если вы используете локальную БД, то, вероятно, увидите в ответ одно выведенное в терминал название коллекции: startup_log.

Просмотр содержимого коллекции
Командная оболочка MongoDB позволяет выполнять запросы к коллекциям в БД.
Структура запроса (операции поиска) следующая:
Объект query используется для конкретизации того, что вы хотите найти в коллекции, и позднее, в главе 6, мы рассмотрим примеры объектов query (Mongoose
тоже использует объекты query). Простейший запрос — пустой запрос, возвращающий все документы коллекции. Не волнуйтесь, что коллекция может быть большой, MongoDB вернет подмножество документов, которое вы сможете просматривать постранично. Используя коллекцию startup_log в качестве примера, вы
можете выполнить следующую команду:
> db.startup_log.find()
Она вернет некоторое количество документов из журнала загрузки MongoDB,
содержимое которых недостаточно интересно, чтобы приводить его тут. Эта команда полезна при запуске БД и при необходимости убедиться в том, что все сохранено так, как ожидается.
<img src="https://ltdfoto.ru/images/2024/08/10/image36f22b4d203c0c99.png" alt="image36f22b4d203c0c99.png" border="0" />

Создание базы данных MongoDB
На самом деле вам не нужно создавать базу данных MongoDB, достаточно просто
начать ее использовать. Для приложения Loc8r имеет смысл назвать базу данных
Loc8r. Так что начните использовать ее в командной оболочке следующей командой:
> use Loc8r
Если вы выполните команду show collections, она пока ничего не вернет, но
если выполнить show dbs, можно увидеть, что база данных была добавлена в список
БД и в настоящий момент пуста:
Loc8r (empty)
local 0.078125GB
test (empty)
Данное сообщение показывает, что она была добавлена в список баз данных

Создание коллекций и документов
Аналогично вам не требуется явным образом создавать коллекции, так как MongoDB
создаст их для вас при первом сохранении в них данных.
ОЛЕЕ БЛИЗКИЕ ВАМ ДАННЫЕ О МЕСТАХ _____________________________________
Loc8r в первую очередь связана с данными, основанными на учете местоположения, все
примеры — вымышленные места, расположенные неподалеку от тех мест, где я жил в Великобритании. Вы можете сделать свою версию более близкой себе, изменив названия,
адреса и координаты.
Чтобы узнать свои координаты, можете посетить сайт http://whatsmylatlng.com/. На странице имеется кнопка для определения местоположения с помощью JavaScript, которая
даст вам намного более точное местоположение, чем первоначальное приближение.
Обратите внимание на то, что координаты выдаются вам в порядке «широта/долгота»,
так что вам необходимо будет поменять их местами для БД, так как там долгота должна указываться первой.
Чтобы получить координаты любого адреса, можно использовать http://mygeoposition.com/. Этот сайт дает возможность ввести адрес или перетащить указатель для получения географических координат. И не забывайте, что пары в MongoDB должны выглядеть следующим образом: долгота, затем широта.

Для модели Location вам понадобится коллекция locations; не забывайте, что
название коллекции по умолчанию — это название модели в нижнем регистре
в форме множественного числа. Создать и сохранить новый документ можно путем
передачи объекта данных команде save коллекции, как показано в следующем
фрагменте кода:


db.locations.insertOne({ name: 'Starcups', address: '125 High Street, Reading, RG 6 1PS', rating: 3, facilities: ['Hot drinks', 'Food', 'Premium wifi'], coords: [-0.9690884, 51.455041], openingTimes: [{ days: 'Monday - Friday', opening: '7:00am', closing: '7:00pm', closed: false }, { days: 'Saturday', opening: '8:00am', closing: '5:00pm', closed: false }, { days: 'Sunday', closed: true }] })


Этот код за один шаг создаст новую коллекцию locations, а также первый документ в этой коллекции. Если вы теперь выполните show collections в командной
оболочке MongoDB, то увидите, что возвращается новая коллекция locations
вместе с автоматически созданной коллекцией system.indexes, например:
> show collections
locations
system.indexes
Вы можете выполнить запрос к коллекции для поиска всех документов — пока
что там только один, так что будет возвращено не так уж много информации. Можно применить к коллекции также команду find:
Этот фрагмент кода был отформатирован для удобства чтения, возвращенный
MongoDB в командную оболочку документ не имел бы разрывов строк и отступов. Но командная оболочка MongoDB может приукрасить его для вас, если
добавить .pretty() в конец команды, вот так:
> db.locations.find().pretty()
Обратите внимание на то, что порядок данных в возвращенном документе не совпадает с порядком данных в предоставленном вами объекте. Так как эта структура данных не основана на столбцах, не имеет значения, каким образом MongoDB
хранит отдельные пути в документе. Данные все равно всегда располагаются
в правильных путях, а хранимые в массивах данные всегда сохраняют один и тот же
порядок.

Добавление поддокументов
Вероятно, вы обратили внимание на то, что в нашем первом документе набор данных был неполон — в нем отсутствовали поддокументы отзывов. Можно добавить
их в исходную команду save, как мы поступили с часами работы, или обновить
существующий документ и внести их туда.
В MongoDB имеется команда update, принимающая два входных параметра,
первый из которых — запрос, так что она знает, какой документ обновлять, а второй
содержит инструкции о том, что делать после нахождения документа. На данном
этапе мы можем использовать совсем простой запрос и искать место по названию
(Starcups), так как уверены в отсутствии дублирующихся записей. Для объекта
с инструкциями можно использовать команду $push, чтобы добавить новый объект
в путь отзывов, — не имеет значения, что пути отзывов может еще не существовать,
MongoDB добавит его в качестве части операции push.
Все вместе это будет выглядеть как в следующем фрагменте кода:

db.locations.updateOne({
name: 'Starcups'},{
$push: {
reviews: [{
author: 'Simon Holmes',
rating: 5,
timestamp: '16 July 2013',
reviewText: 'What a great place. I can\'t say enough good things about it.'
}, {
author: 'Charlie Chaplin',
rating: 3,
timestamp: '16 June 2013',
reviewText: 'It was okay. Coffee wasn\'t great, but the wifi was fast.'
}]
}
})
Если вы выполните эту команду в командной оболочке MongoDB во время использования базы данных Loc8r, она добавит отзыв в документ. Это можно повторять
столько раз, сколько нужно, меняя данные, чтобы добавить несколько отзывов.
Обратите внимание на команду new Date, служащую для задания времени создания отзыва. Ее использование гарантирует, что MongoDB будет хранить дату
в виде объекта даты в формате ISO, а не строки — именно этого требует наша схема и это позволяет сделать работу с данными дат более гибкой.

Повторяем процесс
Благодаря этим нескольким командам мы получили одно место, на котором можно
протестировать приложение, но в идеале нам хотелось бы иметь больше. Так что
вперед, добавьте еще несколько мест в БД.
Когда закончите эту работу и данные будут введены, можно начинать использовать эти данные из приложения — в этом случае мы собираемся создать API.
Но прежде, чем перейти к этому в главе 6, выполним еще одну вспомогательную
операцию. Нам хотелось бы отправлять на Heroku регулярные обновления, и теперь,
когда мы добавили соединение с БД и модели данных, необходимо убедиться, что
они поддерживаются в Heroku.

Введение базы данных
в промышленную эксплуатацию
Если вы вывели свое приложение в реальный мир, не стоит оставлять базу данных
на локальной машине. База данных тоже должна быть доступна извне. В этом разделе мы собираемся поместить базу данных в среду промышленной эксплуатации
и модернизировать приложение Loc8r так, чтобы оно использовало опубликованную БД для опубликованного сайта и локальную БД — для сайта, предназначенного для разработки. Мы начнем с использования бесплатного пакета сервиса под
названием MongoLab, который можно использовать в качестве дополнения
к Heroku. Если вы предпочитаете другого провайдера или собственный сервер баз
данных — не проблема. Первая часть этого раздела посвящена настройке MongoLab,
но в следующих частях описаны миграция данных и настройка строк соединения
в приложении Node, которые являются платформонезависимыми.

Настройка MongoLab
и получение URI базы данных
Первая задача состоит в получении доступного извне URI базы данных, чтобы
можно быть поместить туда данные и добавить его в приложение. Мы будем здесь
использовать сервис MongoLab из-за его неплохого бесплатного пакета, отличной
документации и очень отзывчивой группы поддержки.

Существует несколько способов настройки БД на MongoLab. Самый быстрый
и удобный из них — использовать дополнение посредством Heroku. Именно этим
мы здесь и займемся, однако при этом понадобится зарегистрировать на Heroku
реальную банковскую карту. Heroku заставляет вас делать это при использовании
его дополнений в своей экосистеме, чтобы защититься от злоупотреблений. Использование бесплатного пакета-«песочницы» MongoLab не влечет никаких расходов.
Если это вас не устраивает, загляните в следующую врезку, где рассказывается
о настройке MongoLab вручную.

РУЧНАЯ НАСТРОЙКА MONGOLAB _______________________________________________
Если не хотите, вам не обязательно использовать систему дополнений Heroku. Лучше
всего настроить в облаке базу данных MongoDB и получить строку соединения для нее.
Можете воспользоваться документацией MongoLab, которая направит вас на верный
путь: http://docs.mongolab.com/.
Вкратце шаги выполнения таковы.
1. Зарегистрироваться для получения бесплатной учетной записи.
2. Создать новую БД (для бесплатного пакета необходимо выбрать Single Node, Sandbox).
3. Добавить пользователя.
4. Получить URI базы данных (строку соединения). Строка соединения будет выглядеть так:
mongodb://dbuser:dbpassword@ds059957.mongolab.com:59957/loc8r-dev
Конечно, все части у вас будут иными и вам придется заменить имя пользователя и пароль теми, которые вы задали на шаге 3.
Как только у вас будет полная строка соединения, ее желательно сохранить в качестве
части конфигурации Heroku. Это можно сделать следующей командой (командная строка терминала должна находиться в корневом каталоге вашего приложения):
$ heroku config:set MONGOLAB_URI=your_db_uri
Замените your_db_uri полной строкой соединения, включая протокол mongodb://. Автоматически выполнить настройку MONGOLAB_URI в вашей конфигурации Heroku можно быстро и легко. Эти выполняемые вручную шаги приведут вас к тому же результату,
что и упомянутый быстрый способ, и теперь вы можете вернуться к основному тексту.

Добавление MongoLab в приложение Heroku
Самый быстрый способ добавить MongoLab в качестве дополнения Heroku — через
терминал. Убедитесь, что вы находитесь в корневом каталоге своего приложения,
и выполните следующую команду:
$ heroku addons:add mongolab

Невероятно, но факт! База данных MongoDB готова и ждет вас в облаке. Проверить это и открыть веб-интерфейс к новой БД можно с помощью следующей
команды:
$ heroku addons:open mongolab
Для использования БД необходимо знать ее URI.
Получение URI базы данных
Получить полный URI базы данных можно с помощью командной строки. Благодаря этому способу вы получите полную строку соединения, которую можно будет
использовать в приложении, а также увидите различные компоненты, которые
пригодятся при внесении данных в БД.
Команда для получения URI базы данных:
$ heroku config:get MONGOLAB_URI
Эта команда выведет полную строку соединения, которая будет выглядеть примерно так:
mailto:mongodb://heroku_app20110907:4rqhlidfdqq6vgdi06c15jrlpf@ds033669.
mongolab.com:33669/heroku_app20110907
Держите свой вариант этой строки под рукой, так как скоро вы будете использовать его в приложении. Прежде всего необходимо разложить его на составные
части.

Разложение URI на составные части
Хотя этот URI выглядит как случайная мешанина символов, его можно разделить
на составные части, чтобы понять смысл. Из раздела 5.1.2 нам известно, что URI
базы данных имеет следующую структуру:
Так что можете разложить полученный от MongoLab URI на следующие составные части:
	имя пользователя — heroku_app20110907;
	пароль — 4rqhlidfdqq6vgdi06c15jrlpf;
	адрес сервера — ds033669.mongolab.com;
	порт — 33669;
	название базы данных — heroku_app20110907.

Все это взято из приведенного здесь примера URI, так что у вас части будут
другими. Запишите их, они вам пригодятся.
5.5.2. Помещение данных в базу данных
Теперь, когда доступная извне БД настроена и все необходимые для соединения
с ней подробности известны, можно поместить в нее данные. Пошаговый план выполнения этой задачи таков.
1. Создать временный каталог для хранения дампа данных.
2. Выполнить дамп данных из БД версии Loc8r, предназначенной для разработки.
3. Восстановить данные в промышленную БД.
4. Протестировать промышленную БД.
Все эти шаги можно быстро выполнить через терминал, что мы и сделаем. Это
позволит избежать переключений между разными средами.

Создание временного каталога
Простейший первый шаг, который, если вам так удобнее, можете выполнить в интерфейсе операционной системы, состоит в создании временного каталога для
размещения дампа ваших данных. Следующая команда выполняет это в операционных системах Mac и Linux:
$ mkdir -p ~/tmp/mongodump
Теперь у вас есть куда поместить дамп данных.
Выполнение дампа данных из тестовой базы данных
Выполнение дампа выглядит так, как будто вы удаляете все из локальной, предназначенной для разработки БД, но это впечатление неверное. Процесс представляет собой скорее экспорт, а не очистку.
Для этого используется команда mongodump, принимающая три входных параметра:
	-h — сервер, на котором располагается приложение (и порт);
	-d — название базы данных;
	-o — целевой каталог для вывода.
Собрав все это воедино и используя порт MongoDB по умолчанию — 27017, вы
должны получить следующую команду:
$ mongodump -h localhost:27017 -d Loc8r -o ~/tmp/mongodump
Выполнив ее, вы получите промежуточный дамп данных.

Восстановление данных в промышленную базу данных
Процесс помещения данных в реальную БД аналогичен выполнению дампа, только вместо mongodump используется команда mongorestore. На входе она ожидает
следующих параметров:
	-h — промышленный сервер и порт;
	-d — название промышленной БД;
	-u — имя пользователя для промышленной БД;
	-p — пароль для промышленной БД.
Собрав все это воедино и используя имеющуюся информацию об URI базы
данных, вы должны получить следующую команду:
$ mongorestore -h ds033669.mongolab.com:33669 -d heroku_app20110907 -u
heroku_app20110907 -p 4rqhlidfdqq6vgdi06c15jrlpf ~/tmp/mongodump/Loc8r
Конечно, ваш вариант будет несколько иным, поскольку у вас другие сервер,
название промышленной БД, имя пользователя и пароль. Когда выполните команду mongorestore, она поместит данные из дампа в вашу БД.

Тестирование промышленной базы данных
Возможности командной оболочки MongoDB не ограничиваются обращением
к базам данных на вашей локальной машине. Командную оболочку можно использовать и для соединения с внешними базами данных, если, конечно, у вас имеются
нужные учетные данные.
Для соединения командной оболочки MongoDB с внешней БД используется
та же команда mongo, только добавляется информация о БД, к которой вы хотите
подключиться. Необходимо включить в параметры имя сервера, порт и название
БД. Также при необходимости можно указать имя пользователя и пароль. Целиком
структура этой команды выглядит следующим образом:
$ mongo hostname:port/database_name -u username -p password
Например, при использовании рассматриваемых нами в этой главе настроек мы
получим такую команду:
$ mongo ds033669.mongolab.com:33669/heroku_app20110907 -u
heroku_app20110907 -p 4rqhlidfdqq6vgdi06c15jrlpf
Она соединит вас с БД через командную оболочку MongoDB. После установления соединения можете использовать уже знакомые вам команды для ее опроса:
> show collections
> db.locations.find()
Теперь у вас имеются две базы данных и две строки соединения, и очень важно
всегда использовать правильную.

Заставляем приложение использовать
правильную базу данных
Итак, у вас есть исходная, предназначенная для разработки БД на локальной машине и новая промышленная БД вMongoLab (или где-то еще). Хотелось бы продолжать
использовать тестовую БД при разработке приложения, но необходимо, чтобы промышленная версия приложения применяла промышленную БД. Однако обе они
используют один и тот же исходный код. Данную проблему иллюстрирует рис. 5.12.

<img src="https://ltdfoto.ru/images/2024/08/10/imageef8173734ecb50eb.png" alt="imageef8173734ecb50eb.png" border="0" />

Итак, у нас имеется один набор исходного кода, выполняемый в двух средах,
каждая из которых должна использовать свою БД. Справиться с проблемой можно
с помощью переменной среды Node NODE_ENV.
Переменная среды NODE_ENV
Переменные среды влияют на то, как выполняется основной процесс. Та из них,
которую мы хотим рассмотреть и использовать, — NODE_ENV. Приложение уже использует NODE_ENV, вы просто пока что нигде ее не видели. По умолчанию Heroku
устанавливает для переменной NODE_ENV значение production, чтобы приложение
на их серверах работало в промышленном режиме.
ПРОВЕРЯЕМ, ИСПОЛЬЗУЕТ ЛИ HEROKU ПРОМЫШЛЕННЫЙ РЕЖИМ __________
В определенных случаях в зависимости от настроек приложения � �ku может не работать в промышленном режиме. Убедиться, что переменные среды настроены правильно,
можно с помощью следующей команды терминала:
$ heroku config:set NODE_ENV=production

Прочитать NODE_ENV из любого места приложения можно с помощью следующего
оператора:
process.env.NODE_ENV
Если эта переменная не задана в вашей среде, то он вернет undefined. Задать
различные переменные среды можно при запуске приложения Node, вставив в начале команды запуска присваивание, например:
$ NODE_ENV=production nodemon
Эта команда запустит приложение в промышленном режиме, а значение
process.env.NODE_ENV будет установлено равным production.
СОВЕТ __________________________________________________________________________
Не устанавливайте переменную NODE_ENV из приложения, только читайте ее.
Задание URI базы данных в зависимости от среды
Соединение БД для нашего приложения находится в файле db.js в каталоге
app_server/models. Относящаяся к соединению часть этого файла в настоящий
момент выглядит следующим образом:
var dbURI = 'mongodb://localhost/Loc8r';
mongoose.connect(dbURI);
Для изменения значения dbURI в заДля изменения значения dbURI в зависимости от текущей среды достаточно
всего лишь воспользоваться оператором if для проверки значения NODE_ENV.
В следующем фрагменте кода показано, как выполнить это для передачи соединения с промышленной MongoDB. Обратите внимание на то, что вам нужно использовать свою собственную строку соединения, а не приведенную в примере:
var dbURI = 'mongodb://localhost/Loc8r';
if (process.env.NODE_ENV === 'production') {
dbURI = 'mongodb://
heroku_app20110907:4rqhlidfdqq6vgdi06c15jrlpf@ds033669.mongolab.com:3366
9/heroku_app20110907';
}
mongoose.connect(dbURI);
Если исходный код будет находиться в общедоступном репозитории, вы, вероятно, не захотите показывать всем свои учетные данные для БД. Обойти это можно с помощью переменной среды. Благодаря MongoLab на Heroku у вас уже есть
одна настроенная переменная — именно так мы ранее получили доступ к строке
соединения (если вы настроили учетную запись MongoLab вручную, это настроенная вами переменная конфигурации Heroku). Если же вы используете другого
провайдера, не добавляющего ничего к конфигурации Heroku, то можете указать

свой URI с помощью команды heroku config:set, которую мы использовали, чтобы убедиться, что Heroku выполняется в промышленном режиме.
Следующий фрагмент кода демонстрирует использование строки соединения,
задаваемой через переменные среды:
var dbURI = 'mongodb://localhost/Loc8r';
if (process.env.NODE_ENV === 'production') {
dbURI = process.env.MONGOLAB_URI;
}
mongoose.connect(dbURI);
Это значит, что теперь вы можете использовать код совместно, но доступ к вашим
учетным данным для БД будет только у вас.

Тестирование перед пуском
Путем задания переменной среды при запуске приложения из терминала можно
протестировать эти модернизации кода до отправки его на Heroku. События соединения Mongoose, которые мы настроили ранее, выводят журнал в консоль при
выполнении соединения с БД для контроля используемого URI.
Обычный запуск приложения из терминала выглядит вот так:
$ nodemon
Express server listening on port 3000
Mongoose connected to mongodb://localhost/Loc8r
Для сравнения: запуск приложения в промышленном режиме выглядит следующим образом:
$ NODE_ENV=production nodemon
Express server listening on port 3000
Mongoose connected to mongodb://
heroku_app20110907:4rqhlidfdqq6vgdi06c15jrlpf@ds033669.mongolab.com:33669/
heroku_app20110907
Вероятно, при выполнении этих команд вы обратили внимание на то, что подтверждение соединения Mongoose появляется в промышленной среде через значительный промежуток времени. Это происходит из-за задержки использования
отдельного сервера для БД. Именно поэтому стоит открывать соединение с БД при
запуске приложения и оставлять его открытым.
Отмечу, что предыдущая проверка промышленной среды может завершиться
неудачей в некоторых версиях Windows и в редких случаях в Linux. Это происходит,
если ваша система не в состоянии извлечь переменные среды Heroku. При этом вы
все равно можете выполнить тестирование промышленной БД с помощью вставки
MONGOLAB_URI в начало команды запуска приложения (start), как в следующем фрагменте кода (обратите внимание: его необходимо ввести в виде одной строки):
$ NODE_ENV=production MONGOLAB_URI=mongodb://
<span class="code">&lt;username>:&lt;password>@&lt;hostname>:&lt;port>/&lt;database> nodemon start</span>

Теперь вне зависимости от используемой операционной системы вы сможете
запустить приложение локально, подключив его к промышленной БД.
Тестирование на Heroku
Если локальные проверки прошли успешно и вы можете подключиться к удаленной
БД посредством временного запуска приложения в промышленном режиме, значит,
вы готовы отправить его на Heroku. Воспользуйтесь теми же командами, что и обычно, для отправки туда последней версии кода:
$ git add .
$ git commit –m "Сообщение, описывающее детали коммита"
$ git push heroku master
Heroku позволяет вам с легкостью взглянуть на последние 100 строк журналов
с помощью выполнения команды терминала. Можно заглянуть в эти журналы,
чтобы увидеть вывод журнальных сообщений вашей консоли, одним из которых
будет сообщение Mongoose connected to…. Для отображения журналов выполните
в терминале следующую команду:
$ heroku logs
Она выведет последние 100 строк в окно терминала, самые последние строки
будут внизу. Прокрутите окно до сообщения Mongoose connected to…, которое
будет выглядеть примерно так:
2014-03-08T08:19:42.269603+00:00 app[web.1]: Mongoose connected to mongodb://
heroku_app20110907:4rqhlidfdqq6vgdi06c15jrlpf@ds033669.mongolab.com:33669/heroku_app20110907
Если вы это видите, значит, промышленное приложение на Heroku подключилось к вашей промышленной БД.
Итак, данные описаны и промоделированы, а наше приложение Loc8r подключилось к БД. Но мы пока что совсем не взаимодействовали с БД — это нам предстоит позже!



























